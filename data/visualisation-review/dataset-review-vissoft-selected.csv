Ref.,ID,Title,First Author,Paper Year,Abstract,Name,Questions,Goal,Topic,Category,Task,Target,Audience,Representation,Medium,# Pages,Available,Java?,"PlataformWindows",Linux,Mac,Web,License,Source available,Framework,Target Technology,Venue
S1,338,Kayrebt: An Activity Diagram Extraction and Visualization Toolset Designed for the Linux Codebase,"Georget, L.",2015,"We present Extractor and Viewer, two tools from the Kayrebt toolset. The former is a plugin for the Gnu Compiler Collection (GCC) which builds pseudo-UML2 activity diagrams from C source code. It is specifically designed to handle the Linux kernel, a large and complex codebase. Use cases for this tool are numerous. The diagrams extracted from the C source code can be used to get a better insight of the control or data flow inside a program, or to evaluate the complexity of a function at a glance. Kayrebt::Viewer is a GUI designed for visualizing and navigating between the diagrams to explore source code.",Kayrebt,,to get a better insight of the control or data flow inside a program,Element relationship,"Control flow, Data flow",Reverse Engineering,Source Code,user,Stacked,Not identified,5,https://github.com/lgeorget/Kayrebt-Dumper,,N,Y,N,N,ARR,Y,"Extractor, Globsym, Viewer",C,VISSOFT
S2,346,XVIZIT: Visualizing Cognitive Units in Spreadsheets,"Hodnigg, K.",2015,"Spreadsheets can be large and complex and their maintenance and comprehension difficult to end-users. Large numbers of cells, complex formulae and missing documentation can impede the understanding of a spreadsheet. Comprehension assesses different levels of a spreadsheet according to a specific maintenance task, ranging from single formulae over sets of cells to complex structural patterns. These levels of abstraction are subsumed under the term cognitive unit. XVIZIT helps end-users in maintaining and comprehending spreadsheets. It guides them through a spreadsheet model: Roles of cells and sheets, similar patterns and various concepts of modularity can be explored. It uses modularization algorithms to provide conceptional decompositions of a spreadsheet model, such as equivalence classes or data modules. XVIZIT’s slice visualizations ease the evaluation of corrective modifications by showing the dependant cells. Furthermore, XVIZIT provides a number of complexity measures allowing end-users to estimate the effort to comprehend and maintain a spreadsheet.",XVIZIT,"are there modules orself-contained computations?",,ND,ND,Programming,Spreadsheet,user,Standard,Not identified,5,https://xvizit.wordpress.com/portfolio/metrics-based-spreadsheet-visualization/,,Y,N,N,N,Free,N,"Java FX, Control FX, GraphStream",Excel and Numbers spreadsheet,VISSOFT
S3,319,Vestige: A Visualization Framework for Engineering Geometry-Related Software,"Schneider, T.",2015,"Geometry-related software is increasingly important in computational science and visual computing. Engineering such software is particularly challenging due to the size and complexity of the data it operates on. In this paper we present VESTIGE, a framework that employs visualization to address that challenge. VESTIGE targets four software engineering activities: (1) visualization-guided development, (2) monitoring and bug detection, (3) test oracle generation, and (4) debugging. We present five scenarios from our real-life experience as developers of geometry-related software that show how VESTIGE helps to improve the software development process. Integrating VESTIGE into the development workflow takes little effort and can have significant benefits.",Vestige,how the computation reached that result?,,TE,TE,Debugging,Source Code,developer,Geometrically-Transformed,Not identified,10,,,,,,,-,-,C++ OpenGL,"Language idenpendent, but requires to implementa specific protocol to send polygon data in JSON format using sockets ",VISSOFT
S4,320,Hierarchical Software Landscape Visualization for System Comprehension: A Controlled Experiment,"Fittkau, F.",2015,"In many enterprises the number of deployed applications is constantly increasing. Those applications – often several hundreds – form large software landscapes. The comprehension of such landscapes is frequently impeded due to, for instance, architectural erosion, personnel turnover, or changing require- ments. Therefore, an efficient and effective way to comprehend such software landscapes is required. The current state of the art often visualizes software landscapes via flat graph-based representations of nodes, applications, and their communication.In our ExplorViz visualization, we introduce hierarchical ab- stractions aiming at solving typical system comprehension tasks fast and accurately for large software landscapes. To evaluate our hierarchical approach, we conduct a controlled experiment comparing our hierarchical landscape visualization to a flat, state-of-the-art visualization. In addition, we thoroughly analyze the strategies employed by the participants and provide a package containing all our experimental data to facilitate the verifiability, reproducibility, and further extensibility of our results.We observed a statistically significant increase of 14 % in task correctness of the hierarchical visualization group compared to the flat visualization group in our experiment. The time spent on the system comprehension tasks did not show any significant differences. The results backup our claim that our hierarchical concept enhances the current state of the art in landscape visualization.",ExploreViz,which applications are duplicated on multiple nodes?,,ND,ND,Software Process Management,Documentation,user,Geometrically-Transformed,Standard,10,,,,,,,-,-,-,-,VISSOFT
S5,322,Interactive Tag Cloud Visualization of Software Version Control Repositories,"Greene, G.J.",2015,"Version control repositories contain a wealth of implicit information that can be used to answer many questions about a project’s development process. However, this information is not directly accessible in the version control archives and must be extracted and visualized. This paper describes ConceptCloud, a flexible, interactive browser for SVN and Git repositories. The main novelty of our approach is the combination of an intuitive tag cloud visualization with an underlying concept lattice that provides a formal structure for navigation. ConceptCloud sup- ports concurrent navigation in multiple linked but individually customizable tag clouds, which allows for multi-faceted repository browsing and for the construction of unique visualizations. We describe the mathematical foundations and implementation of our approach, and use ConceptCloud to quickly gain insight into the team structure and development process of two projects.",ConceptCloud,which developers collaborate?,,Changes,History,Programming,CVS,user,Iconic,Not identified,10,http://www.conceptcloud.org,,,,,,-,N,-,"SVN, GIT",VISSOFT
S6,327,"Blended, Not Stirred: Multi-concern Visualization of Large Software Systems","Dal Sasso, T.",2015,"While constructing and evolving software systems, developers generate directly and indirectly a large amount of data of diverse nature, such as source code changes, bug tracking information, IDE interactions, stack traces, etc. Often these diverse data sources are processed and visualized in isolation, leading to a partial view of systems.We present a blended approach to visualize several data “ingredients” at once, to give as complete an answer as possible to the question “What happened to the system in the last few days?”. The goal is to enable a quick and comprehensive assessment of what happened to a software system in any given time frame.",Blended City,what happened to our system recently?,,Changes,History,Reverse engineering,Changes,developer,"Stacked, Iconic",Not identified,10,,,,,,,-,-,Roassal,Smalltalk,VISSOFT
S7,336,Pixel-Oriented Techniques for Visualizing Next-Generation HPC Systems,"Cottam, J.",2015,"Visualization schemas need to be enhanced to support next-generation high-performance computing (HPC) environments. New HPC runtimes perform more actions in a unit of time, but they also perform a wider variety of actions. Existing schemas are too simple to illustrate the variety of information that HPC developers need. However, existing schemas can be extended in simple ways to become more effective for next-generation HPC environments. This paper presents extensions to the common Vampir style plot that use high-definition alpha composition and color weaving. These two techniques incorporate new detail into the traditional plot style, providing useful information for HPC developers.",Vampir,how different are work queues on different threads?,,TE,TE,Programming,Documentation,HPX developer,Dense Pixel,Not identified,5,,,,,,,-,-,-,HPX C++,VISSOFT
S8,339,SMNLV: A Small-Multiples Node-Link Visualization Supporting Software Comprehension by Displaying Multiple Relationships in Software Structure,"Abuthawabeh, A.",2015,"Software engineering tasks like understanding of (legacy) software, checking guidelines, finding structure, or re-engineering of existing software require the analysis of the static software structure. The optimal visualization of this structure depends on the task at hand. In general, the software structure is mapped to a graph and graph drawing algorithms are used for displaying the structure. The task of drawing these graphs becomes more involved if not only one type of relations, e.g., call graphs, but many relation types should be analyzed at the same time. We propose a small-multiples node-link visualization, where each small visualization shows the graph related to one edge type. The visualizations are synchronized using selection and coordinated views. Using a separate view for each of the relations provides additional analysis capabilities. The main advantage of this approach is, that optimized drawing algorithms can be used for each type of relationship while being able to display multiple relationships at the same time.",SMNLV,,to check guidelines and re-engineering of existing software,Element relationship,"Contracts, Dependencies",Reverse Engineering,Source Code,user,Geometrically-Transformed,"full HD display, tiled display (Wall Display)",5,,,,,,,-,-,"Java 8, Graphisto Toolkit, abego TreeLayout, NetBeans Visual Library.",Java,VISSOFT
S9,341,Live Visualization of GUI Application Code Coverage with GUITracer,"Molnar, A.J.",2015,"The present paper introduces the initial implemen- tation of a software exploration tool targeting graphical user interface (GUI) driven applications. GUITracer facilitates the comprehension of GUI-driven applications by starting from their most conspicuous artefact - the user interface itself. The current implementation of the tool can be used with any Java-based target application that employs one of the AWT, Swing or SWT toolkits. The tool transparently instruments the target application and provides real time information about the GUI events fired. For each event, call relations within the application are displayed at method, class or package level, together with detailed cover- age information. The tool facilitates feature location, program comprehension as well as GUI test creation by revealing the link between the application’s GUI and its underlying code. As such, GUITracer is intended for software practitioners developing or maintaining GUI-driven applications. We believe our tool to be especially useful for entry-level practitioners as well as students seeking to understand complex GUI-driven software systems. The present paper details the rationale as well as the technical im- plementation of the tool. As a proof-of-concept implementation, we also discuss further development that can lead to our tool’s integration into a software development workflow.",GUITracer ,how the GUI and the underlying code are related?,,Elements,Location,Programming,Source Code,"practitioners, students",Standard,Not identified,5,https://bitbucket.org/guiresearch/tools,,,,,,Free,Y,Java 6,"Java using AWT, Swing or SWT",VISSOFT
S10,344,Advancing Data Race Investigation and Classification through Visualization,"Koutsopoulos, N.",2015,"Data races in multi-threaded programs are a com- mon source of serious software failures. Their undefined behavior may lead to intermittent failures with unforeseeable, and in embedded systems, even life-threatening consequences. To mitigate these risks, various detection tools have been created to help identify potential data races. However, these tools produce thousands of data race warnings, often in text-based format, which makes the manual assessment process slow and error-prone.Through visualization, we aim to speed up the data race assessment process by reducing the amount of information to be investigated, and to provide a versatile interface that quality assurance engineers can use to investigate data race warnings. The ultimate goal of our integrated software suite, called RaceView, is to improve the usability of the data race information to such an extent that the elimination of data races can be incorporated into the regular software development process.",RaceView,how a specific code location can be reached via function calls?,,Elements,Concurrency,Debugging,Runtime,quality assurance engineers,Stacked,Not identified,5,,,,,,,-,-,Eclipse Visualization Toolkit (Zest),C,VISSOFT
S11,304,Visual Clone Analysis with SolidSDD,"Voinea, L.",2014,"We present SolidSDD, an integrated tool for the extraction and visual analysis of code clones. SolidSDD aims to simplify and speed up the entire process of clone extraction from code bases written in C, C++, Java, and C#, and visual analysis of the extracted results. To this end, we combine several scalable visualization techniques such as hierarchical edge bundles, table lenses, annotated text views, and linked views. We demonstrate SolidSDD for both fine-grained clone analysis and aggregated report production tasks on several large-scale code bases.",SolidSDD,how are clones distributed in system structure?,,TE,TE,Maintenance,Source Code,developer,"Dense Pixel, Stacked",Not identified,4,http://www.solidsourceit.com/index.html,,Y,N,N,N,Comm.,N,"C++ , OpenGL","C, C++, Java, and C#",VISSOFT
S12,305,Polyptychon: A Hierarchically-Constrained Classified Dependencies Visualization,"Daniel, D.T.",2014,"Architects and developers are often tasked with evaluating or maintaining unfamiliar software systems. Reverse engineering tools help extract relationships between the system parts as they exist instead of as documented. Though node-link diagrams have a straightforward correspondence with the graph- representable data generated, the scale and complexity of real- world data sets prevent efficient comprehension.This paper presents Polyptychon, an interactive node-link visualization designed for incremental exploration of dependency information. Given a hierarchical information space of software artifacts, Polyptychon constrains the visible dependencies to be related to the child nodes of a specified artifact node, called a view root. It then classifies these siblings as levelized, tangled and independent. It also includes context nodes, which are a filtered set of nodes elsewhere in the hierarchy that are related to the siblings. The context nodes are further grouped based on a project-specific partition function.The hierarchical constraints and partition function provide means to control the number of nodes displayed, while the dependency classification allows users to form a qualitative impression of the dependency structure. We demonstrate with examples from the Netty open source project. We conclude with areas of future work, in particular, as a basis of evolutionary dependency analysis.",Polyptychon,how the system is actually organized?,,Elements,Dependencies,Reverse Engineering,Source Code,architects and developers,Geometrically-Transformed,Not identified,4,,,,,,,-,-,D3,Java,VISSOFT
S13,310,ChronoTwigger: A Visual Analytics Tool for Understanding Source and Test Co-evolution,"Ens, B.",2014,"Applying visual analytics to large software systems can help users comprehend the wealth of information produced by source repository mining. One concept of interest is the co-evolution of test code with source code, or how source and test files develop together over time. For example, understanding how the testing pace compares to the development pace can help test managers gauge the effectiveness of their testing strategy. A useful concept that has yet to be effectively incorporated into a co-evolution visualization is co-change. Co-change is a quantity that identifies correlations between software artifacts, and we propose using this to organize our visualization in order to enrich the analysis of co-evolution. In this paper, we create, implement, and study an interactive visual analytics tool that displays source and test file changes over time (co-evolution) while grouping files that change together (co-change). Our new technique improves the analyst’s ability to infer information about the software development process and its relationship to testing. We discuss the development of our system and the results of a small pilot study with three participants. Our findings show that our visualization can lead to inferences that are not easily made using other techniques alone.",ChronoTwigger,what test files changed compared to source files at the beginning of a project?,,TE,TE,Testing,CVS,test manager,Geometrically-Transformed,Immersive 3D environment,10,,,,,,,-,-,"OpenGL, GLUT, VR Juggler",GIT,VISSOFT
S14,311,Visualizing the Evolution of Systems and Their Library Dependencies,"Kula, R.G.",2014,"System maintainers face several challenges stem- ming from a system and its library dependencies evolving separately. Novice maintainers may lack the historical knowledge required to efficiently manage an inherited system. While some libraries are regularly updated, some systems keep a dependency on older versions. On the other hand, maintainers may be unaware that other systems have settled on a different version of a library. In this paper, we visualize how the dependency relation between a system and its dependencies evolves from two perspectives. Our system-centric dependency plots (SDP) visualize the successive library versions a system depends on over time. The radial layout and heat-map metaphor provide visual clues about the change in dependencies along the system’s release history. From this perspective, maintainers can navigate to a library-centric dependants diffusion plot (LDP). The LDP is a time-series visualization that shows the diffusion of users across the different versions of a library. We demonstrate on real-world systems how maintainers can benefit from our visualizations through four case scenarios.",-,how the dependency relation between a system and its dependencies evolves?,,Changes,Implications,Maintenance,Source Code,maintainer,"Geometrically-Transformed, Iconic",Not identified,10,,,,,,,-,-,-,Java,VISSOFT
S15,262,The visualizations of code bubbles,"Reiss, S.P.",2013,"Code Bubbles is an integrated development environment that concentrates on the user experience. The environment is very visual and includes a number of different visualizations, both static and dynamic. We will demonstrate the environment and the various visualizations on a realistic scenario based on our current work",Code Bubbles,what other programmers are working on?,,Changes,Debugging,Debugging,Source Code,user,Dense Pixel,Not identified,4,http://cs.brown.edu/~spr/codebubbles/,,Y,Y,Y,N,Free,Y,-,Java,VISSOFT
S16,265,Visualizing software dynamicities with heat maps ,"Benomar, O.",2013,"Interactive software visualization offers a promising support for program comprehension, including program dynamicity. We present, the extension of an existing visualization tool with heat maps to explore the time and other dimensions of software. To this end, we first propose a framework to unify the two main software dynamicities, execution and evolution. Then, this unified framework is exploited to define a visualization environment based on heat maps. We illustrate our approach on two comprehension tasks: understanding the behavior of programmers during the evolution of an application and under- standing class contributions in use cases. The case studies show that the heat-map metaphor contributes to answer, more easily, many of the questions important to program comprehension.",VERSO,what are coworkers working on?,,Changes,"Teammates, History",Maintenance,"Source Code, Changes",developer,"Dense Pixel, Stacked, Geometrically-Transformed",Not identified,10,,,,,,,-,-,-,Java,VISSOFT
S17,267,DEVis: A tool for visualizing software document evolution,Junji Zhi,2013,"During the software development process many technical documents are produced. Such documents and their evolution history contain rich information about the development process. Analyzing these document changes may reveal regularities and anomalies which are helpful to understand the software system and its development process. In this paper, we propose DEVis, an interactive visualization tool to visualize the software documentation evolution and aid the tasks of analyzing software development process. We initially evaluated our tool using the knowledge task-based framework and discuss the challenging aspects and lessons learned during the development of DEVis.",DEVis,what kind of changes have been made?,,Changes,History,Software Process Management,Documentation,"manager, developer","Geometrically-Transformed, Iconic",Not identified,4,https://sites.google.com/site/junjizhi/devis_tool,,,,,,-,Y,G4P,-,VISSOFT
S18,268,SourceVis: Collaborative software visualization for co-located environments ,"Anslow, C.",2013,"Most software development tools and applications are designed from a single-user perspective and are bound to the desktop and Integrated Development Environments (IDEs). These tools and applications make it hard for developers to analyse and interact with software artifacts collaboratively. We present SourceVis – a multi-user collaborative software visualization application for use on large multi-touch tables. We describe the design and visualization features of SourceVis, present findings from a user study, and discuss the implications for building collaborative software visualization applications.",SourceVis,how many versions contain annotation classes?,,ND,ND,Maintenance,Source Code,developer,"Geometrically-Transformed, Stacked",Large multi-touch tables,10,,,,,,,-,-,"MT4j, OpenCloud, JFreeChart",,VISSOFT
S19,275,SYNCTRACE: Visual thread-interplay analysis,"Karran, B.",2013,"In software comprehension, program traces are important to gain insight into certain aspects of concurrent runtime behavior, e.g., thread-interplay. Here, key tasks are finding usages of blocking operations, such as synchronization and I/O operations, assessing temporal order of such operations, and analyzing their effects. This is a hard task for large and complex program traces due to their size and number of threads involved. In this paper, we present SYNCTRACE, a new visualization technique based on (bended) activity diagrams and edge bundles that allows for parallel analysis of multiple threads and their inter-thread correspondences. We demonstrate how the technique, implemented as a tool, can be applied on real-world trace datasets to support understanding concurrent behavior.",SYNCTRACE,where and when a thread waits or releases?,,Elements,Concurrency,Maintenance,Runtime,user,"Dense Pixel, Geometrically-Transformed",Not identified,10,,,,,,,-,-,-,-,VISSOFT
S20,281,Automatic categorization and visualization of lock behavior,"Reiss, S.P.",2013,"We consider the problem of understanding locking behavior in large Java programs using a combination of data collection, data analysis, and visualization. Our technique starts by collecting partial information about all locks used in the program. It then analyzes this information to determine sets of locks with common behaviors and to deter- mine, for each set of locks, how that lock is used, e.g. if it is used as a mutex, semaphore, read-write lock, etc. The result of the analysis is then presented to the user who can select specific locks for full analysis during a subsequent run.Visualizing locking information is particularly difficult since the time scale of a lock can be ten or more orders of magnitude different from the time scale of the overall run and locks can be used millions of times. We provide different visu- alizations and visualization techniques for this purpose. First, we analyze either the partial or full traces and identify pat- terns of how each lock is used and display just those patterns along with their frequency. Second, we provide a thread-cen- tric view of locking that supports fish-eye views at the micro- second level as well as time compression. Third, we provide a lock-centric view that is based on the specific type of lock to show its particular behavior.",-,how much time is spent blocking on a specific lock?,,Elements,Concurrency,Programming,Runtime,programmer,"Dense Pixel, Geometrically-Transformed",Not identified,10,,,,,,,-,-,-,Java,VISSOFT
S21,288,Chronos: Visualizing slices of source-code history,"Servant, F.",2013,"In this paper, we present CHRONOS—a tool that enables the querying, exploration, and discovery of histori- cal change events to source code. Unlike traditional Revision- Control-System tools, CHRONOS allows queries across any subset of the code, down to the line-level, which can potentially be contiguous or disparate, even among multiple files. In addition, CHRONOS provides change history across all historical versions (i.e., it is not limited to a pairwise “diff”). The tool implements a zoom-able user interface as a visualization of the history of the queried code to provide both a high-level view of the changes, which supports pattern recognition and discovery, and a low- level view that supports semantic comprehension for tasks such as reverse engineering and identifying design rationale. In this paper, we describe use cases in which CHRONOS may be helpful, provide a motivating example to demonstrate the benefits brought by CHRONOS, and describe its visualization in detail.",Chronos,"when, how, by whom, and why was this code changed or inserted?",,Changes,History,Reverse Engineering,CVS,developer,Geometrically-Transformed,Not identified,4,,,,,,,-,-,Java,"CVS, SVN and Git",VISSOFT
S22,252,Visual support for porting large code bases,"Broeksema, B.",2011,"We present a tool that helps C/C++ developers to estimate the effort and automate software porting. Our tool supports project leaders in planning a porting project by showing where a project must be changed, how many changes are needed, what kinds of changes are needed, and how these interact with the code. For developers, we provide an overview of where a given file must be changed, the structure of that file, and close interaction with typical code editors. To this end, we integrate code querying, program transformation, and software visualization techniques. We illustrate our solution with use-cases on real-world code bases.",Kdevelop,which code fragments are affected by a given rewrite rule?,,Changes,Implications,Maintenance,Source Code,"project leader, developers","Dense Pixel, Geometrically-Transformed",Not identified,8,http://www.gitorious.org/kdevcpptools/kdevcpptools,,,,,,-,Y,C++,C/C++,VISSOFT
S23,254,Visualising concurrent programs with dynamic dependence graphs,"Lonnberg, J.",2011,"Atropos is a software tool for visualising concurrent program executions intended to help students debug concurrent programs and learn how concurrency works. Atropos supports a slicing debugging strategy by providing a visualisation of dynamic dependence graphs that can be explored to trace the chain of events backwards from a symptom to its cause. In this paper, we present the reasoning behind the design of Atropos and summarise how we evaluated it with students.",Atropos,how the operations performed during the execution?,,ND,ND,Programming,Runtime,students,Geometrically-Transformed,Not identified,4,http://www.cse.hut.fi/en/research/LeTech/Atropos/,,,,,,Free,Y,-,-,VISSOFT
S24,257,"Visual exploration of program structure, dependencies and metrics with SolidSX","Reniers, D.",2011,"We present SolidSX, an visual analysis tool for code structure, dependencies, and metrics. Our tool facilitates the understanding of large program code bases by simplifying the entire pipeline from data acquisition up to visualization and interactive querying. Secondly, SolidSX is an easy to use, scalable, and configurable visualization component for compound attributed graphs extracted by third-party tools, easy to integrate by devel- opers in their own applications. We detail the architecture and functions of SolidSX, present examples for its two use-cases, and outline insights collected from tool usage in academia and industry.",SolidSX,,to explore large compound attributed graph for program comprehension,Element relationship,Dependencies,Reverse Engineering,Source Code,"developer, end-user","Dense Pixel, Stacked, Geometrically-Transformed",Standard,4,http://www.solidsourceit.com,,,,,,Comm.,N,"OpenGL, GLUT, FTGL, wxWidgets",".NET/VB/C#, Java, and Visual C++",VISSOFT
S25,258,MosaiCode: Visualizing large scale software: A tool demonstration ,"Maletic, J.I.",2011,A software visualization tool called MosaiCode is introduced and described. MosaiCode uses a Seesoft metaphor to support the visualization and understanding of various characteristics for large scale software systems. A usage scenario is given to demonstrate the tool.,MosaiCode,what are areas of the code with high code churn?,,ND,ND,Maintenance,CVS,"project managers, system architects",Dense Pixel,Not identified,4,,,,,,,-,-,"C++,  Qt",-,VISSOFT
S26,117,An interactive ambient visualization for code smells,"Murphy-Hill, E.",2010,"Code smells are characteristics of software that indicate that code may have a design problem. Code smells have been proposed as a way for programmers to recognize the need for restructuring their software. Because code smells can go unnoticed while program- mers are working, tools called smell detectors have been devel- oped to alert programmers to the presence of smells in their code, and to help them understand the cause of those smells. In this paper, we propose a novel smell detector called Stench Blossom that provides an interactive ambient visualization designed to first give programmers a quick, high-level overview of the smells in their code, and then, if they wish, to help in understanding the sources of those code smells. We also describe a laboratory experiment with 12 programmers that tests several hypotheses about our tool. Our findings suggest that programmers can use our tool effectively to identify smells and to make refactoring judgements. This is partly because the tool serves as a memory aid, and partly because it is more reliable and easier to use than heuristics for analyzing smells",Stench Blossom,how widespread the feature envy is?,,Changes,Implications,Maintenance,Source Code,"programmers, designer",Iconic,Not identified,10,https://github.com/DeveloperLiberationFront/refactoring-tools/tree/master/installables/update_sites/stench_blossom,Y,Y,Y,Y,N,Free,Y,-,Java,SOFTVIS
S27,125,Exploring the inventor's paradox: applying jigsaw to software visualization,"Ruan, H.",2010,"Software visualization research has typically focussed on domain specific tools and techniques. In this paper, we evaluate applying a general purpose visual analytics tool Jigsaw to visualize the JHotDraw open source software system. We describe how Jigsaw can be applied to visualize software, and show how it can support some program comprehension tasks.",Jigsaw,what other entities are likely to de- pend on this package?,,Element relationship,Dependencies,Maintenance,Source Code,developers,"Geometrically-Transformed, Iconic",Not identified,10,http://www.cc.gatech.edu/gvu/ii/jigsaw/,Y,Y,Y,Y,N,Free,N,-,-,SOFTVIS
S28,127,Towards anomaly comprehension: using structural compression to navigate profiling call-trees,"Lin, S.",2010,"Developers must often diagnose anomalies in programs they only have a partial knowledge of. As a result, they must simultaneously reverse engineer parts of the system they are unfamiliar with while interpreting dynamic observation data (performance profiling traces, error-propagation chan- nels, memory leaks), a task particularly difficult. To support developers in this kind of comprehension task, filtering and aggregation have long been suggested as key enabling strategies. Unfortunately, traditional approaches typically only provide a uniform level of aggregation, thus limiting the ability of developers to construct context-dependent representations of a program’s execution. In this paper, we pro- pose a localised approach to navigate and analyse the CPU usage of little-known programs and libraries. Our method exploits the structural information present in profiling call trees to selectively raise or lower the local abstraction level of the performance data. We explain the formalism under- pinning our approach, describe a prototype, and present a preliminary user study that shows our tool has the potential to complement more traditional navigation approaches.",ProfVis,,to diagnose anomalies in programs based on partial knowledge,Changes,Implications,Reverse Engineering,Runtime,developers,Iconic,Not identified,10,http://ftaiani.ouvaton.org/7-software/profvis.html,Y,,Y,Y,,Free,Y,-,Java,SOFTVIS
S29,122,Heapviz: interactive heap visualization for program understanding and debugging,"Aftandilian, E.E.",2010,"Understanding the data structures in a program is crucial to understanding how the program works, or why it doesn’t work. Inspecting the code that implements the data struc- tures, however, is an arduous task and often fails to yield insights into the global organization of a program’s data. Inspecting the actual contents of the heap solves these prob- lems but presents a significant challenge of its own: finding an effective way to present the enormous number of objects it contains.In this paper we present Heapviz, a tool for visualizing and exploring snapshots of the heap obtained from a running Java program. Unlike existing tools, such as traditional de- buggers, Heapviz presents a global view of the program state as a graph, together with powerful interactive capabilities for navigating it. Our tool employs several key techniques that help manage the scale of the data. First, we reduce the size and complexity of the graph by using algorithms inspired by static shape analysis to aggregate the nodes that make up a data structure. Second, we introduce a dominator-based layout scheme that emphasizes hierarchical containment and ownership relations. Finally, the interactive interface allows the user to expand and contract regions of the heap to mod- ulate data structure detail, inspect individual objects and field values, and search for objects based on type or con- nectivity. By applying Heapviz to both constructed and real-world examples, we show that Heapviz provides pro- grammers with a powerful and intuitive tool for exploring program behavior.",Heapviz,"how the program works and why it doesn’t work?",,Changes,Debugging,Debugging,Runtime,programmers,Geometrically-Transformed,Not identified,10,,,,,,,-,-,Prefuse toolkit,Java,SOFTVIS
S30,124,Trevis: a context tree visualization & analysis framework and its use for classifying performance failure reports,"Adamoli, A.",2010,"When developers profile their applications to identify per- formance problems, they normally use profilers producing calling context trees. A calling context tree (CCT) represents the caller-callee relationships of a program. A dynam- ically collected CCT provides method coverage information. The CCTs produced by profilers also include method hot- ness information. Trevis, our context tree visualization and analysis framework, allows users to visualize, compare, cluster, and intersect CCTs produced by profilers. We evaluate Trevis in the context of a novel profiling tool called FlyBy. FlyBy runs transparently on an end-user’s computer and continuously samples the applications’ call stack. When the user perceives the application as sluggish, she presses a “Was Slow!” button to tell FlyBy to file a performance failure report. The report contains the CCT based on the call stack samples FlyBy gathered over the last few seconds before the user pressed the button. We show how Trevis allows us to visualize and classify FlyBy bug reports.",Trevis,"where the program spent most time andwhich methods were called?",,Elements,Performance,Testing,Runtime,developer,Stacked,Not identified,10,,,,,,,-,-,"Trevis, GraphViz",Java,SOFTVIS
S31,126,Dependence cluster visualization,"Islam, S.S.",2010,"Large clusters of mutual dependence have long been regarded as a problem impeding comprehension, testing, maintenance, and reverse engineering. An effective visualization can aid an engineer in addressing the presence of large clusters. Such a visualization is presented. It allows a program’s dependence clusters to be consid- ered from an abstract high level down thru a concrete source-level. At the highest level of abstraction, the visualization uses a heat-map (a color scheme) to efficiently overview the clusters found in an en- tire system. Other levels include three source code views that allow a user to “zoom” in on the clusters starting from the high-level sys- tem view, down through a file view, and then onto the actual source code where each cluster can be studied in detail.Also presented are two case studies, the first is the open-source calculator bc and the second is the industrial program copia, which performs signal processing. The studies consider qualitative evalu- ations of the visualization. From the results, it is seen that the visu- alization reveals high-level structure of programs and interactions between its components. The results also show that the visualiza- tion highlights potential candidates (functions/files) for re-factoring in bc and finds dependence pollution in copia.",Decluvi,,helps to quickly identify computations involved in clusters of dependence,Element relationship,Dependencies,Maintenance,Source Code,"maintainer developer, engineer",Dense Pixel,Standard,10,,,,,,,-,-,-,-,SOFTVIS
S32,128,Embedding spatial software visualization in the IDE: an exploratory study,"Kuhn, A.",2010,"Software visualization can be of great use for understanding and exploring a software system in an intuitive manner. Spatial representation of software is a promising approach of increasing interest. However, little is known about how de- velopers interact with spatial visualizations that are embed- ded in the IDE. In this paper, we present a pilot study that explores the use of Software Cartography for program com- prehension of an unknown system. We investigated whether developers establish a spatial memory of the system, whether clustering by topic offers a sound base layout, and how de- velopers interact with maps. We report our results in the form of observations, hypotheses, and implications. Key findings are a) that developers made good use of the map to inspect search results and call graphs, and b) that devel- opers found the base layout surprising and often confusing. We conclude with concrete advice for the design of embedded software maps.",CodeMap,which architectural paradigm is used?,,"CH, EL, ER","Testing, Debugging, Location, Intent and implementation, Architecture",Programming,Source Code,developer,Iconic,Not identified,10,http://github.com/akuhn/codemap,,,,,,MIT,Y,-,Java,SOFTVIS
S33,129,Visualizing windows system traces,"Wu, Y.",2010,"Operating system traces contain the detailed behavior of the persistent actions of an application; interactions between multiple applications; and the functioning of the system as a whole. The challenge is that such traces are large and consequently hard to understand and analyze. We present lviz, a novel visualization tool, which meets these challenges. We focus on Windows system traces though our visualization is general. Our visualization is flexible and can be customized to highlight different aspects of the behavior program(s) and the overall operating system.",lviz,how the operating system works to examine performance problems?,,TE,TE,Programming,Runtime,user,Dense Pixel,Not identified,10,,,,,,,-,-,OpenJDK 1.6.0 18 (64bit),VDP,SOFTVIS
S34,131,Zinsight: a visual and analytic environment for exploring large event traces,"de Pauw, W.",2010,"Information in event traces from software systems can help developers with performance analysis, debugging and troubleshooting. However, the volume of data contained in these traces can make such tasks a challenge. In this paper we propose a new tool, Zinsight, to visualize event traces from complex systems. Our contribution is a novel combination of visualizations and pattern extraction techniques, enabling user exploration, analysis and understanding of traces containing millions of events. Three complimentary views help the user answer different questions. First, the Event Flow view shows the trace in its entirety or in detail. The user sees visual patterns representing phases of processing and the relative order of events. Second, the Event Statistics view quantifies events, and presents distributions and averages enabling the user to identify outlier behavior. Third, the Sequence Context view extracts patterns of interest from the trace and represents them along with frequency and performance data in succinct execution flow diagrams. The user can navigate from patterns to their constituent instance sequences and even back to individual events in the other views. Questions can be answered and hypotheses tested using the most natural view for the task.",Zinsight,how did we get to these events?,,"CH, EL","Debugging, Performance",Debugging,Runtime,performance analyst,Dense Pixel,Not identified,10,http://researcher.watson.ibm.com/researcher/view_group.php?id=613,,,,,,Comm,N,-,IBM System z,SOFTVIS
S35,136,Representing development history in software cities,"Steinbrückner, F.",2010,In this paper we describe a systematic approach to utilize the city metaphor for the visualization of large software systems as evolving software cities. The main contribution is a new layout approach which explicitly takes the development history of software systems into account and makes history directly visible in the layouts. These layouts incrementally evolve in a very smooth and stable way during the development of the represented software system. They are used as a visualization platform for integrating a large variety of product and process data and thus create a coherent set of specialized visualizations. To illustrate this we present some example maps capturing specific development history aspects.,CrocoCosmos,what is the history of a piece of code?,,Elements,History,Reverse Engineering,CVS,"project manager, developer",Stacked,Not identified,10,,,,,,,-,-,jMonkeyEngine,Java,SOFTVIS
S36,242,Case study: Visual analytics in software product assessments,"Telea, A.",2009,"We present how a combination of static source code analysis, repository analysis, and visualization techniques has been used to effec- tively get and communicate insight in the development and project management problems of a large industrial code base. This study is an example of how visual analytics can be effectively applied to answer maintenance questions and support decision making in the software industry. We comment on the relevant findings during the study both in terms of used technique and applied methodology and outline the favorable factors that were essential in making this type of assessment successful within tight time and budget constraints.",-,why it was hard to add new features to the existing software?,,ND,ND,Software Process Management,CVS,"project managers, system architects","Dense Pixel, Stacked, Geometrically-Transformed",Not identified,8,,,,,,,-,-,-,Keil C166,VISSOFT
S37,89,Representing unit test data for large scale software development,"Cottam, J.A.",2008,"Large scale software projects rely on routine, automated testing to gauge progress towards its goals. The diversity and quantity of these tests grow as time and project scope increase. This is as a consequence of both experience and expanding audience. It be- comes increasingly difficult to interpret testing results as the testing suites multiply and diversify. If interpretation becomes too diffi- cult, testings results could become ignored all together. Visualization has proven to be an effective tool to aid the interpretation of large amounts of data. We have adapted visualization techniques based on small multiples to communicate the health of the soft- ware project across several levels of abstraction. The collective set of techniques we refer to as the SeeTest visualization schema. We applied this visualization technique to the Open MPI test results in order to assist developers in the software release cycle. Through the visualizations, developers found a variety of surprising mismatches between their data and their intuitions. This exploration did not involve collecting any data not already being collected, merely pre- senting it in manner that better supported their needs. In this paper, we detail the development of the representation we used and give more particular analysis of the insights gained by the Open MPI community. The techniques presented in this paper can be applied to other software projects.",SeeTest,how did the changes from yesterday effect the stability of the project?,,Changes,History,Testing,CVS,developer,"Geometrically-Transformed, Iconic",Not identified,10,,,,,,,-,-,Stencil visualization environment,-,SOFTVIS
S38,91,A catalogue of lightweight visualizations to support code smell inspection,"Parnin, C.",2008,"Preserving the integrity of software systems is essential in ensur- ing future product success. Commonly, companies allocate only a limited budget toward perfective maintenance and instead pres- sure developers to focus on implementing new features. Traditional techniques, such as code inspection, consume many staff resources and attention from developers. Metrics automate the process of checking for problems but produce voluminous, imprecise, and in- congruent results. An opportunity exists for visualization to assist where automated measures have failed; however, current software visualization techniques only handle the voluminous aspect of data but fail to address imprecise and incongruent aspects. In this paper, we describe several techniques for visualizing possible defects reported by automated inspection tools. We propose a catalogue of lightweight visualizations that assist reviewers in weeding out false positives. We implemented the visualizations in a tool called NOSEPRINTS and present a case study on several commercial sys- tems and open source applications in which we examined the im- pact of our tool on the inspection process.",NosePrints,where the value was originating from?,,Changes,Testing,Maintenance,Runtime,"project manager, developer",Dense Pixel,"1268 by 1048 resolution display, Wall Display, projection screen",10,,,,,,,-,-,-,-,SOFTVIS
S39,97,Streamsight: a visualization tool for large-scale streaming applications,"de Pauw, W.",2008,"Stream processing is becoming a new and important computing paradigm. Innovative streaming applications are being developed in areas ranging from scientific applications (e.g., environment monitoring), to business intelligence (e.g., fraud detection and trend analysis), to financial markets (e.g., algorithmic trading strategies). Developing, understanding, debugging, and optimizing streaming applications is non-trivial because of the adaptive and dynamic nature of these applications. The sheer complexity and the distributed character of a large number of cooperating components hosted on a distributed environment further complicate matters. In this paper we describe Streamsight, a new visualization tool built to examine, monitor, and help understand the dynamic behavior of streaming applications. Previously developed stream processing visualization tools focus solely on composition of dataflow graphs. Streamsight’s novelty hinges on a wide range of capabilities, including the ability to manage the dynamics of large and evolving topologies comprising multiple streaming applications with thousands of nodes and inter- connections. From rendering live performance counters using different perspectives to allowing recordings and replays of the execution process, Streamsight provides the mechanisms that permit a better understanding of the evolving and adaptive behavior of streaming applications. These capabilities are used for debugging purposes, for performance optimization, and management of resources, including capacity planning. More than 50 developers, both inside and outside IBM, have been using Streamsight.",Streamsight,what kind of hardware interconnect link technology to employ?,,TE,TE,Testing,Runtime,developer,Standard,Not identified,10,,,,,,,-,-,dot,IBM System S,SOFTVIS
S40,101,Stacked-widget visualization of scheduling-based algorithms,"Bernardin, T.",2008,"We present a visualization system to assist designers of scheduling- based multi-threaded out-of-core algorithms. Our system facilitates the understanding and improving of the algorithm through a stack of visual widgets that effectively correlate the out-of-core system state with scheduling decisions. The stack presents an increasing refinement in the scope of both time and abstraction level; at the top of the stack, the evolution of a derived efficiency measure is shown for the scope of the entire out-of-core system execution and at the bottom the details of a single scheduling decision are dis- played. The stack provides much more than a temporal zoom-effect as each widget presents a different view of the scheduling decision data, presenting distinct aspects of the out-of-core system state as well as correlating them with the neighboring widgets in the stack. This approach allows designers to to better understand and more effectively react to problems in scheduling or algorithm design.As a case study we consider a global illumination renderer and show how visualization of the scheduling behavior has led to key improvements of the renderer’s performance.",Lumiere,,to assist designers of scheduling-based multi-threaded algorithms,Elements,Concurrency,Programming,Runtime,designer,"Dense Pixel, Geometrically-Transformed",Not identified,11,,,,,,,-,-,-,-,SOFTVIS
S41,208,Visualizing Dynamic Memory Allocations,"Moreta, S.",2007,"We present a visualization tool for dynamic memory allocation information obtained from instrumenting the runtime allocator used by C programs. The goal of the presented visualization techniques is to convey insight in the dynamic behavior of the allocator The purpose is to help the allocator designers understand how the performance and working of the allocator depend on the actual allocation scenarios in order to optimize itsfunctionality by decreasing fragmentation and improving response time. We use an orthogonal dense pixel layout of time versus memory space which can show tens ofthousands of allocation events on  a single screen. We enhance the basic idea with several new techniques: anti aliased metric bars for detecting high and low activity areas; cushion cursors for checking correlations of multiple views; and a view to show correlation between program structure (functions) and memory allocations. The presented techniques are demonstrated on datafrom areal application.",MemoView,how does the allocator speed depend on type and parameters?,,Elements,Performance,Programming,Runtime,user,Dense Pixel,Not identified,8,,,,,,,-,-,-,-,VISSOFT
S42,223,A Visualization for Software Project Awareness and Evolution ,"Ripley, R.M.",2007,"Real-time awareness of other developers' activities is a powerful tool to assist in coordination of developer activities. Thus far; this type of awareness has focused only on individual developers,with information regarding individual artifacts provided in a contextualized visualization. Here, we build upon our prior work, but take a broader perspective: visualization and exploration of workspace activity and evolution on a project-wide basis. We believe this visualization helps project managers who now have a comprehensive view of a project activities, allowing them to intelligently steer development and adjust task assignments. Developers can also benefitfrom this high level view by understanding how their work relates with each other and to the project as a whole. Another interesting aspect of our work is that we can visualize the evolution ofworkspaces and the emergent project evolution either live or postmortem: since our tool stores the workspaces' events, we can replay, stop, rewind, and visually inspect the effort at any given point in time to find trends, problems, and other patterns of interest.",Paladir,when was the artifact changed?,,Changes,History,Software Process Management,CVS,Everyone involved in software development. From coders to managers.,Iconic,"The medium of the visualization ranges from a small window in the corner of a developer's or manager's desktop, to an entire monitor, to a wall-sized display. Again, by having the same visualization usable across a range of mediums maintains continuity as interaction modes change.",8,,,,,,,-,-,Palantir,Java,VISSOFT
S43,43,Experimental evaluation of animated-verifying object viewers for Java,"Jain, J.",2006,"Although many visualization techniques have been shown to be pedagogically effective, they are still not widely adopted. The reasons include: lack of suitable methods of automatic-generation of visualizations, lack of integration among visualizations, and lack of integration with basic integrated development environment (IDE) support. To effectively use visualizations when developing code, it is useful to automatically generate multiple synchronized views without leaving the IDE. The jGRASP IDE provides object viewers that automatically generate dynamic, state-based visualizations of objects and primitive variables in Java. Such seamless integration of a lightweight IDE with a set of pedagogically effective software visualizations is unique and is currently unavailable in any other environment. Multiple instructors have reported positive anecdotal evidence of their usefulness. We conducted formal, repeatable experiments to investigate the effect of these viewers for singly linked lists on student performance and we found a statistically significant improvement over traditional methods of visual debugging that use break-points.",jGrasp,,to understand concepts of dynamic programming implementation,ND,ND,Programming,Runtime,students,Standard,Not identified,10,http://www.jgrasp.org/,,Y,Y,Y,N,-,N,-,Java,SOFTVIS
S44,44,Execution patterns for visualizing web services,"de Pauw, W.",2006,"Web Services are well on their way to becoming the Lingua Franca for distributed computing. Although tools for building and monitoring web services applications are more powerful and easier to use than ever, they do not yet fully address the horizontal complexity of mature applications built as large nets of interconnected web services. We present a pattern-based visualization that enables business owners, application designers, programmers, and operations staff to quickly understand the behavior of complex web services applications. We describe a novel pattern extraction algorithm that captures important trends from web services execution traces. We demonstrate a new way to visualize these patterns that shows the behavior of web services applications at different levels of abstraction. Finally, we explain how this can help developers with performance analysis by showing both the averages and variations in the data contained in each pattern.",IBM WS Navigator,where most of the time is being spent?,,Elements,Performance,Maintenance,Runtime,"achitect, developer, business owner, tester, designer, programmer, operation staff","Standard, Geometrically-Transformed",Not identified,9,,,,,,,-,-,-,-,SOFTVIS
S45,45,Visualizing live software systems in 3D,"Greevy, O.",2006,"The analysis of the runtime behavior of a software system yields vast amounts of information, making accurate interpretations diffi- cult. Filtering or compression techniques are often applied to re- duce the volume of data without loss of key information vital for a specific analysis goal. Alternatively, visualization is generally accepted as a means of effectively representing large amounts of data. The challenge lies in creating effective and expressive visual representations that not only allows for a global picture, but also enables us to inspect the details of the large data sets. We define the focus of our analysis to be the runtime behavior of features. Static structural visualizations of a system are typically represented in two dimensions. We exploit a third dimension to visually rep- resent the dynamic information, namely object instantiations and message sends. We introduce a novel 3D visualization technique that supports animation of feature behavior and integrates zoom- ing, panning, rotating and on-demand details. As proof of concept, we apply our visualization technique to feature execution traces of an example system.",TraceCrawler,which parts of the code are active during the execution of a feature?,,"EL, ER","Location, Control flow",Reverse Engineering,Runtime,"developer, engineer",Geometrically-Transformed,Standard,10,,,,,,,-,-,CCJun,Smalltalk,SOFTVIS
S46,50,Visual exploration of function call graphs for feature location in complex software systems,"Bohnet, J.",2006,"Maintenance, reengineering, and refactoring processes of software systems are typically driven and organized in terms of features. Feature change requests need to be translated into changes in source code, which is a highly cost intensive and time consuming task when complex legacy software systems are concerned; their documentation is likely to be outdated and incomplete. In this paper, we propose a prototype tool that supports users in locating and understanding feature implementation in large (>1 MLOC) C/C++ systems. A combination of static and dynamic analysis allows extracting of the function call graph during feature execution and interpreting it within the static architecture of the system. An interactive multi-view visualization enables users to explore that graph. An effective 21⁄2D visualization provides various visual cues that facilitate finding those paths in the function call graph that are essential for understanding feature functionality. Additionally to source code aspects, the dynamic metric of function execution times is exploited, which gives significant hints to feature-implementing functions. Furthermore, information on functions is extended by architectural aspects, thereby supporting users in remaining oriented during their analysis and exploration task as they can give priority to selected architectural components and thereby hide insignificant function calls.",Call Graph Analyzer,which the important functions for feature understanding are?,,Changes,Debugging,Debugging,Runtime,developers,Standard,Not identified,10,,,,,,,-,-,GraphViz,C/C++,SOFTVIS
S47,52,Multiscale and multivariate visualizations of software evolution,"Voinea, L.",2006,"Software evolution visualization is a promising technique for assessing the software development process. We study how complex correlations of software evolution attributes can be made using multivariate visualization techniques. We use a combination of color and textures to depict up to four artifact attributes at the same time in one view using the same spatial layout. Next, we describe an interactive navigation method of the attribute space that can extend the correlation capabilities to four or more attributes. A second issue we address is how to use clustering to reduce the complexity of evolution visualizations. We propose two new methods, isometric and isorelevance, to generate relevant abstraction levels in a hierarchical clustering of software evolution artifacts. The isometric method generates partitions with similar size elements. The isorelevance method generates partitions with elements of similar relevance. We propose a novel widget, the cluster map, which visualizes all partitions in a clustering and supports users when making size/relevance compromises when choosing a partition. We illustrate the applicability of the proposed techniques with two usage scenarios on the evolution of two real-life industry size projects.",CVSgrab,"what versions, with these words in the log, were committed by that her?",,Changes,History,Reverse Engineering,CVS,developer,Dense Pixel,Not identified,10,,,,,,,-,-,-,-,SOFTVIS
S48,25,CVSscan: visualization of code evolution,"Voinea, L.",2005,"During the life cycle of a software system, the source code is changed many times. We study how developers can be enabled to get insight in these changes, in order to understand the status, history and structure better, as well as for instance the roles played by various contributors. We present CVSscan, an integrated multiview environment for this. Central is a line- oriented display of the changing code, where each version is represented by a column, and where the horizontal direction is used for time, Separate linked displays show various metrics, as well as the source code itself. A large variety of options is provided to visualize a number of different aspects. Informal user studies demonstrate the efficiency of this approach for real world use cases.",CVSscan,which parts of the code are unstable?,,Changes,History,Maintenance,CVS,"developer, maintainer, project manager, tester, new team members, architect",Dense Pixel,Standard,11,http://www.win.tue.nl/vis1/home/lvoinea/VCN.html,,Y,N,N,N,Free,N,-,-,SOFTVIS
S49,32,Jove: java as it happens,"Reiss, S.P.",2005,"Dynamic software visualization is designed to provide programmers with insights as to what the program is doing. Most current dynamic visualizations either use program traces to show information about prior runs, slow the program down substantially, show only minimal information, or force the programmer to indicate when to turn visualizations on or off. We have developed a dynamic Java visualizer that provides a statement-level view of a Java program in action with low enough overhead so that it can be used almost all the time by programmers to understand what their program is doing while it is doing it.",Jove,what the software is doing when performance issues arise?,,Changes,Debugging,Debugging,Runtime,programmer,"Geometrically-Transformed, Iconic, Stacked",Not identified,11,http://cs.brown.edu/~spr/,,Y,Y,Y,N,Free,Y,-,Java,SOFTVIS
S50,30,Methodology and architecture of JIVE,"Gestwicki, P.",2005,"A novel approach to the runtime visualization and analy- sis of object-oriented programs is presented and illustrated through a prototype system called JIVE: J ava I nteractive V isualization E nvironment. The main contributions of JIVE are: multiple concurrent representations of program state and execution history; support for forward and reverse exe- cution; and graphical queries over program execution. This model facilitates program understanding and interactive de- bugging. Our visualization of runtime states clarifies the important point that objects are environments of execution. The history of object interaction is displayed via sequence diagrams, and in this way we help close the loop between design-time and run-time representations. Interactive exe- cution is made possible by maintaining a runtime history database, which may be queried for information on vari- able behavior, method executions, and object interactions. We illustrate the capabilities of this system through exam- ples. JIVE is implemented using the Java Platform Debugger Architecture and supports the Java language and libraries, including multithreaded and GUI applications.",Jive,,runtime comprehension of object-oriented programs,Changes,Debugging,Debugging,Runtime,engineer,Standard,Not identified,10,http://cs.brown.edu/~spr/research/vizjive.html,,Y,Y,Y,N,Free,Y,-,Java,SOFTVIS
S51,184,Visual Exploration of Combined Architectural and Metric Information,"Termeer, M. ",2005,"We present MetricView,a software visualizationand exploration tool that combines traditional UML diagram visualization with metric visualization in an efective way. MetricViewisvery easy and natural to use for software architects and developers yet ofers apowerful set of mechanisms that allow fine customization of the visualizations forgetting specific insights. We discuss several visual and architectural design choices which turned out to be important in the constructionof MetricView,and illustrate our approach with several results using real-life datasets.",MetricView,what happens If I change this component?,,Changes,Implications,Programming,Documentation,architects and developers,Iconic,Standard,6,http://www.win.tue.nl/san/projects/empanada/metricview/,N,Y,,,,Free,N,"C++, OpenGL, FreeType, wxWindows",-,VISSOFT
S52,24,Visual data mining in software archives,"Burch, M.",2005,Software archives contain historical information about the development process of a software system. Using data mining techniques rules can be extracted from these archives. In this paper we discuss how standard visualization techniques can be applied to interactively explore these rules. To this end we extended the standard visualization techniques for association rules and sequence rules to also show the hierarchical order of items. Clusters and outliers in the resulting visualizations provide interesting insights into the relation between the temporal development of a system and its static structure. As an example we look at the large software archive of the MOZILLA open source project. Finally we discuss what kind of regularities and anomalies we found and how these can then be leveraged to support software engineers.,EPOSee,what items have been changed at the same time?,,Changes,History,Reverse Engineering,CVS,engineer,"Dense Pixel, Geometrically-Transformed",Not identified,10,http://www.st.uni-trier.de/eposoft/eposee/,,Y,Y,Y,N,GPL,Y,-,-,SOFTVIS
S53,26,The war room command console: shared visualizations for inclusive team coordination,"O'Reilly, C.",2005,"Making the structure of software visible during system develop- ment helps (i) build a shared understanding of the context for each piece of work, (ii) identify progress with implementation, and (iii) highlight any conflict between individual development activities. Finding an adequate representation for such information is not straightforward, especially for large applications. This paper de- scribes an implementation of such a visualization system designed to explore some of the issues involved. The approach is based on a ‘War Room Command Console’ metaphor and uses a bank of eight linked consoles to present information. The tool was applied to several industrial software systems written in a mixture of Java, C++ and C, one of which was over a million lines of code in size.",War Room Console,which artifacts are of importance?,,Elements,Intent and implementation,Software Process Management,Source Code,"project manager, technical lead, developer",Dense Pixel,Wall display,10,,,,,,,-,-,"Java, C++","Java, C/C++",SOFTVIS
S54,33,Visualizing structural properties of irregular parallel computations,"Blochinger, W.",2005,"An important task in parallel programming is the appropriate dis- tribution of work on the processors. This distribution is usually dynamically changing and hard to predict, further it is very sensitive to the change of parameters. Even with advanced analysis tools this problem is hard to be solved. We propose to visualize the program structure as it changes over the execution time. We therefore present a new automatic layout algorithm based on Sugiyama’s framework, which enables the user to detect structural patterns which might be fatal for the performance of the program - patterns which might be impossible to detect in a more analytical way. Furthermore it assists the user to find appropriate timing parameters for load balancing. We integrate our visualization into an integrated development envi- ronment that supports the implementation, execution, and analysis of parallel programs.",DOT,,to identify optimal parameters to distribute the work on the processors,Elements,Performance,Programming,Runtime,user,Geometrically-Transformed,Not identified,11,,,,,,,-,-,"Java, yFiles library",C/C++,SOFTVIS
S55,35,Visualization of mobile object environments,"Frishman, Y.",2005,"This paper presents a system for visualizing mobile object frame- works. In such frameworks, the objects can migrate to remote hosts, along with their state and behavior, while the application is running. An innovative graph-based visualization is used to depict the phys- ical and the logical connections in the distributed object network. Scalability is achieved by using a focus+context technique jointly with a user-steered clustering algorithm. In addition, an event synchronization model for mobile objects is presented. The system has been applied to visualizing several mobile object applications.",Mobile Object Vis.,,to understand connections in the distributed object network,TE,TE,Debugging,Runtime,developer,Standard,Not identified,11,,,,,,,-,-,Java3D,-,SOFTVIS
S56,39,Towards understanding programs through wear-based filtering,"DeLine, R.",2005,"Large software projects often require a programmer to make changes to unfamiliar source code. This paper presents the results of a formative observational study of seven professional programmers who use a conventional development environment to update an unfamiliar implementation of a commonly known video game. We describe several usability problems they experience, including keeping oriented in the program’s source text, maintaining the number and layout of open text documents and relying heavily on textual search for navigation. To reduce the cost of transferring knowledge about the program among developers, we propose the idea of wear-based filtering, a combination of computational wear and social filtering. The development environment collects interaction information, as with computational wear, and uses that information to direct the attention of subsequent users, as with social filtering. We present sketches of new visualizations that use wear-based filtering and demonstrate the feasibility of our approach with data drawn from our study.",FAN,what does this called method do?,,"EL, ER","Intent and implementation, Dependencies",Programming,Source Code,developer,Standard,Not identified,10,,,,,,,-,-,-,-,SOFTVIS
S57,1,Program animation based on the roles of variables,"Sajaniemi, J.",2003,"Computer programming is a difficult skill for many students and visualizations may be used to foster learning. This paper presents a program animation system, PlanAni, that is based on the concept of the roles of variables. Roles represent schematic uses of variables that occur in programs over and over again, and a set of nine roles covers practically all variables in novice-level programs. PlanAni has been tested in a teaching experiment comparing tradi- tional teaching with role-based teaching and animation. The results of a semi-structured interview with the teacher indicate that stu- dents like to work with the animator and that the system clarifies many concepts in programming.",PlanAni,what part of the array is currently being sorted?,,ND,ND,Programming,Source Code,student,Standard,Not identified,11,http://www.cs.uef.fi/~saja/var_roles/planani/index.html,,Y,Y,Y,N,Free,Y,Java3D,Pascal,SOFTVIS
S58,6,Visualizing Java in action,"Reiss, S.P.",2003,"Dynamic software visualization is supposed to provide program- mers with insights as to what the program is doing. Most current dynamic visualizations either use program traces to show information about prior runs, slow the program down substantially, show only minimal information, or force the programmer to indi- cate when to turn visualizations on or off. We have developed a dynamic Java visualizer that provides a view of a program in action with low enough overhead so that it can be used almost all the time by programmers to understand what their program is doing while it is doing it.",Jive,how much time each thread spent in each class?,,Changes,Debugging,Debugging,Source Code,user,Stacked,Not identified,10,http://cs.brown.edu/~spr/research/vizjive.html,,Y,Y,Y,N,Free,Y,-,Java,SOFTVIS
S59,4,EVolve: an open extensible software visualization framework,"Wang, Q.",2003,"Existing visualization tools typically do not allow easy extension by new visualization techniques, and are often coupled with inflex- ible data input mechanisms. This paper presents EVolve, a flexible and extensible framework for visualizing program characteristics and behaviour. The framework is flexible in the sense that it can visualize many kinds of data, and it is extensible in the sense that it is quite straightforward to add new kinds of visualizations.The overall architecture of the framework consists of the core EVolve platform that communicates with data sources via a well defined data protocol and which communicates with visualization methods via a visualization protocol.Given a data source, an end-user can use EVolve as a stand-alone tool by interactively creating, configuring and modifying visual- izations. A variety of visualizations are provided in the current EVolve library, with features that facilitate the comparison of mul- tiple views on the same execution data. We demonstrate EVolve in the context of visualizing execution behaviour of Java programs.",EVolve,,help us to develop compiler optimization ,Changes,Implications,Programming,Runtime,user,Standard,Not identified,11,http://www.sable.mcgill.ca/evolve/,,Y,Y,Y,N,Free,Y,-,Java,SOFTVIS
S60,7,Visualization of program-execution data for deployed software,"Orso, A.",2003,"Software products are often released with missing function- ality, errors, or incompatibilities that may result in failures in the field, inferior performances, or, more generally, user dissatisfaction. In previous work, we presented the Gamma technology, which facilitates remote analysis and measurement of deployed software and allows for gathering program- execution data from the field. When monitoring a high number of deployed instances of a software product, however, a large amount of data is collected. Such raw data are useless in the absence of a suitable data-mining and visualization technique that supports exploration and understanding of the data. In this paper, we present a new technique for collecting, storing, and visualizing program-execution data gathered from deployed instances of a software product. We also present a prototype toolset, Gammatella, that implements the technique. We show how the visualization capa- bilities of Gammatella allows for effectively investigating several kinds of execution-related information in an interac- tive fashion.",Gamma/Gammatella,,investigate the behavior of deployed software,Changes,Debugging,Debugging,Runtime,"developer, maintainer","Dense Pixel, Stacked",Not identified,11,,,,,,,-,-,"Java, Swing, TreeMap Java Library",Java,SOFTVIS
S61,8,A system for graph-based visualization of the evolution of software,"Collberg, C.",2003,"We describe Gevol, a system that visualizes the evolution of software using a novel graph drawing technique for visual- ization of large graphs with a temporal component. Gevol extracts information about a Java program stored within a CVS version control system and displays it using a temporal graph visualizer. This information can be used by program- mers to understand the evolution of a legacy program: Why is the program structured the way it is? Which programmers were responsible for which parts of the program during which time periods? Which parts of the program appear unstable over long periods of time and may need to be rewritten? This type of information will complement that produced by more static tools such as source code browsers, slicers, and static analyzers.",GEVOL,who was responsible for which parts of the program during which periods?,,Changes,Rationale,Programming,CVS,user,Geometrically-Transformed,Not identified,11,,,,,,,-,-,-,-,SOFTVIS
S62,14,Interactive locality optimization on NUMA architectures,"Mu, T.",2003,"Optimizing the performance of shared-memory NUMA programs remains something of a black art, requiring that application writers possess deep understanding of their programs’ behaviors. This difficulty represents one of the remaining hindrances to the widespread adoption and deployment of these cost-efficient and scalable shared-memory NUMA architectures. To address this problem, we have developed a performance monitoring infrastruc- ture and a corresponding set of tools to aid in visualizing and understanding the subtleties of the memory access behavior of parallel NUMA applications with large datasets. The tools are designed to be general, interoperable, and easily portable. We give detailed examples of the use of one particular tool in the set. We have used this memory access visualization tool profitably on a range of ap- plications, improving performance by around 90%, on average.",-,,helps users to allocate data onto their dominating nodes,TE,TE,Programming,CVS,user,Dense Pixel,Not identified,10,,,,,,,-,-,-,-,SOFTVIS
S63,15,Graph visualization for the analysis of the structure and dynamics of extreme-scale supercomputers,"Zhou, C.",2003,"We are exploring the development and application of information visualization techniques for the analysis of new massively parallel supercomputer architectures. Modern supercomputers typically comprise very large clusters of commodity SMPs interconnected by possibly dense and often nonstandard networks. The scale, complexity, and inherent nonlocality of the structure and dynamics of this hardware, and the systems and applications distributed over it, challenge traditional analysis methods. As part of the `a la carte team at Los Alamos National Laboratory, who are simulating these advanced architectures, we are exploring advanced visualization techniques and creating tools to provide intuitive exploration, discovery, and analysis of these simulations. This work complements existing and emerging algorithmic analysis tools. This paper gives background on the problem domain, a description of a prototypical computer architecture of interest (on the order of 10,000 processors connected by a quaternary fat-tree communications network), and a presentation of two classes of visualizations that clearly display the switch structure and the flow of information in the interconnecting network.",Flatland,,analysis of massively parallel supercomputer architectures,TE,TE,Programming,Documentation,user,"Stacked, Iconic",Standard,7,,,,,,,-,-,OpenGL,-,SOFTVIS
S64,177,KScope: A Modularized Tool for 3D Visualization of Object-Oriented Programs,"Davis, T.A.",2003,"Visualization of software systems is a widely used tech- nique in software engineering. This paper proposes a 3D user-navigable software visualization system, termed KScope, that is comprised of a modular, component- based architecture. The flexibility of this construction allows for a variety of component configurations to vali- date experimental software visualization techniques. The first iteration of KScope is described and evaluated.",Kscope,,to provide an analysis of java programs,ND,ND,Reverse Engineering,Source Code,researcher,Stacked,Standard,6,,,,,,,-,-,Java3D,Java,VISSOFT
S65,178,Self-Organizing Maps Applied in Visualising Large Software Collections,"Brittle, J.",2003,"The self-organizing map's unsupervised clustering method can be used as a data visualisation technique. Within this paper different techniques to visualise self- organizing maps (SOM) and their effectiveness are inves- tigated in relation to the organisation of a large software collection and its visualisation. GENISOM, an offspring component of the GENESIS software engineering platform, incorporates the genera- tion, maintenance and viewing of Self-Organizing Maps. The results from our studies indicate that a hybrid of 2D and 3D visualisations is favoured by users. Extensive us- ability tests also show that the majority of users found that the additional information a SOM provides, aids browsing and searching of a software collection. Further work is addressing the problems found in the application of SOM within a software engineering environment.",GENISOM,,to aid programmers in the process of reverse engineering,Element relationship,Architecture,Reverse Engineering,Source Code,user,Iconic,Not identified,6,,,,,,,-,-,Java3D,-,VISSOFT