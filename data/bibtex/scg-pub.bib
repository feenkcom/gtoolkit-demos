@inproceedings{Ache00a,
	Abstract = {The fact that so many different kinds of
				  coordination models and languages have been proposed
				  suggests that no one single approach will be the
				  best for all coordination problems. Different
				  coordination styles exhibiting different properties
				  may be more suitable for some problems than others.
				  Like other architectural styles, coordination styles
				  can be expressed in terms of components, connectors
				  and composition rules. We propose an approach in
				  which coordination styles are expressed as component
				  algebras: components of various sorts can be
				  combined using operators that realize their
				  coordination, yielding other sorts of components.We
				  show how several coordination styles can be defined
				  and applied using Piccola, a small language for
				  composing software components. We furthermore show
				  how glue abstractions can be used to bridge
				  coordination styles when more than one style is
				  needed for a single application.},
	Address = {Limassol, Cyprus},
	Annote = {internationalconference},
	Author = {Franz Achermann and Stefan Kneub\"uhl and Oscar Nierstrasz},
	Booktitle = {Coordination '2000},
	Doi = {10.1007/3-540-45263-X_2},
	Editor = {Ant{\'o}nio Porto and Gruia-Catalin Roman},
	Isbn = {978-3-540-41020-1},
	Keywords = {olit scg-pub piccola scg-none jb00 snf00 scg-coord-00},
	Month = sep,
	Pages = {19--35},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Scripting Coordination Styles},
	Url = {http://scg.unibe.ch/archive/papers/Ache00aScriptingCoordStyles.pdf},
	Volume = 1906,
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Ache00aScriptingCoordStyles.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/3-540-45263-X_2}}

@inproceedings{Ache00b,
	Abstract = {A namespace is a mapping from labels to values. Most
				  programming languages support different forms of
				  namespaces, such as records, dictionaries, objects,
				  environments, packages and even keyword based
				  parameters. Typically only a few of these notions
				  are first-class, leading to arbitrary restrictions
				  and limited abstraction power in the host language.
				  Piccola is a small language that unifies various
				  notions of namespaces as first-class forms, or
				  extensible, immutable records. By making namespaces
				  explicit, Piccola is easily able to express various
				  abstractions that would normally require more
				  heavyweight techniques, such as language extensions
				  or metaprogramming.},
	Address = {Z{\"u}rich, Switzerland},
	Annote = {internationalconference},
	Author = {Franz Achermann and Oscar Nierstrasz},
	Booktitle = {Modular Programning Languages, Proceedings of JMLC 2000 (Joint Modular Languages Conference)},
	Doi = {10.1007/10722581_8},
	Editor = {J{\"u}rg Gutknecht and Wolfgang Weck},
	Isbn = {978-3-540-67958-5},
	Keywords = {olit scg-pub piccola scg-none jb00 snf00 scg-coord-00 onhindex(36)},
	Month = sep,
	Pages = {77--89},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Explicit Namespaces},
	Url = {http://scg.unibe.ch/archive/papers/Ache00bExplicitNamespaces.pdf},
	Volume = 1897,
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Ache00bExplicitNamespaces.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/10722581_8}}

@inproceedings{Ache00d,
	Abstract = {Object oriented languages cannot express certain
				  composition abstractions due to restricted
				  abstraction power. A number of approaches, like SOP
				  or AOP overcome this restriction, thus giving the
				  programmer more possibilities to get a higher degree
				  of separation of concern. We propose \emph{forms},
				  extensible mappings from labels to values, as
				  vehicle to implement and reason about composition
				  abstractions. Forms unify a variety of concepts such
				  as interfaces, environments, and contexts. We are
				  prototyping a composition language where forms are
				  the only and ubiquitous first class value. Using
				  forms, it is possible compose software artifacts
				  focusing on a single concern and thus achieve a high
				  degree of separation of concern. We believe that
				  using forms it also possible to compare and reason
				  about the different composition mechanisms
				  proposed.},
	Address = {Limerick, Ireland},
	Author = {Franz Achermann},
	Booktitle = {Workshop on Multi-Dimensional Separation of Concerns in Software Engineering (ICSE 2000)},
	Keywords = {olit scg-pub skip-doi piccola scg-none jb00 snf00 scg-coord-00},
	Month = jun,
	Title = {Language support for feature mixing},
	Url = {http://scg.unibe.ch/archive/papers/Ache00dFeatureMixing.pdf},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Ache00dFeatureMixing.pdf}}

@incollection{Ache01a,
	Abstract = {Piccola is a language for composing applications
				  from software components. It has a small syntax and
				  a minimal set of features needed for specifying
				  different styles of software composition. The core
				  features of Piccola are communicating agents, which
				  perform computations, and forms, which are the
				  communicated values. Forms are a special notion of
				  extensible, immutable records. Forms and agents
				  allow us to unify components, static and dynamic
				  contexts and arguments for invoking services.
				  Through a series of examples, we present a tour of
				  Piccola, illustrating how forms and agents suffice
				  to express a variety of compositional abstractions
				  and styles.},
	Author = {Franz Achermann and Oscar Nierstrasz},
	Booktitle = {Software Architectures and Component Technology},
	Editor = {Mehmet Aksit},
	Isbn = {0-7923-7576-9},
	Keywords = {olit scg-pub skip-doi piccola scg-none jb00 snf00 onhindex(102) scg-coord-00},
	Pages = {261--292},
	Publisher = {Kluwer},
	Title = {Applications = Components + Scripts --- A Tour of {Piccola}},
	Url = {http://scg.unibe.ch/archive/papers/Ache01aTour.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Ache01aTour.pdf}}

@incollection{Ache01b,
	Abstract = {Although object-oriented languages are well-suited
				  to implementing software components, they fail to
				  shine in the construction of component-based
				  applications, largely because object-oriented design
				  tends to obscure a component-based architecture. We
				  propose to tackle this problem by clearly separating
				  component implementation and composition. Piccola is
				  a small "composition language" that embodies the
				  paradigm of "applications = components + scripts."
				  Piccola models components and composition
				  abstractions by means of a unifying foundation of
				  communicating concurrent agents. Flexibility and
				  extensibility are obtained by modelling both
				  interfaces to components and the contexts in which
				  they live by extensible records, or "forms". We
				  illustrate the realization of an architectural style
				  in Piccola and show how external components may be
				  adapted and composed according to the style. We show
				  how separating components from their composition can
				  improve maintainability.},
	Author = {Franz Achermann and Markus Lumpe and Jean-Guy Schneider and Oscar Nierstrasz},
	Booktitle = {Formal Methods for Distributed Processing --- A Survey of Object-Oriented Approaches},
	Editor = {Howard Bowman and John Derrick},
	Isbn = {0-521-77184-6},
	Keywords = {olit scg-pub skip-doi pict pi omnrep scg-coord-99 onhindex(96) snf99 piccola scg-none jb00 scg-coord-00},
	Pages = {403--426},
	Publisher = {Cambridge University Press},
	Title = {Piccola --- a Small Composition Language},
	Url = {http://scg.unibe.ch/archive/papers/Ache01bPASCL.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Ache01bPASCL.pdf}}

@article{Ache05a,
	Abstract = {Although the term ``software component'' has become
				  commonplace, there is no universally accepted
				  definition of the term, nor does there exist a
				  common foundation for specifying various kinds of
				  components and their compositions. We propose such a
				  foundation. The Piccola Calculus is a process
				  calculus, based on the asynchronous pi-calculus,
				  extended with explicit namespaces. The calculus is
				  high-level, rather than minimal, and is consequently
				  convenient for expressing and reasoning about
				  software components, and different styles of
				  composition. We motivate and present the calculus,
				  and outline how it is used to specify the semantics
				  of Piccola, a small composition language. We
				  demonstrate how the calculus can be used to simplify
				  compositions by partial evaluation, and we briefly
				  outline some other applications of the calculus to
				  reasoning about compositional styles.},
	Annote = {internationaljournal},
	Author = {Franz Achermann and Oscar Nierstrasz},
	Cvs = {PiccolaReasoning},
	Doi = {10.1016/j.tcs.2004.09.022},
	Journal = {Theoretical Computer Science},
	Keywords = {snf04 snf05 scg-pub piccola scg-none jb05 context-calculus},
	Number = {2-3},
	Pages = {367--396},
	Title = {A Calculus for Reasoning about Software Components},
	Url = {http://scg.unibe.ch/archive/papers/Ache05aPiccolaReasoning.pdf},
	Volume = {331},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Ache05aPiccolaReasoning.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.tcs.2004.09.022}}

@inproceedings{Aesc13a,
	Abstract = {This paper presents a case study of analyzing a legacy PL/1 ecosystem that has grown for 40 years to support the business needs of a large banking company. In order to support the stakeholders in analyzing it we developed St1-PL/1 -- a tool that parses the code for association data and computes structural metrics which it then visualizes using top-down interactive exploration. Before building the tool and after demonstrating it to stakeholders we conducted several interviews to learn about legacy ecosystem analysis requirements. We briefly introduce the tool and then present results of analysing the case study. We show that although the vision for the future is to have an ecosystem architecture in which systems are as decoupled as possible the current state of the ecosystem is still removed from this. We also present some of the lessons learned during our discussions with stakeholders which include their interests in automatically assessing the quality of the legacy code.},
	Author = {Aeschlimann, Erik and Lungu, Mircea and Nierstrasz, Oscar and Worms, Carl},
	Booktitle = {Proceedings of the 20th Working Conference on Reverse Engineering, WCRE 2013},
	Doi = {10.1109/WCRE.2013.6671320},
	Keywords = {scg-pub snf-asa1 scg13 PL/1 ecosystems static analysis metrics visualization jb14},
	Medium = {2},
	Pages = {441 -- 448},
	Peerreview = {yes},
	Title = {Analyzing {PL/1} Legacy Ecosystems: An Experience Report},
	Url = {http://scg.unibe.ch/archive/papers/Aesc13a-PL1Ecosystem.pdf},
	Year = {2013},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Aesc13a-PL1Ecosystem.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.2013.6671320}}

@inproceedings{Alle16a,
	Abstract = {Software is fundamental to academic research work, both as part of
		the method and as the result of research. In June 2016 25 people
		gathered at Schloss Dagstuhl for a week-long PerSoftware is
		fundamental to academic research work, both as part of the method
		and as the result of research. In June 2016 25 people gathered at
		Schloss Dagstuhl for a week-long Perspectives Workshop and began
		to develop a manifesto which places emphasis on the scholarly
		value of academic software and on personal responsibility. Twenty
		pledges cover the recognition of academic software, the academic
		software process and the intellectual content of academic
		software. This is still work in progress. Through this lightning
		talk, we aim to get feedback and hone these further, as well as to
		inspire the WSSSPE audience to think about actions they can take
		themselves rather than actions they want others to take. We aim to
		publish a more fully developed Dagstuhl Manifesto by December
		2016.spectives Workshop and began to develop a manifesto which
		places emphasis on the scholarly value of academic software and on
		personal responsibility. Twenty pledges cover the recognition of
		academic software, the academic software process and the
		intellectual content of academic software. This is still work in
		progress. Through this lightning talk, we aim to get feedback and
		hone these further, as well as to inspire the WSSSPE audience to
		think about actions they can take themselves rather than actions
		they want others to take. We aim to publish a more fully developed
		Dagstuhl Manifesto by December 2016.},
	Annote = {internationalworkshop},
	Author = {Alice Allen and Cecilia Aragon and Christoph Becker and Jeffrey Carver and Andrei Chi\c{s} and Benoit Combemale and Mike Croucher and Kevin Crowston and Daniel Garijo and Ashish Gehani and Carole Goble and Robert Haines and Robert Hirschfeld and James Howison and Kathryn Huff and Caroline Jay and Daniel S. Katz and Claude Kirchner and Kateryna Kuksenok and Ralf L\"{a}mmel and Oscar Nierstrasz and Matt Turk and Rob van Nieuwpoort and Matthew Vaughn and Jurgen Vinju},
	Booktitle = {Proceedings of Workshop on Sustainable Software for Science: Practice and Experiences (WSSSPE 2016)},
	Editor = {Gabrielle Allen and Jeffrey Carver and Sou-Cheng T.
		Choi and Tom Crick and Michael R. Crusoe and Sandra Gesing and
		Robert Haines and Michael Heroux and Lorraine J. Hwang and Daniel
		S. Katz and Kyle E. Niemeyer and Manish Parashar and Colin C.
		Venters},
	Publisher = {{CEUR}},
    Series = {Proceedings of the Fourth Workshop on Sustainable Software for Science: Practice and Experiences (WSSSPE4)},
    Volume = {1686},
	medium={1},
	Keywords = {scg16 scg-pub jb17 snf-none skip-doi Andrei Chis},
	Location = {Manchester, UK},
	Peerreview = {yes},
	Title = {Lightning Talk: ``{I} solemnly pledge'' A Manifesto for Personal Responsibility in the Engineering of Academic Software},
	Pdf = {http://ceur-ws.org/Vol-1686/WSSSPE4_paper_15.pdf},
	Url = {http://scg.unibe.ch/archive/papers/Alle16a-WSSPE.pdf},
	Year = {2016}
}

@inproceedings{Arev01a,
	Abstract = {Integration of architectural descriptions in
				  development tools and environments, in order to take
				  architectural descriptions into account, is a
				  topical issue. Nowadays, the existing formalisms to
				  represent software architecture fail in providing a
				  clear semantics and only give an intuitive graphical
				  representation of the system as a whole. More
				  specifically, the framework architectures should
				  show the overall design and the specification of the
				  points of the variability of the framework, making
				  easier the reuse of the architectures, integration
				  with others frameworks and a reference to measure
				  the changes in subsequent versions of the
				  frameworks. In this paper we propose an approach to
				  describe the architecture of frameworks, combining
				  formal and non-formal formalisms: Wright, an
				  architectural description language developed at
				  Carnegie Mellon University, and architectural
				  patterns. Based on the study of several frameworks,
				  our objective was to produce a complete description
				  of a framework, to show the expressive power of both
				  approaches and to consider complementarity and
				  flexibility regarding to other approaches.},
	Author = {Gabriela Ar{\'e}valo and Isabelle Borne},
	Booktitle = {Proceedings of Langages et Modeles \`a Objets (LMO'01)},
	Keywords = {scg-old scg-pub skip-doi arevalo},
	Month = jan,
	Publisher = {Hermes, Paris},
	Title = {Architectural Description of Object Oriented Frameworks},
	Url = {http://scg.unibe.ch/archive/papers/Arev01aLMO01.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Arev01aLMO01.pdf}}

@inproceedings{Arev02a,
	Abstract = {This paper proposes the use of the formal technique
				  of Concept Analysis to analyse how classes in an
				  object-oriented inheritance hierarchy are coupled by
				  means of the inheritance and interfaces
				  relationships. To perform our analysis, we use the
				  information provided by the self-send and super-send
				  behaviour of each class in the hierarchy. Especially
				  for large and complex inheritance hierarchies, we
				  believe that this analysis can help in understanding
				  the software, in particular with how reuse is
				  achieved. Additionally, the proposed technique
				  allows us to identify weak spots in the inheritance
				  hierarchy that may be improved, and to serve as
				  guidelines for extending or customising an
				  object-oriented application framework. As a first
				  step, this position paper reports on an initial
				  experiment with the Magnitude hierarchy in the
				  Smalltalk programming language.},
	Author = {Gabriela Ar{\'e}valo and Tom Mens},
	Booktitle = {ECOOP 2002: Proceedings of the Inheritance Workshop},
	Editor = {Andrew Black and Erik Ernst and Peter Grogono and Markky Sakkinen},
	Keywords = {snf02 scg-pub skip-doi scg-none jb02 arevalo},
	Month = jun,
	Pages = {3--9},
	Publisher = {University of Jyv\"askyl\"a},
	Title = {Analysing Object Oriented Application Frameworks using Concept Analysis},
	Url = {http://scg.unibe.ch/archive/papers/Arev02aECOOP02ApplicationFrameworks.pdf},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Arev02aECOOP02ApplicationFrameworks.pdf}}

@inproceedings{Arev02b,
	Abstract = {This paper proposes to use the formal technique of
				  Concept Analysis to analyse how methods and classes
				  in an object-oriented inheritance hierarchy are
				  coupled by means of the inheritance and interfaces
				  relationships. Especially for large and complex
				  inheritance hierarchies, we believe that a formal
				  analysis of how behaviour is reused can provide
				  insight in how the hierarchy was built and the
				  different relationships among the classes. To
				  perform this analysis, we use behavioural
				  information provided by the self sends and super
				  sends made in each class of the hierarchy. The
				  proposed technique allows us to identify weak spots
				  in the inheritance hierarchy that may be improved,
				  and to serve as guidelines for extending or
				  customising an object-oriented application
				  framework. As a first step, this paper reports on an
				  initial experiment with the Magnitude hierarchy in
				  the Smalltalk programming language.},
	Author = {Gabriela Ar{\'e}valo and Tom Mens},
	Booktitle = {Advances in Object-oriented Information Systems: OOIS 2002 Workshops},
	Editor = {Jean-Michel Bruel and Zohra Bellahsene},
	Keywords = {snf02 scg-pub skip-doi scg-none jb02 arevalo},
	Month = sep,
	Pages = {53--63},
	Publisher = {Springer Verlag},
	Title = {Analysing Object Oriented Framework Reuse using Concept Analysis},
	Url = {http://scg.unibe.ch/archive/papers/Arev02bOOIS02FrameworkReuse.pdf},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Arev02bOOIS02FrameworkReuse.pdf}}

@inproceedings{Arev03a,
	Abstract = {The functionalities of software artifacts are
				  defined by structural and behavioral dependencies.
				  During evolution and maintenance phases of a system,
				  the developer has to be able to understand how these
				  dependencies were defined and how they influence the
				  interaction of the artifacts. The developer must be
				  sure that modifications done in the system will not
				  break its behavior. In the most of the cases, this
				  happens because the dependencies are not documented.
				  We propose to tackle this problem in the context of
				  object oriented classes hierarchies using Concept
				  Analysis. We use different properties about
				  invocations in methods to analyze the dependencies
				  among the hierarchy classes in terms of class
				  behaviour. Based on these results, we show a set of
				  patterns that describe repeated kinds of behavior in
				  class hierarchies. We show the application of these
				  patterns in the specific case of Magnitude hierarchy
				  in Smalltalk.},
	Author = {Gabriela Ar{\'e}valo},
	Booktitle = {Proceedings of Langages et Modeles \`a Objets (LMO'03)},
	Keywords = {snf03 scg-pub skip-doi scg-none jb03 arevalo},
	Month = jan,
	Pages = {47--59},
	Publisher = {Hermes, Paris},
	Title = {Understanding Behavioral Dependencies in Class Hierarchies using Concept Analysis},
	Url = {http://scg.unibe.ch/archive/papers/Arev03aLMO03UnderstandingDependencies.pdf},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Arev03aLMO03UnderstandingDependencies.pdf}}

@inproceedings{Arev03b,
	Abstract = {Within object oriented software, the minimal unit of
				  development and testing is a class. So understanding
				  how a class is defined and behaves is important.
				  Considering that a class is composed of instance
				  variables and methods, the process is not so easy to
				  achieve because we must decide which different
				  viewpoints can help us to detect features of a
				  class. These viewpoints can include identifying
				  groups of methods accessing a (set of) instance
				  variable(s), groups of methods that interact among
				  themselves to provide a functionality or groups of
				  methods that behave as interface. Thus, with these
				  different groups, we are able to know the different
				  hidden characteristics of a class. In this position
				  paper, we propose to apply Concept Analysis to
				  generate the different groups of (collaborating)
				  entities and use these groups to define different
				  views. These views will help us to get the main
				  features of a class.},
	Annote = {internationalworkshop},
	Author = {Gabriela Ar\'evalo},
	Booktitle = {Proceedings of WOOR 2003 (4th International Workshop on Object-Oriented Reengineering)},
	Cvs = {ConAnWOOR03XRayViews},
	Keywords = {recast03 scg-pub skip-doi scg-none jb03 arevalo moose-pub},
	Month = jul,
	Pages = {76--80},
	Publisher = {University of Antwerp},
	Title = {{X-Ray} Views on a Class using Concept Analysis},
	Url = {http://scg.unibe.ch/archive/papers/Arev03bWOOR03XRayViews.pdf},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Arev03bWOOR03XRayViews.pdf}}

@inproceedings{Arev03c,
	Abstract = {Understanding the internal workings of classes is a
				  key prerequisite to maintaining an object-oriented
				  software system. Unfortunately, classical editing
				  and browsing tools offer mainly linear and textual
				  views of classes and their implementation. These
				  views fail to expose the semantic relationships
				  between the internal parts of a class. We propose
				  XRay views --a technique based on Concept Analysis--
				  which reveal the internal relationships between
				  groups of methods and attributes of a class. XRay
				  views are composed out of elementary collaborations
				  between attributes and methods, and help the
				  engineer to build a mental model of how a class
				  works internally. In this paper we present XRay
				  views, and illustrate the approach by applying it on
				  the Smalltalk class UIBuilder.},
	Annote = {internationalconference},
	Author = {Gabriela Ar\'evalo and St\'ephane Ducasse and Oscar Nierstrasz},
	Booktitle = {Proceedings of 18th Conference on Automated Software Engineering (ASE'03)},
	Cvs = {ConAnASE03XRayViews},
	Doi = {10.1109/ASE.2003.1240318},
	Keywords = {recast03 scg-pub stefPub moose-pub arevalo scg-none jb04},
	Month = oct,
	Note = {Short paper},
	Pages = {267--270},
	Publisher = {IEEE Computer Society},
	Title = {{X-Ray} Views: Understanding the Internals of Classes},
	Url = {http://scg.unibe.ch/archive/papers/Arev03cASE03XRayViews.pdf},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Arev03cASE03XRayViews.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ASE.2003.1240318}}

@inproceedings{Arev03d,
	Abstract = {Understanding the internal workings of classes is a
				  key prerequisite to maintaining an object-oriented
				  software system. Unfortunately, classical editing
				  and browsing tools offer mainly linear and textual
				  views of classes and their implementation. These
				  views fail to expose the semantic relationships
				  between the internal parts of a class. We propose
				  XRay views --a technique based on Concept Analysis--
				  which reveal the internal relationships between
				  groups of methods and attributes of a class. XRay
				  views are composed out of elementary collaborations
				  between attributes and methods and help the engineer
				  to build a mental model of how a class works
				  internally. In this paper we present XRay views, and
				  illustrate the approach by applying it to three
				  Smalltalk classes: OrderedCollection, Scanner, and
				  UIBuilder.},
	Annote = {internationalworkshop},
	Author = {Gabriela Ar\'evalo and St\'ephane Ducasse and Oscar Nierstrasz},
	Booktitle = {Proceedings of 2nd International Workshop on MASPEGHI 2003 (ASE 2003)},
	Cvs = {ConAnMASPEGHI03XRayViews},
	Keywords = {snf04 scg-pub skip-doi stefPub arevalo scg-none jb04 moose-pub},
	Month = oct,
	Pages = {9--18},
	Publisher = {CRIM --- University of Montreal (Canada)},
	Title = {Understanding Classes using {X-Ray} Views},
	Url = {http://scg.unibe.ch/archive/papers/Arev03dMASPEGHI03XRayViews.pdf},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Arev03dMASPEGHI03XRayViews.pdf}}

@inproceedings{Arev04a,
	Abstract = {A key problem during software development and
				  maintenance is to detect and recognize recurring
				  collaborations among software artifacts that are
				  implicit in the code. These collaboration patterns
				  are typically signs of applied idioms, conventions
				  and design patterns during the development of the
				  system, and may entail implicit contracts that
				  should be respected during maintenance, but are not
				  documented explicitly. In this paper we apply Formal
				  Concept Analysis to detect implicit collaboration
				  patterns. Our approach generalizes Antoniol and
				  Tonella one for detecting classical design patterns.
				  We introduce a variation to their algorithm to
				  reduce the computation time of the concepts, a
				  language-independent approach for object-oriented
				  languages, and a post-processing phase in which
				  pattern candidates are filtered out. We identify
				  collaboration patterns in the analyzed applications,
				  match them against libraries of known design
				  patterns, and establish relationships between
				  detected patterns and their nearest neighbours.},
	Annote = {internationalconference},
	Author = {Gabriela Ar\'evalo and Frank Buchli and Oscar Nierstrasz},
	Booktitle = {Proceedings of WCRE '04 (11th Working Conference on Reverse Engineering)},
	Cvs = {ConAnPatternsWCRE04},
	Doi = {10.1109/WCRE.2004.18},
	Keywords = {olit scg-pub scg-none jb05 recast05 snf04 arevalo moose-pub},
	Location = {Delft, The Netherlands},
	Month = nov,
	Pages = {122--131},
	Publisher = {IEEE Computer Society Press},
	Title = {Detecting Implicit Collaboration Patterns},
	Url = {http://scg.unibe.ch/archive/papers/Arev04aWCRE04CollaborationPatterns.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Arev04aWCRE04CollaborationPatterns.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.2004.18}}

@inproceedings{Arev05b,
	Abstract = {Object-oriented applications are difficult to extend
				  and maintain, due to the presence of implicit
				  dependencies in the inheritance hierarchy. Although
				  these dependencies often correspond to well-known
				  schemas, such as hook and template methods, new
				  unanticipated dependency schemas occur in practice,
				  and can consequently be hard to recognize and
				  detect. To tackle this problem, we have applied
				  Concept Analysis to automatically detect recurring
				  dependency schemas in class hierarchies used in
				  object-oriented applications. In this paper we
				  describe our mapping of OO dependencies to the
				  formal framework of Concept Analysis, we apply our
				  approach to a non-trivial case study, and we report
				  on the kinds of dependencies that are uncovered with
				  this technique. As a result, we show how the
				  discovered dependency schemas correspond not only to
				  good design practices, but also to bad smells in
				  design.},
	Acceptnum = {33},
	Accepttotal = {81},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Gabriela Ar\'evalo and St\'ephane Ducasse and Oscar Nierstrasz},
	Booktitle = {Proceedings of 9th European Conference on Software Maintenance and Reengineering (CSMR'05)},
	Cvs = {ConAnCSMR05ClassHierarchies},
	Doi = {10.1109/CSMR.2005.24},
	Impactfactor = {hors},
	Keywords = {scg-pub arevalo scg-none jb05 recast05 stefPub moose-pub},
	Location = {Manchester, United Kingdom},
	Misc = {acceptance rate: 33/81 = 41\%},
	Month = mar,
	Pages = {62--71},
	Publisher = {IEEE Computer Society},
	Rate = {41%},
	Selectif = {non},
	Title = {Discovering Unanticipated Dependency Schemas in Class Hierarchies},
	Url = {http://scg.unibe.ch/archive/papers/Arev05bCSMR05ClassHierarchies.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Arev05bCSMR05ClassHierarchies.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/CSMR.2005.24}}

@inproceedings{Arev05c,
	Abstract = {A key difficulty in the maintenance and evolution of
				  complex software systems is to recognize and
				  understand the implicit dependencies that define
				  contracts that must be respected by changes to the
				  software. Formal Concept Analysis is a
				  well-established technique for identifying groups of
				  elements with common sets of properties. We have
				  successfully applied FCA to complex software systems
				  in order to automatically discover a variety of
				  different kinds of implicit, recurring sets of
				  dependencies amongst design artifacts. In this paper
				  we describe our approach, outline three case
				  studies, and draw various lessons from our
				  experiences. In particular, we discuss how our
				  approach is applied iteratively in order to draw the
				  maximum benefit offered by FCA.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Gabriela Ar{\'e}valo and St\'ephane Ducasse and Oscar Nierstrasz},
	Booktitle = {Proceedings of 3rd International Conference on Formal Concept Analysis (ICFCA '05)},
	Cvs = {ConAnICFCA05LessonsLearned},
	Doi = {10.1007/b105806},
	Impactfactor = {hors},
	Keywords = {scg-pub scg-none jb05 recast05 arevalo stefPub},
	Location = {Lens, France},
	Month = feb,
	Pages = {95--112},
	Publisher = {Springer Verlag},
	Selectif = {non},
	Series = {LNAI (Lecture Notes in Artificial Intelligence)},
	Title = {Lessons Learned in Applying Formal Concept Analysis},
	Url = {http://scg.unibe.ch/archive/papers/Arev05cICFCA05LessonsLearned.pdf},
	Volume = {3403},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Arev05cICFCA05LessonsLearned.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/b105806}}

@inproceedings{Arya11a,
	Abstract = {Software dependencies play a vital role in program comprehension, change impact
			analysis and other software maintenance activities. Traditionally, these activities are
			supported by source code analysis, however, the source code is sometimes inaccessible,
			and not all stakeholders have adequate knowledge to perform such analysis. For example,
			non-technical domain experts and consultants raise most maintenance requests, however,
			they cannot predict the cost and impact of the requested changes without the support of
			the developers. We propose a novel approach to predict software dependencies by
			exploiting coupling present in domain-level information. Our approach is independent of
			the software implementation, hence, it can be used to evaluate architectural
			dependencies without access to the source code or the database. We evaluate our
			approach with a case study on a large-scale enterprise system, in which we demonstrate
			how up to 68% of the source code dependencies and 77% of the database dependencies are
			predicted solely based on domain information.},
	Author = {Amir Aryani and Fabrizio Perin and Mircea Lungu and Abdun Naser Mahmood and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 18th Working Conference on Reverse Engineering (WCRE 2011)},
	Doi = {10.1109/WCRE.2011.17},
	Issn = {1095-1350},
	Keywords = {internationalconference scg-pub snf-none ercim11 jb12 scg11},
	Medium = {2},
	Month = oct,
	Pages = {55-64},
	Peerreview = {yes},
	Title = {Can We Predict Dependencies Using Domain information?},
	Url = {http://scg.unibe.ch/archive/papers/Aria11aWCRE11.pdf},
	Year = {2011},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Aria11aWCRE11.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.2011.17}}

@article{Arya14a,
	Abstract = {Software dependencies play a vital role in programme comprehension, change impact
		analysis and other software maintenance activities. Traditionally, these activities are
        supported by source code analysis; however, the source code is sometimes inaccessible or
        difficult to analyse, as in hybrid systems composed of source code in multiple languages
        using various paradigms (e.g. object-oriented programming and relational databases).
        Moreover, not all stakeholders have adequate knowledge to perform such analyses. For
        example, non-technical domain experts and consultants raise most maintenance requests;
        however, they cannot predict the cost and impact of the requested changes without the
        support of the developers. We propose a novel approach to predicting software dependencies
        by exploiting the coupling present in domain-level information. Our approach is
        independent of the software implementation; hence, it can be used to approximate
        architectural dependencies without access to the source code or the database. As such, it
        can be applied to hybrid systems with heterogeneous source code or legacy systems with
        missing source code. In addition, this approach is based solely on information visible and
        understandable to domain users; therefore, it can be efficiently used by domain experts
        without the support of software developers. We evaluate our approach with a case study on
        a large-scale enterprise system, in which we demonstrate how up to 65% of the source code
        dependencies and 77\% of the database dependencies are predicted solely based on domain
        information.},
	Author = {Aryani, Amir and Perin, Fabrizio and Lungu, Mircea and Mahmood, Abdun Naser and Nierstrasz, Oscar},
	Doi = {10.1002/smr.1598},
	Issn = {2047-7481},
	Journal = {Journal of Software: Evolution and Process},
	Keywords = {scg-pub snf-asa1 scg14 jb13 domain-based coupling, architectural dependencies, database dependencies, source code analysis, programme comprehension},
	Peerreview = {yes},
	Medium = {2},
	Annote = {internationaljournal},
	Nb = {Was Arya13a},
	Number = {1},
	Pages = {50--76},
	Title = {Predicting dependencies using domain-based coupling},
	Url = {http://scg.unibe.ch/archive/papers/Arya14aJSME.pdf},
	Volume = {26},
	Year = {2014},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Arya14aJSME.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1002/smr.1598}}

@inproceedings{Bali06a,
	Abstract = {Copy-paste programming is dangerous as it may lead
				  to hidden dependencies between different parts of
				  the system. Modifying clones is not always straight
				  forward, because we might not know all the places
				  that need modification. This is even more of a
				  problem when several developers need to know about
				  how to change the clones. In this paper, we
				  correlate the code clones with the time of the
				  modification and with the developer that performed
				  the modification to detect patterns of how
				  developers copy from one another. We develop a
				  visualization, named Clone Evolution View, to
				  represent the evolution of the duplicated code. We
				  show the relevance of our approach on several large
				  case studies and we distill our experience in forms
				  of interesting copy patterns.},
	Annote = {internationalconference},
	Author = {Mihai Balint and Tudor G\^irba and Radu Marinescu},
	Booktitle = {Proceedings of International Conference on Program Comprehension (ICPC 2006)},
	Doi = {10.1109/ICPC.2006.25},
	Keywords = {scg-pub scg-none jb06 fb06 girba moose-pub recast06 norex06},
	Medium = {2},
	Pages = {56--65},
	Peerreview = {yes},
	Title = {How Developers Copy},
	Url = {http://scg.unibe.ch/archive/papers/Bali06aHowDevelopersCopy.pdf},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Bali06aHowDevelopersCopy.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICPC.2006.25}}

@inproceedings{Berg03a,
	Abstract = {Classical module systems support well the modular
				  development of applications but do not offer the
				  ability to add or replace a method in a class that
				  is not defined in that module. On the other hand,
				  languages that support method addition and
				  replacement do not provide a modular view of
				  applications, and their changes have a global
				  impact. The result is a gap between module systems
				  for object-oriented languages on one hand, and the
				  very desirable feature of method addition and
				  replacement on the other hand. To solve these
				  problems we present classboxes, a module system for
				  object-oriented languages that provides method
				  addition and replacement. Moreover, the changes made
				  by a classbox are only visible to that classbox (or
				  classboxes that import it), a feature we call local
				  rebinding. To validate the model, we have
				  implemented it in the Squeak Smalltalk environment,
				  and performed experiments modularising code.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Roel Wuyts},
	Booktitle = {Proceedings of Joint Modular Languages Conference (JMLC'03)},
	Doi = {10.1007/b12023},
	Inria = {hors},
	Isbn = {978-3-540-40796-6},
	Keywords = {snf03 scg-pub scg-none jb03 module stefPub classbox alexandrePub alexPub noWorkshop},
	Misc = {Best Paper Award},
	Pages = {122--131},
	Publisher = {Springer-Verlag},
	Selectif = {non},
	Series = {LNCS},
	Title = {Classboxes: A Minimal Module Model Supporting Local Rebinding},
	Url = {http://scg.unibe.ch/archive/papers/Berg03aClassboxes.pdf http://www.springerlink.com/index/G5C3J6EB427YCDH2},
	Volume = {2789},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Berg03aClassboxes.pdf%20http://www.springerlink.com/index/G5C3J6EB427YCDH2},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/b12023}}

@inproceedings{Berg03b,
	Abstract = {Classical module systems support well the modular
				  development of applications but do not offer the
				  ability to add or replace a method in a class that
				  is not defined in that module. On the other hand,
				  languages that support method addition and
				  replacement do not provide a modular view of
				  applications, and their changes have a global
				  impact. The result is a gap between module systems
				  for object-oriented languages on one hand, and the
				  very desirable feature of method addition and
				  replacement on the other hand. To solve these
				  problems we present classboxes, a module system for
				  object-oriented languages that provides method
				  addition and replacement. Moreover, the changes made
				  by a classbox are only visible to that classbox (or
				  classboxes that import it), a feature we call local
				  rebinding. To validate the model, we have
				  implemented it in the Squeak Smalltalk environment,
				  and performed experiments modularising code.},
	Aeres = {ACT},
	Aeresstatus = {aeres05},
	Annote = {internationalworkshop},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Roel Wuyts},
	Booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
	Inria = {hors},
	Keywords = {snf03 scg-pub skip-doi scg-none jb03 stefPub alexandrePub module classbox alexPub},
	Month = jul,
	Selectif = {non},
	Title = {The {Classbox} Module System},
	Url = {http://scg.unibe.ch/archive/papers/Berg03bClassboxes.pdf},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Berg03bClassboxes.pdf}}

@techreport{Berg04a,
	Abstract = {A class extension is a method that is defined in a
				  module, but whose class is defined elsewhere. Class
				  extensions offer a convenient way to incrementally
				  modify existing classes when subclassing is
				  inappropriate. Unfortunately existing approaches
				  suffer from various limitations. Either class
				  extensions have a global impact, with possibly
				  negative effects for unexpected clients, or they
				  have a purely local impact, with negative results
				  for collaborating clients. Furthermore, conflicting
				  class extensions are either disallowed, or resolved
				  by linearization, with consequent negative effects.
				  To solve these problems we present classboxes, a
				  module system for object-oriented languages that
				  provides for method addition and replacement.
				  Moreover, the changes made by a classbox are only
				  visible to that classbox (or classboxes that import
				  it), a feature we call local rebinding. To validate
				  the model we have implemented it in the Squeak
				  Smalltalk environment, and performed benchmarks.},
	Address = {Universit\"at Bern, Switzerland},
	Aeres = {AP},
	Aeresstatus = {aeres05},
	Annote = {report notrefereed technicalReport},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
	Classification = {D.1.5 Object-oriented Programming; D.3.3 Language Constructs and Features},
	General_Terms = {Inheritance, Mixins, Multiple Inheritance, Traits, Reuse, Smalltalk},
	Inria = {hors},
	Institution = {Institut f\"ur Informatik},
	Keywords = {snf-redundant scg-pub skip-doi scg-none jb04 snf04 stefPub alexPub alexandrePub},
	Misc = {ClassboxTR04},
	Month = jun,
	Number = {IAM-04-003},
	Selectif = {non},
	Title = {Classboxes: Controlling Visibility of Class Extensions},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Berg04aIAM-04-003.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Berg04aIAM-04-003.pdf}}

@inproceedings{Berg04c,
	Abstract = {With prototype-based languages, concretization and
				  abstraction are unified into a single concept a
				  prototype. Prototype-based languages are based on a
				  simple set of principles: object-centered
				  representation, dynamic reshape of objects, cloning
				  and possibly message delegation. However, they all
				  differ in the interpretation and combination of
				  these principles. Therefore there is a need to
				  compare and understand. In this paper we present
				  Prototalk, a research and teaching vehicle to
				  understand, implement and compare prototype-based
				  languages. Prototalk is a framework that offers a
				  predefined set of language data structures and
				  mechanisms that can be composed and extended to
				  generate various prototype-based language
				  interpreters. It presents a classification of
				  languages based on different mechanisms in an
				  operational manner.},
	Aeres = {ACT},
	Aeresstatus = {aeres05},
	Annote = {internationalconference},
	Author = {Alexandre Bergel and Christophe Dony and St\'ephane Ducasse},
	Booktitle = {Proceedings of 12th International Smalltalk Conference (ISC'04)},
	Cvs = {PrototalkESUG04},
	Inria = {hors},
	Keywords = {scg-pub skip-doi scg-none jb05 snf04 stefPub alexPub alexandrePub noWorkshop},
	Month = sep,
	Pages = {107--130},
	Selectif = {non},
	Title = {Prototalk: an Environment for Teaching, Understanding, Designing and Prototyping Object-Oriented Languages},
	Url = {http://scg.unibe.ch/archive/papers/Berg04cprototalk.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Berg04cprototalk.pdf}}

@article{Berg05a,
	Abstract = {A class extension is a method that is defined in a
				  module, but whose class is defined elsewhere. Class
				  extensions offer a convenient way to incrementally
				  modify existing classes when subclassing is
				  inappropriate. Unfortunately existing approaches
				  suffer from various limitations. Either class
				  extensions have a global impact, with possibly
				  negative effects for unexpected clients, or they
				  have a purely local impact, with negative results
				  for collaborating clients. Furthermore, conflicting
				  class extensions are either disallowed, or resolved
				  by linearization, with consequent negative effects.
				  To solve these problems we present classboxes, a
				  module system for object-oriented languages that
				  provides for method addition and replacement.
				  Moreover, the changes made by a classbox are only
				  visible to that classbox (or classboxes that import
				  it), a feature we call local rebinding. To validate
				  the model we have implemented it in the Squeak
				  Smalltalk environment, and performed benchmarks.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
	Cvs = {ClassboxESUG04},
	Doi = {10.1016/j.cl.2004.11.002},
	Impactfactor = {0.467, SCI},
	Inria = {hors},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {scg-pub snf-actsc scg-none jb05 classbox snf05 stefPub onhindex(62) alexPub},
	Misc = {SCI impact factor 0.467},
	Month = dec,
	Number = {3-4},
	Pages = {107--126},
	Publisher = {Elsevier},
	Selectif = {non},
	Title = {Classboxes: Controlling Visibility of Class Extensions},
	Url = {http://scg.unibe.ch/archive/papers/Berg05aclassboxesJournal.pdf},
	Volume = {31},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Berg05aclassboxesJournal.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.cl.2004.11.002}}

@inproceedings{Berg05b,
	Abstract = {Unanticipated changes to complex software systems
				  can introduce anomalies such as duplicated code,
				  suboptimal inheritance relationships and a
				  proliferation of run-time downcasts. Refactoring to
				  eliminate these anomalies may not be an option, at
				  least in certain stages of software evolution.
				  Classboxes are modules that restrict the visibility
				  of changes to selected clients only, thereby
				  offering more freedom in the way unanticipated
				  changes may be implemented, and thus reducing the
				  need for convoluted design anomalies. In this paper
				  we demonstrate how classboxes can be implemented in
				  statically-typed languages like {Java}. We also
				  present an extended case study of Swing, a {Java}
				  GUI package built on top of AWT, and we document the
				  ensuing anomalies that Swing introduces. We show how
				  Classbox/J, a prototype implementation of classboxes
				  for {Java}, is used to provide a cleaner
				  implementation of Swing using local refinement
				  rather than subclassing.},
	Acceptnum = {25},
	Accepttotal = {142},
	Address = {New York, NY, USA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference topconference},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz},
	Booktitle = {Proceedings of 20th International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA'05)},
	Doi = {10.1145/1094811.1094826},
	Inria = {hors},
	Keywords = {snf05 stefPub alexPub snf06 scg-none jb06 scg-pub onhindex(97)},
	Misc = {acceptance rate: 25/142 = 17\%},
	Pages = {177--189},
	Publisher = {ACM Press},
	Rate = {17%},
	Selectif = {oui},
	Title = {Classbox/{J}: Controlling the Scope of Change in {Java}},
	Url = {http://scg.unibe.ch/archive/papers/Berg05bclassboxjOOPSLA.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Berg05bclassboxjOOPSLA.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1094811.1094826}}

@article{Berg05c,
	Abstract = {Each object-oriented programming language proposes
				  various grouping mechanisms to bundle interacting
				  classes (i.e., packages, modules, selector
				  namespaces, etc). To understand such diversity and
				  to compare the different approaches, a common
				  foundation is needed. As far as we are aware of, no
				  major attempt that would go in that direction has
				  been realized. In this paper we present a simple
				  module calculus together with a set of operators for
				  modeling the composition semantics of different
				  grouping mechanisms. Using this module calculus we
				  are able to express the semantics of {Java}
				  packages, C# namespaces, Ruby modules, selector
				  namespaces, gbeta classes, classboxes, MZScheme
				  units, and MixJuice modules. This calculus supports
				  the identification of system families sharing
				  similar characteristics. In addition it provides a
				  uniform way to represent and analyze fine-grained
				  module semantics.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz},
	Cvs = {ModuleAnalysisJUCS05},
	Impactfactor = {0.337, SCI},
	Inria = {hors},
	Journal = {Journal of Universal Computer Science},
	Keywords = {scg-pub skip-doi scg-none jb06 classbox snf06 stefPub alexPub listic},
	Misc = {SCI impact factor 0.337},
	Month = nov,
	Number = {10},
	Pages = {1613--1644},
	Selectif = {non},
	Title = {Analyzing Module Diversity},
	url = {http://scg.unibe.ch/archive/papers/Berg05cModuleDiversity.pdf},
	Url2 = {http://www.jucs.org/jucs_11_10/analyzing_module_diversity},
	Volume = {11},
	Year = {2005},
	Bdsk-Url-1 = {http://www.jucs.org/jucs_11_10/analyzing_module_diversity%20http://scg.unibe.ch/archive/papers/Berg05cModuleDiversity.pdf}}

@inproceedings{Berg05d,
	Abstract = {On the one hand, traits are a powerful way of
				  structuring classes. Traits support the reuse of
				  method collections over several classes. However,
				  traits cannot be used when specifying unanticipated
				  changes to an application. On the other hand,
				  classboxes are a new module system that supports the
				  local redefinition of classes: a collection of
				  classes can be locally extended with variables
				  and/or methods and the existing clients do not get
				  impacted by changes. However, an extension applied
				  to a class by a classbox cannot be reused for other
				  classes. This paper describes how combining Traits
				  and Classboxes supports the safe introduction of
				  crosscutting collaborations: safe because the
				  existing clients of the classes do not get impacted,
				  crosscutting because collaborations between several
				  classes can be put in place in a unanticipated
				  manner. In the resulting system, a collaboration is
				  represented by a classbox and a role by a trait.},
	Address = {Erfurt, Germany},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {nationalconference},
	Author = {Alexandre Bergel and St\'ephane Ducasse},
	Booktitle = {{Net}.{ObjectDays} (NODE'05)},
	Inria = {hors},
	Keywords = {snf05 scg-none jb06 scg-pub skip-doi alexPub stefPub listic},
	Month = sep,
	Pages = {61--75},
	Selectif = {non},
	Title = {Supporting Unanticipated Changes with {Traits} and {Classboxes}},
	Url = {http://scg.unibe.ch/archive/papers/Berg05dTraitsClassbox.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Berg05dTraitsClassbox.pdf}}

@article{Berg05e,
	Abstract = {Atomically introducing changes to a group of classes
				  is a challenging task. In addition, certain
				  applications require that changes be applied
				  dynamically without shutting down and restarting the
				  application. In this paper we present an extension
				  of classboxes to make them dynamic. A classbox is a
				  kind of module that supports class extension and
				  instance variable addition. Class extensions and
				  definitions defined in a classbox represent an
				  aspect. In addition, with classboxes, aspects are
				  dynamically applied to, removed from hot- in a
				  system. Such aspects may crosscut a large number of
				  classes which are extended by adding or redefining
				  existing methods and adding new instance variables.
				  Finally the aspects are scoped i.e., they are local
				  to the classboxes that define them.},
	Aeres = {ACT},
	Annote = {nationaljournal},
	Author = {Alexandre Bergel and St\'ephane Ducasse},
	Cvs = {ClassboxJFDLPA04},
	Inria = {hors},
	Journal = {Revue des Sciences et Technologies de l'Information (RSTI) --- L'Objet (Num\'ero sp\'ecial : Programmation par aspects)},
	Keywords = {scg-pub skip-doi scg-none jb05 classboxes snf05 stefPub alexandrePub alexPub listic},
	Month = nov,
	Number = {3},
	Pages = {53--68},
	Publisher = {Hermes, Paris},
	Selectif = {non},
	Title = {Scoped and Dynamic Aspects with {Classboxes}},
	Url = {http://scg.unibe.ch/archive/papers/Berg05eDynamicClassboxes.pdf},
	Volume = {11},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Berg05eDynamicClassboxes.pdf}}

@inproceedings{Berg06b,
	Abstract = {Prototyping new programming languages is often
				  assimilated as a task requiring heavy expertise in
				  parsing and compilation. This paper argues that
				  choosing as a host platform a language having
				  advanced reflective capabilities helps in reducing
				  the effort and time spent on developing new language
				  related constructs and tools. The Squeak Smalltalk
				  implementation provides very expressive reflective
				  facilities. In this paper we focus on having methods
				  as first class entities, enabling methods
				  manipulation as plain standard objects and
				  reification of method execution. Powerful language
				  related tools and efficient new programming
				  constructs can be quickly implemented. ByteSurgeon,
				  a bytecode manipulation library, and FacetS, an
				  aspect mechanism, serve as illustrations.},
	Aeres = {ACT},
	Annote = {internationalworkshop},
	Author = {Alexandre Bergel and Marcus Denker},
	Booktitle = {Proceedings of the ECOOP'06 Workshop on Revival of Dynamic Languages},
	Cvs = {SqueakRSP06},
	Inria = {hors},
	Keywords = {snf06 scg-pub skip-doi scg-none jb06 fb06 alexpub},
	Medium = {4},
	Month = jul,
	Peerreview = {yes},
	Selectif = {non},
	Title = {Prototyping Languages, Related Constructs and Tools with {Squeak}},
	Url = {http://scg.unibe.ch/archive/papers/Bergel06bRDLPrototyping.pdf},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Bergel06bRDLPrototyping.pdf}}

@inproceedings{Berg07a,
	Abstract = {Traits offer a fine-grained mechanism to compose
				  classes from reusable components while avoiding
				  problems of fragility brought by multiple
				  inheritance and mixins. Traits as originally
				  proposed are \emph{stateless}, that is, they contain
				  only methods, but no instance variables. State can
				  only be accessed within traits by accessors, which
				  become \emph{required methods} of the trait.
				  Although this approach works reasonably well in
				  practice, it means that many traits, viewed as
				  software components, are artificially
				  \emph{incomplete}, and classes that use such traits
				  may contain significant amounts of boilerplate glue
				  code. Although these limitations are largely
				  mitigated by proper tool support, we seek a cleaner
				  solution that supports \emph{stateful traits}. The
				  key difficulty is how to handle conflicts that arise
				  when composed traits contribute instance variables
				  whose names clash. We present a solution that is
				  faithful to the guiding principle of stateless
				  traits: \emph{the client retains control of the
				  composition}. Stateful traits consist of a minimal
				  extension to stateless traits in which instance
				  variables are purely local to the scope of a trait,
				  unless they are explicitly made accessible by the
				  composing client of a trait. Naming conflicts are
				  avoided, and variables of disjoint traits can be
				  explicitly merged by clients. We discuss and compare
				  two implementation strategies, and briefly present a
				  case study in which stateful traits have been used
				  to refactor the trait-based version of the Smalltalk
				  collection hierarchy.},
	Address = {Berlin Heidelberg},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
	Booktitle = {Advances in Smalltalk --- Proceedings of 14th International Smalltalk Conference (ISC 2006)},
	Doi = {10.1007/978-3-540-71836-9_3},
	Inria = {hors},
	Isbn = {978-3-540-71835-2},
	Issn = {0302-9743},
	Keywords = {scg07 stefPub scg-pub jb07 snf06 traits},
	Medium = {2},
	Month = aug,
	Pages = {66--90},
	Peerreview = {yes},
	Publisher = {Springer},
	Selectif = {non},
	Series = {LNCS},
	Title = {Stateful Traits},
	Url = {http://scg.unibe.ch/archive/papers/Berg07aStatefulTraits.pdf},
	Volume = {4406},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Berg07aStatefulTraits.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-540-71836-9_3}}

@inproceedings{Berg07c,
	Abstract = {Smalltalk is not only an object-oriented programming
				  language; it is also known for its extensive
				  integrated development environment supporting
				  interactive and dynamic programming. While the
				  default tools are adequate for browsing the code and
				  developing applications, it is often cumbersome to
				  extend the environment to support new language
				  constructs or to build additional tools supporting
				  new ways of navigating and presenting source code.
				  In this paper, we present the OmniBrowser, a browser
				  framework that supports the definition of browsers
				  based on an explicit metamodel. With OmniBrowser a
				  domain model is described in a graph and the
				  navigation in this graph is specified in its
				  associated metagraph. We present how new browsers
				  are built from predefined parts and how new tools
				  are easily described. The browser framework is
				  implemented in the Squeak Smalltalk environment.
				  This paper shows several concrete instantiations of
				  the framework: a remake of the ubiquitous Smalltalk
				  System Browser, and a coverage browser.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Colin Putney and Roel Wuyts},
	Booktitle = {Advances in Smalltalk --- Proceedings of 14th International Smalltalk Conference (ISC 2006)},
	Doi = {10.1007/978-3-540-71836-9_3},
	Inria = {hors},
	Isbn = {978-3-540-71835-2},
	Issn = {0302-9743},
	Keywords = {scg07 stefPub scg-pub jb07 snf06},
	Medium = {2},
	Month = aug,
	Pages = {134--156},
	Peerreview = {yes},
	Publisher = {Springer},
	Selectif = {non},
	Series = {LNCS},
	Title = {Meta-Driven Browsers},
	Url = {http://scg.unibe.ch/archive/papers/Berg07cOmnibrowser.pdf},
	Volume = {4406},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Berg07cOmnibrowser.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-540-71836-9_3}}

@article{Berg08a,
	Abstract = {Page-centric Web application frameworks fail to
				  offer adequate solutions to model composition and
				  control flow. Seaside allows Web applications to be
				  developed in the same way as desktop applications.
				  Control flow is modelled as a continuous piece of
				  code, and components may be composed, configured and
				  nested as one would expect from traditional user
				  interface frameworks.},
	Aeres = {AP},
	Aeresstatus = {aeres08},
	Annote = {notrefereed},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Lukas Renggli},
	Inria = {hors},
	Journal = {ERCIM News},
	Keywords = {scg-pub snf-none skip-doi alexPub stefPub scg-none jb08},
	Month = jan,
	Selectif = {non},
	Title = {Seaside -- Advanced Composition and Control Flow for Dynamic Web Applications},
	Url = {http://ercim-news.ercim.eu/en72/special/seaside-advanced-composition-and-control-flow-for-dynamic-web-applications},
	Volume = 72,
	Year = {2008},
	Bdsk-Url-1 = {http://ercim-news.ercim.org/content/view/325/536/}}

@inproceedings{Berg08b,
	Abstract = {Following last two years' workshop on dynamic
				  languages at the ECOOP conference, the Dyla 2007
				  workshop was a successful and popular event. As its
				  name implies, the workshop's focus was on dynamic
				  languages and their applications. Topics and
				  discussions at the workshop included macro expansion
				  mechanisms, extension of the method lookup
				  algorithm, language interpretation, reflexivity and
				  languages for mobile ad hoc networks. The main goal
				  of this workshop was to bring together different
				  dynamic language communities and favouring cross
				  communities interaction. Dyla 2007 was organised as
				  a full day meeting, partly devoted to presentation
				  of submitted position papers and partly devoted to
				  tool demonstration. All accepted papers can be
				  downloaded from the workshop's web site. In this
				  report, we provide an overview of the presentations
				  and a summary of discussions.},
	Aeres = {DO},
	Aeresstatus = {aeres08},
	Annote = {workshopproceedings},
	Author = {Alexandre Bergel and Wolfgang De Meuter and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
	Booktitle = {Object-Oriented Technology. ECOOP 2007 Workshop Reader},
	Doi = {10.1007/978-3-540-78195-0},
	Inria = {hors},
	Isbn = {978-3-540-78194-3},
	Keywords = {scg07 scg-pub stefPub jb08 snf-none},
	Medium = {2},
	Pages = {7--12},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Selectif = {non},
	Series = {LNCS},
	Title = {Dynamic Languages and Applications, Report on the Workshop {Dyla}'07 at {ECOOP} 2007},
	url = {http://scg.unibe.ch/archive/papers/Berg08bDyla07Report.pdf},
	url2 = {http://www.springer.com/computer/programming/book/978-3-540-78194-3},
	Volume = {4906},
	Year = {2008},
	Bdsk-Url-1 = {http://dyla2007.unibe.ch/%20http://scg.unibe.ch/archive/papers/Berg08bDyla07Report.pdf%20http://www.springer.com/computer/programming/book/978-3-540-78194-3},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-540-78195-0}}

@article{Berg08e,
	Abstract = {Traits offer a fine-grained mechanism to compose
				  classes from reusable components while avoiding
				  problems of fragility brought by multiple
				  inheritance and mixins. Traits as originally
				  proposed are stateless, that is, they contain only
				  methods, but no instance variables. State can only
				  be accessed within stateless traits by accessors,
				  which become required methods of the trait. Although
				  this approach works reasonably well in practice, it
				  means that many traits, viewed as software
				  components, are artificially \emph{incomplete}, and
				  classes that use such traits may contain significant
				  amounts of boilerplate glue code. We present an
				  approach to stateful traits that is faithful to the
				  guiding principle of stateless traits: the client
				  retains control of the composition. Stateful traits
				  consist of a minimal extension to stateless traits
				  in which instance variables are purely local to the
				  scope of a trait, unless they are explicitly made
				  accessible by the composing client of a trait. We
				  demonstrate by means of a formal object calculus
				  that adding state to traits preserves the flattening
				  property: traits contained in a program can be
				  compiled away. We discuss and compare two
				  implementation strategies, and briefly present a
				  case study in which stateful traits have been used
				  to refactor the trait-based version of the Smalltalk
				  collection hierarchy.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
	Doi = {10.1016/j.cl.2007.05.003},
	Impactfactor = {0.467, SCI},
	Inria = {hors},
	Issn = {1477-8424},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {traits smalltalklite scg07 stefPub scg-pub jb08 snf06},
	Medium = {2},
	Number = {2-3},
	Pages = {83--108},
	Peerreview = {yes},
	Publisher = {Elsevier},
	Selectif = {non},
	Title = {Stateful Traits and their Formalization},
	Url = {http://scg.unibe.ch/archive/papers/Berg08eStatefulTraits.pdf},
	Volume = {34},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Berg08eStatefulTraits.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.cl.2007.05.003}}

@inproceedings{Berg10d,
	Abstract = {Code profiling is an essential activity to increase
				  software quality. It is commonly employed in a wide
				  variety of tasks, such as supporting program
				  comprehension, determining execution bottlenecks,
				  and assessing code coverage by unit tests. Spy is an
				  innovative framework to easily build profilers and
				  visualize profiling information. The profiling
				  information is obtained by inserting dedicated code
				  before or after method execution. The gathered
				  profiling information is structured in line with the
				  application structure in terms of packages, classes,
				  and methods. Spy has been instantiated on four
				  occasions so far. We created profilers dedicated to
				  test coverage, time execution, type feedback, and
				  profiling evolution across version. We also
				  integrated Spy in the Pharo IDE. Spy has been
				  implemented in the Pharo Smalltalk programming
				  language and is available under the MIT license.},
	Annote = {internationalworkshop},
	Author = {Alexandre Bergel and Felipe Ba{\~n}ados and Romain Robbes and David R{\"o}thlisberger},
	Booktitle = {Smalltalks 2010},
	Keyword = {moose-pub},
	Keywords = {scg11 scg-pub snf-none jb12 roethlisberger skip-doi skip-pdf},
	Location = {Concepcion del Uruguay, Entre Rios, Argentina},
	Medium = {2},
	Peerreview = {yes},
	Title = {Spy: A Flexible Code Profiling Framework},
	Year = {2010}}

@inproceedings{Berg11b,
	Abstract = {Domain-specific languages and models are increasingly
				  used within general-purpose host languages. While traditional
				  profiling tools perform well on host language code itself, they
				  often fail to provide meaningful results if the developers start
				  to build and use abstractions on top of the host language. In
				  this paper we motivate the need for dedicated profiling tools
				  with three different case studies. Furthermore, we present
				  an infrastructure that enables developers to quickly
				  prototype new profilers for their domain-specific
				  languages and models.},
	Address = {Berlin, Heidelberg},
	Annote = {internationalconference},
	Author = {Alexandre Bergel and Oscar Nierstrasz and Lukas Renggli and Jorge Ressia},
	Booktitle = {Proceedings of the 49th International Conference on Objects, Models, Components and Patterns (TOOLS'11)},
	Doi = {10.1007/978-3-642-21952-8_7},
	Keywords = {scg1 scg-pub scg11 jb11 snf11 helvetia bifrost metaspy},
	Medium = {2},
	Month = jun,
	Pages = {68--82},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Ratex = {28%},
	Series = {LNCS},
	Title = {Domain-Specific Profiling},
	Url = {http://scg.unibe.ch/archive/papers/Berg11b-Profiling.pdf},
	Volume = {6705},
	Year = {2011},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Berg11b-Profiling.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-642-21952-8_7}}

@inproceedings{Bert03a,
	Abstract = {Understanding object-oriented legacy systems is a
				  complex task exacerbated by the presence of late
				  binding and polymorphism. Moreover, the metaphor of
				  message sending and the anthropomorphism promoted by
				  object-oriented languages makes it difficult to
				  statically identify the precise role the objects
				  play at run-time. We propose a lightweight
				  visualization approach enriched with run-time
				  information which allows us to identify precise
				  aspects of the objects lifetime such as the role
				  played in the creation of other objects and the
				  communication architecture they support. Our
				  approach not only supports the run-time
				  understanding of an application but also allows one
				  to evaluate test understanding and test coverage.},
	Annote = {internationalworkshop},
	Author = {Roland Bertuli and St\'ephane Ducasse and Michele Lanza},
	Booktitle = {Proceedings of WOOR 2003 (4th International Workshop on Object-Oriented Reengineering)},
	Keywords = {snf03 scg-pub skip-doi scg-none jb03 stefPub moose-pub},
	Pages = {10--19},
	Publisher = {University of Antwerp},
	Title = {Run-Time Information Visualization for Understanding Object-Oriented Systems},
	Url = {http://scg.unibe.ch/archive/papers/Bert03aEcoopWorkshop.pdf},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Bert03aEcoopWorkshop.pdf}}

@techreport{Blac02a,
	Abstract = {Traits are a programming language technology modeled
				  after mixins but avoiding their problems. In this
				  paper we refactor the Smalltalk collections
				  hierarchy using traits. We observed that the
				  original hierarchy contained much duplication of
				  code; traits let us remove all of it. Traits also
				  make possible much more general reuse of collection
				  code outside of the existing hierarchy; for example,
				  they make it easy to convert other collection-like
				  things into true collections. Our refactoring
				  reduced the size of the collection hierarchy by
				  approximately 12 per cent, with no measurable impact
				  on execution efficiency. More importantly,
				  understandability and reusability of the code was
				  significantly improved, and the path was paved for a
				  more intensive refactoring.},
	Address = {Universit\"at Bern, Switzerland},
	Annote = {report notrefereed},
	Author = {Andrew P. Black and Nathanael Sch\"arli and St\'ephane Ducasse},
	Classification = {D.2.6 Programming Environments D.2.10 Design D.1.5 Object-oriented Programming; D.3.3 Language Constructs and Features},
	General_Terms = {Inheritance, Mixins, Multiple Inheritance, Traits, Reuse, Smalltalk},
	Institution = {Institut f\"ur Informatik},
	Keywords = {snf03 scg-pub skip-doi scg-none jb02 scg-traits stefPub schaerli},
	Month = nov,
	Note = {Also available as Technical Report CSE-02-014, OGI School of Science \& Engineering, Beaverton, Oregon, USA},
	Number = {IAM-02-007},
	Title = {Applying Traits to the {Smalltalk} Collection Hierarchy},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Blac02aTraitsHierarchy.pdf},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Blac02aTraitsHierarchy.pdf}}

@inproceedings{Blac03a,
	Abstract = {Traits are a programming language technology that
				  promote the reuse of methods between unrelated
				  classes. This paper reports on a refactoring of the
				  Smalltalk collections classes using traits. The
				  original collection classes contained much
				  duplication of code; traits let us remove all of it.
				  We also found places where the protocols of the
				  collections lacked uniformity; traits allowed us to
				  correct these non-uniformities without code
				  duplication. Traits also make it possible to reuse
				  fragments of collection code outside of the existing
				  hierarchy; for example, they make it easy to convert
				  other collection-like things into true collections.
				  Our refactoring reduced the number of methods in the
				  collection classes by approximately 10 per cent.
				  More importantly, understandability maintainability
				  and reusability of the code were significantly
				  improved.},
	Acceptnum = {26},
	Accepttotal = {142},
	Annote = {internationalconference topconference},
	Author = {Andrew P. Black and Nathanael Sch\"arli and St\'ephane Ducasse},
	Booktitle = {OOPSLA'03: Proceedings of 17th International Conference on Object-Oriented Programming Systems, Languages and Applications},
	Cvs = {TraitsRefactoringOOPSLA2003},
	Doi = {10.1145/949305.949311},
	Keywords = {snf04 scg-pub scg-none jb02 scg-traits stefPub schaerli stlit-traits},
	Misc = {acceptance rate: 26/142 = 18\%},
	Month = oct,
	Pages = {47--64},
	Title = {Applying Traits to the {Smalltalk} Collection Hierarchy},
	Url = {http://scg.unibe.ch/archive/papers/Blac03aTraitsHierarchy.pdf},
	Volume = {38},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Blac03aTraitsHierarchy.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/949305.949311}}

@inproceedings{Blac04a,
	Abstract = {Traits are an object-oriented programming language
				  construct that allow groups of methods to be named
				  and reused in arbitrary places in an inheritance
				  hierarchy. Classes can use methods from traits as
				  well as defining their own methods and instance
				  variables. Traits thus enable a new style of
				  programming, in which traits rather than classes are
				  the primary unit of reuse. However, the additional
				  sub-structure provided by traits is always optional:
				  a class written using traits can also be viewed as a
				  flat collection of methods, with no change in its
				  semantics. This paper describes the tool that
				  supports these two alternate views of a class,
				  called the traits browser, and the programming
				  methodology that we are starting to develop around
				  the use of traits.},
	Annote = {internationalconference},
	Author = {Andrew P. Black and Nathanael Sch\"arli},
	Booktitle = {Proceedings ICSE 2004},
	Cvs = {TraitsProgrammingICSE2003},
	Doi = {10.1109/ICSE.2004.1317489},
	Keywords = {snf04 scg-pub scg-none jb02 scg-traits schaerli},
	Month = may,
	Pages = {676--686},
	Title = {Traits: Tools and Methodology},
	Url = {http://scg.unibe.ch/archive/papers/Blac04aTraitsTools.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Blac04aTraitsTools.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICSE.2004.1317489}}

@book{Blac07a,
	Abstract = {Squeak by Example, intended for both students and
				  developers, will guide you gently through the Squeak
				  language and environment by means of a series of
				  examples and exercises. This book is made available
				  under the Creative Commons Attribution-ShareAlike
				  3.0 license.},
	Aeres = {OV},
	Aeresstatus = {aeres08},
	Annote = {book},
	Author = {Andrew Black and St\'ephane Ducasse and Oscar Nierstrasz and Damien Pollet and Damien Cassou and Marcus Denker},
	Inria = {ADAM},
	Isbn = {978-3-9523341-0-2},
	Keywords = {scg07 olit scg-pub jb08 snf-none skip-doi},
	Medium = {2},
	Note = {http://squeakbyexample.org},
	Peerreview = {no},
	Publisher = {Square Bracket Associates},
	Title = {Squeak by Example},
	Url = {http://SqueakByExample.org/index.html},
	Year = {2007},
	Bdsk-Url-1 = {http://SqueakByExample.org/index.html}}

@book{Blac09a,
	Abstract = {Pharo by Example, intended for both students and
				  developers, will guide you gently through the Pharo
				  language and environment by means of a series of
				  examples and exercises. This book is made available
				  under the Creative Commons Attribution-ShareAlike
				  3.0 license.},
	Aeres = {OV},
	Aeresstatus = {aeres08},
	Annote = {book},
	Author = {Andrew Black and St\'ephane Ducasse and Oscar Nierstrasz and Damien Pollet and Damien Cassou and Marcus Denker},
	Inria = {ADAM},
	Isbn = {978-3-9523341-4-0},
	Keywords = {olit scg09 scg-pub jb09 snf-none skip-doi},
	Medium = {2},
	Peerreview = {no},
	Publisher = {Square Bracket Associates},
	Title = {Pharo by Example},
	Url = {http://pharobyexample.org},
	Year = {2009},
	Bdsk-Url-1 = {http://pharobyexample.org}}

@article{Blas21a,
  title={{RepliComment:} Identifying Clones in Code Comments},
  abstract = {Code comments are the primary means to document implementation,
	and facilitate program comprehension. Thus, their quality
	should be a primary concern to improve program maintenance.
	While much effort has been dedicated to detecting bad smells
	such as clones in code, little work has focused on comments. In
	this paper we present our solution to detect clones in comments
	that developers should fix. RepliComment can automatically
	analyze Java projects and report instances of copy-and-paste
	errors in comments, and can point developers to which comments
	should be fixed. Moreover, it can report when clones are signs
	of poorly written comments. Developers should fix these
	instances too in order to improve the quality of the code
	documentation. Our evaluation of ten well-known open source
	Java projects identified over 11K instances of comment clones,
	and over 1,300 of them are potentially critical. We improve on
	our own previous work, which could only find 36 issues in the
	same dataset. Our manual inspection of 412 issues reported by
	RepliComment reveals that it achieves a precision of 79\% in
	reporting critical comment clones. The manual inspection of 200
	additional comment clones that RepliComment filters out as
	being legitimate, could not evince any false negative.},
  author={Blasi, Arianna and Stulova, Nataliia and Gorla, Alessandra and Nierstrasz, Oscar},
  Journal = {Journal of Systems \& Software},
  Annote = {internationaljournal},
  pages = {111069},
  year={2021},
  Keywords = {scg-pub snf-asa3 scg21 jb22},
  PeerReview = {yes},
  medium = {2},
  DOI = {10.1016/j.jss.2021.111069},
  Url = {http://scg.unibe.ch/archive/papers/Blas21a-RepliComment.pdf}
}

@inproceedings{Bolz08a,
	Abstract = {We report on our experiences with the Spy project,
				  including implementation details and benchmark
				  results. Spy is a re-implementation of the Squeak
				  (i.e., Smalltalk-80) VM using the PyPy toolchain.
				  The PyPy project allows code written in RPython, a
				  subset of Python, to be translated to a multitude of
				  different backends and architectures. During the
				  translation, many aspects of the implementation can
				  be independently tuned, such as the garbage
				  collection algorithm or threading implementation. In
				  this way, a whole host of interpreters can be
				  derived from one abstract interpreter definition.
				  Spy aims to bring these benefits to Squeak, allowing
				  for greater portability and, eventually, improved
				  performance. The current Spy codebase is able to run
				  a small set of benchmarks that demonstrate
				  performance superior to many similar Smalltalk VMs,
				  but which still run slower than in Squeak itself.
				  Spy was built from scratch over the course of a week
				  during a joint Squeak-PyPy Sprint in Bern last
				  autumn.},
	Annote = {internationalconference},
	Author = {Carl Friedrich Bolz and Adrian Kuhn and Adrian Lienhard and Nicholas D. Matsakis and Oscar Nierstrasz and Lukas Renggli and Armin Rigo and Toon Verwaest},
	Booktitle = {Self-Sustaining Systems},
	Doi = {10.1007/978-3-540-89275-5_7},
	Isbn = {978-3-540-89274-8},
	Keywords = {scg08 scg-pub snf08 jb09 s3 PyPy Spy a hasler08 tverwaes akuhn},
	Medium = {2},
	Pages = {123--139},
	Peerreview = {yes},
	Publisher = {Springer},
	Series = {LNCS},
	Title = {Back to the future in one week --- implementing a {Smalltalk} {VM} in {PyPy}},
	Url = {http://scg.unibe.ch/archive/papers/Bolz08aSpy.pdf},
	Volume = {5142},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Bolz08aSpy.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-540-89275-5_7}}

@inproceedings{Brue08b,
	Abstract = {Much of the knowledge about software systems is
				  implicit, and therefore difficult to recover by
				  purely automated techniques. Architectural layers
				  and the externally visible features of software
				  systems are two examples of information that can be
				  difficult to detect from source code alone, and that
				  would benefit from additional human knowledge.
				  Typical approaches to reasoning about data involve
				  encoding an explicit meta-model and expressing
				  analyses at that level. Due to its informal nature,
				  however, human knowledge can be difficult to
				  characterize up-front and integrate into such a
				  meta-model. We propose a generic, annotation-based
				  approach to capture such knowledge during the
				  reverse engineering process. Annotation types can be
				  iteratively defined, refined and transformed,
				  without requiring a fixed meta-model to be defined
				  in advance. We show how our approach supports
				  reverse engineering by implementing it in a tool
				  called Metanool and by applying it to (i) analyzing
				  architectural layering, (ii) tracking reengineering
				  tasks, (iii) detecting design flaws, and (iv)
				  analyzing features.},
	Annote = {internationalconference},
	Author = {Andrea Br\"{u}hlmann and Tudor G\^irba and Orla Greevy and Oscar Nierstrasz},
	Booktitle = {International Conference on Model Driven Engineering Languages and Systems (Models 2008)},
	Doi = {10.1007/978-3-540-87875-9_46},
	Editor = {Krzysztof Czarnecki et al.},
	Isbn = {978-3-540-87874-2},
	Keywords = {scg08 scg-pub jb09 hasler08 girba moose-pub annotations meta-modeling},
	Medium = {2},
	Pages = {660-674},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Enriching Reverse Engineering with Annotations},
	Url = {http://scg.unibe.ch/archive/papers/Brue08b-Metanool.pdf},
	Volume = {5301},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Brue08b-Metanool.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-540-87875-9_46}}

@techreport{Brun09a,
	Abstract = {Virtual machines emulating hardware devices are
				  generally implemented in low-level languages and
				  using a low-level style for performance reasons.
				  This trend results in largely difficult to
				  understand, difficult to extend and unmaintainable
				  systems. As new general techniques for virtual
				  machines arise, it gets harder to incorporate or
				  test these techniques because of early design and
				  optimization decisions. In this paper we show how
				  such decisions can be postponed to later phases by
				  separating virtual machine implementation issues
				  from the high-level machine-specific model. We
				  construct compact models of whole-system VMs in a
				  high-level language, which exclude all low-level
				  implementation details. We use the pluggable
				  translation toolchain PyPy to translate those models
				  to executables. During the translation process, the
				  toolchain reintroduces the VM implementation and
				  optimization details for specific target platforms.
				  As a case study we implement an executable model of
				  a hardware gaming device. We show that our approach
				  to VM building increases understandability,
				  maintainability and extendability while preserving
				  performance.},
	Annote = {report notrefereed},
	Author = {Camillo Bruni and Toon Verwaest and Marcus Denker},
	Institution = {University of Bern, Institute of Applied Mathematics and Computer Sciences},
	Keywords = {scg09 scg-pub jb09 snf09 skip-doi tverwaes},
	Medium = {2},
	Number = {IAM-09-002},
	Peerreview = {yes},
	Title = {{PyGirl}: Generating Whole-System {VM}s from high-level models using {PyPy}},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Brun09aPyGirlTechreport.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Brun09aPyGirlTechreport.pdf}}

@inproceedings{Brun09c,
	Abstract = {Virtual machines (VMs) emulating hardware devices
				  are generally implemented in low-level languages for
				  performance reasons. This results in unmaintainable
				  systems that are difficult to understand. In this
				  paper we report on our experience using the PyPy
				  toolchain to improve the portability and reduce the
				  complexity of whole-system VM implementations. As a
				  case study we implement a VM prototype for a
				  Nintendo Game Boy, called PyGirl, in which the
				  high-level model is separated from low-level VM
				  implementation issues. We shed light on the process
				  of refactoring from a low-level VM implementation in
				  Java to a high-level model in RPython. We show that
				  our whole-system VM written with PyPy is
				  significantly less complex than standard
				  implementations, without substantial loss in
				  performance.},
	Annote = {internationalconference},
	Author = {Camillo Bruni and Toon Verwaest},
	Booktitle = {Objects, Components, Models and Patterns, Proceedings of TOOLS Europe 2009},
	Doi = {10.1007/978-3-642-02571-6_19},
	Keywords = {scg09 scg-pub jb09 snf09 tverwaes},
	Medium = {2},
	Pages = {328--347},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Series = {LNBIP},
	Title = {{PyGirl}: Generating Whole-System {VMs} from High-Level Prototypes using {PyPy}},
	Url = {http://scg.unibe.ch/archive/papers/Brun09cPyGirl.pdf},
	Volume = {33},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Brun09cPyGirl.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-642-02571-6_19}}

@inproceedings{Bueh22a,
	author = {Noah B\"{u}hlmann and Mohammad Ghafari},
	title = {How Do Developers Deal with Security Issue Reports on GitHub?},
	year = {2022},
	isbn = {9781450387132},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	Url = {https://arxiv.org/pdf/2112.10359},
	doi = {10.1145/3477314.3507123},
	abstract = {Security issue reports are the primary means of informing development teams of security
		risks in projects, but little is known about current practices. We aim to understand the
		characteristics of these reports in open-source projects and uncover opportunities to improve
		developer practices. We analysed 3 493 security issue reports in 182 different projects on GitHub
		and manually studied 333 reports, and their discussions and pull requests. We found that, the
		number of security issue reports has increased over time, they are resolved faster, and they are
		reported in earlier development stages compared to past years. Nevertheless, a tiny group of
		developers are involved frequently, security issues progress slowly, and a great number of them has
		been pending for a long time. We realized that only a small subset of security issue reports
		include reproducibility data, a potential fix is rarely suggested, and there is no hint regarding
		how a reporter spotted an issue. We noted that the resolution time of an issue is significantly
		shorter when the first reaction to a security report is fast and when a reference to a known
		vulnerability exists.},
	booktitle = {Proceedings of the 37th ACM/SIGAPP Symposium on Applied Computing},
	pages = {1580--1589},
	numpages = {10},
	keywords = {scg-pub snf-none security, developer practice, open-source software development},
	location = {Virtual Event},
	series = {SAC '22}
}

@inproceedings{Call11a,
	Abstract = {The dynamic and reflective features of programming
				  languages are powerful constructs that programmers often
				  mention as extremely useful. However, the ability to
				  modify a program at runtime can be both a boon---
				  in terms of flexibility---, and a curse---in terms of tool support.
				  For instance, usage of these features hampers the design
				  of type systems, the accuracy of static analysis techniques,
				  or the introduction of optimizations by compilers. In this
				  paper, we perform an empirical study of a large Smalltalk
				  codebase---often regarded as the poster-child in terms
				  of availability of these features---, in order to assess how
				  much these features are actually used in practice,
				  whether some are used more than others, and in which
				  kinds of projects. These results are useful to make informed
				  decisions about which features to consider
				  when designing language extensions or tool support.},
	Address = {New York, NY, USA},
	Annote = {internationalconference},
	Author = {Oscar Calla{\'u} and Romain Robbes and {\'E}ric Tanter and David R{\"o}thlisberger},
	Booktitle = {Proceedings of the 8th Working Conference on Mining Software Repositories (MSR 2011)},
	Doi = {10.1145/1985441.1985448},
	Journal = {msr},
	Keywords = {scg-pub scg11 snf11 jb11 roethlisberger sde-ecosystems},
	Medium = {2},
	Pages = {23--32},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Title = {How Developers Use the Dynamic Features of Programming Languages: The Case of {Smalltalk}},
	Url = {http://scg.unibe.ch/archive/papers/Call11aDynamicFeaturesMSR2011.pdf},
	Year = {2011},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Call11aDynamicFeaturesMSR2011.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1985441.1985448}}

@inproceedings{Cara14a,
	Annote = {internationalconference},
	Author = {Andrea Caracciolo and Mircea Lungu and Oscar Nierstrasz},
	Booktitle = {European Conference on Software Architecture (ECSA)},
	Abstract = {Software architecture is the result of a design effort
		aimed at ensuring a certain set of quality attributes. As we show,
		quality requirements are commonly specified in practice but are rarely
		validated using automated techniques. In this paper we analyze and
		classify commonly specified quality requirements after interviewing
		professionals and running a survey. We report on tools used to validate
		those requirements and comment on the obstacles encountered by
		practitioners when performing such activity (e.g., insufficient
		tool-support; poor understanding of users needs). Finally we discuss
		opportunities for increasing the adoption of automated tools based on
		the information we collected during our study (e.g., using a
		business-readable notation for expressing quality requirements;
		increasing awareness by monitoring non-functional aspects of a system).},
	Month = aug,
	Publisher = {Springer Berlin Heidelberg},
	Series = {Lecture Notes in Computer Science},
	Volume = {8627},
	Pages = {374--389},
	Title = {How Do Software Architects Specify and Validate Quality Requirements?},
	Year = {2014},
	PeerReview = {yes},
	Medium = {2},
	Keywords = {scg-pub snf-asa1 scg14 jb14 arch-constr-survey},
	Doi = {10.1007/978-3-319-09970-5_32},
	Url = {http://scg.unibe.ch/archive/papers/Cara14a-SpecifyValidateQualityRequirements.pdf},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Cara14a-SpecifyValidateQualityRequirements.pdf}}

@inproceedings{Cara14b,
	Annote = {internationalworkshop},
	Author = {Andrea Caracciolo and Mircea Lungu and Oscar Nierstrasz},
	Abstract = {Software architecture consists of a set of design choices that can be
		partially expressed in form of rules that the implementation must conform to.
		Architectural rules are intended to ensure properties that fulfill fundamental
		non-functional requirements. Verifying architectural rules is often a non- trivial
		activity: available tools are often not very usable and support only a narrow subset of
		the rules that are commonly specified by practitioners. In this paper we present a new
		highly-readable declarative language for specifying architectural rules. With our
		approach, users can specify a wide variety of rules using a single uniform notation.
		Rules can get tested by third-party tools by conforming to pre-defined specification
		templates. Practitioners can take advantage of the capabilities of a growing number of
		testing tools without dealing with them directly.},
	title = {Dicto: A Unified {DSL} for Testing Architectural Rules},
	booktitle = {Proceedings of the 2014 European Conference on Software Architecture Workshops},
	series = {ECSAW '14},
	year = {2014},
	isbn = {978-1-4503-2778-7},
	location = {Vienna, Austria},
	pages = {21:1--21:4},
	articleno = {21},
	numpages = {4},
	PeerReview = {yes},
	Medium = {2},
	Keywords = {scg-pub snf-asa1 scg14 jb14 dicto-dsl DSL, Software Architecture, Validation},
	Url = {http://scg.unibe.ch/archive/papers/Cara14b-Dicto.pdf},
	doi = {10.1145/2642803.2642824},
	acmid = {2642824},
	publisher = {ACM},
	address = {New York, NY, USA}
}

@inproceedings{Cara14c,
	Annote = {internationalconference},
	Author = {Andrea Caracciolo and Andrei Chi\c{s} and Boris Spasojevi\'{c} and Mircea Lungu},
	Abstract = {Software corpora facilitate reproducibility of analyses, however, static analysis for an entire corpus still requires considerable effort, often duplicated unnecessarily by multiple users. Moreover, most corpora are designed for single languages increasing the effort for cross-language analysis. To address these aspects we propose Pangea, an infrastructure allowing fast development of static analyses on multi-language corpora. Pangea uses language-independent meta-models stored as object model snapshots that can be directly loaded into memory and queried without any parsing overhead. To reduce the effort of performing static analyses, Pangea provides out-of-the box support for: creating and refining analyses in a dedicated environment, deploying an analysis on an entire corpus, using a runner that supports parallel execution, and exporting results in various formats. In this tool demonstration we introduce Pangea and provide several usage scenarios that illustrate how it reduces the cost of analysis.},
	title = {Pangea: A Workbench for Statically Analyzing Multi-Language Software Corpora},
	booktitle = {Source Code Analysis and Manipulation (SCAM), 2014 IEEE 14th International Working Conference on},
	year = {2014},
	month = sep,
	location = {Victoria, British Columbia, Canada},
	numpages = {6},
	Pages = {71--76},
	PeerReview = {yes},
	Medium = {2},
	doi = {10.1109/SCAM.2014.38},
	isbn = {978-1-4799-6148-1},
	Keywords = {scg-pub snf-asa1 scg14 jb15 pangea software corpora Andrei Chis Spasojevic},
	Url = {http://scg.unibe.ch/archive/papers/Cara14c.pdf},
	publisher = {IEEE}
}

@article{Cara14d,
	Abstract = {Dicto is a declarative language for specifying architectural rules using a single uniform notation. Once defined, rules can automatically be validated using adapted off-the-shelf tools.},
	Title = {Dicto: Keeping Software Architecture Under Control},
	Annote = {notrefereed},
	Author = {Andrea Caracciolo and Mircea Lungu and Oscar Nierstrasz},
	Journal = {ERCIM News},
	PeerReview = {no},
	Medium = {2},
	Keywords = {scg-pub snf-asa1 scg14 jb15 skip-doi dicto-dsl DSL Software Architecture Validation},
	Month = oct,
	Url = {http://ercim-news.ercim.eu/en99/special/dicto-keeping-software-architecture-under-control},
	Volume = 99,
	Year = {2014}
}

@inproceedings{Cara15a,
	Annote = {internationalworkshop},
	Author = {Andrea Caracciolo},
	Title = {A Unified Approach to Automatic Testing of Architectural Constraints},
	Booktitle = {Proceedings of ICSE 2015 (37st International Conference on Software Engineering), Doctoral Symposium},
	volume={2},
	pages={871-874},
	Keywords = {scg-pub snf-asa1 scg15 jb15 dicto-dsl},
	PeerReview = {yes},
	Medium = {2},
	Publisher = {ACM Press},
	Abstract = {Architectural decisions are often encoded in the form of constraints and guidelines. Non-functional requirements can be ensured by checking the conformance of the implementation against this kind of invariant. Conformance checking is often a costly and error-prone process that involves the use of multiple tools, differing in effectiveness, complexity and scope of applicability. To reduce the overall effort entailed by this activity, we propose a novel approach that supports verification of human- readable declarative rules through the use of adapted off-the-shelf tools. Our approach consists of a rule specification DSL, called Dicto, and a tool coordination framework, called Probo. The approach has been implemented in a soon to be evaluated prototype.},
	Year = {2015},
	doi={10.1109/ICSE.2015.281},
	Url = {http://scg.unibe.ch/archive/papers/Cara15a.pdf}}

@inproceedings{Cara15b,
	Annote = {internationalconference},
	Author = {Andrea Caracciolo and Mircea Lungu and Oscar Nierstrasz},
	Title = {A Unified Approach to Architecture Conformance Checking},
	Abstract = {Software erosion can be controlled by periodically checking for consistency between the de facto architecture and its theoretical counterpart. Studies show that this process is often not automated and that developers still rely heavily on manual reviews, despite the availability of a large number of tools. This is partially due to the high cost involved in setting up and maintaining tool-specific and incompatible test specifications that replicate otherwise documented invariants. To reduce this cost, our approach consists in unifying the functionality provided by existing tools under the umbrella of a common business-readable DSL. By using a declarative language, we are able to write tool-agnostic rules that are simple enough to be understood by non-technical stakeholders and, at the same time, can be interpreted as a rigorous specification for checking architecture conformance},
	Booktitle = {Proceedings of the 12th Working IEEE/IFIP Conference on Software Architecture (WICSA)},
	Keywords = {scg-pub snf-asa1 scg15 jb15 dicto-dsl},
	PeerReview = {yes},
	Medium = {2},
	Publisher = {ACM Press},
	Year = {2015},
	month=may,
	pages={41-50},
	doi = {10.1109/WICSA.2015.11},
	Url = {http://scg.unibe.ch/archive/papers/Cara15b.pdf}}

@inproceedings{Cara15c,
	Annote = {internationalworkshop},
	Author = {Andrea Caracciolo},
	Abstract = {Software architecture erodes over time and needs to be constantly monitored to be kept consistent with its original intended design. Consistency is rarely monitored using automated techniques. The cost associated to such an activity is typically not considered proportional to its benefits.
To improve this situation, we propose Dicto, a uniform DSL for specifying architectural invariants. This language is designed to reduce the cost of consistency checking by offering a framework in which existing validation tools can be matched to newly-defined language constructs.
In this paper we discuss how such a DSL can be qualitatively and qualitatively evaluated in practice.},
	title = {On the Evaluation of a {DSL} for Architectural Consistency Checking},
	booktitle = {Extended Abstracts of the Eighth Seminar on Advanced Techniques and Tools for Software Evolution (SATToSE 2015)},
	year = {2015},
	month = jul,
	location = {Mons, Belgium},
	pages = {55--57},
	numpages = {3},
	PeerReview = {yes},
	Medium = {2},
	Keywords = {scg-pub snf-asa1 scg15 jb16 dicto-dsl DSL skip-doi},
	Url = {http://scg.unibe.ch/archive/papers/Cara15c.pdf}}

@inproceedings{Cara16b,
	Annote = {internationalconference},
	Author = {Andrea Caracciolo and Bledar Aga and Mircea Lungu and Oscar Nierstrasz},
	Title = {Marea: a Semi-automatic Decision Support System for Breaking Dependency Cycles},
	Abstract = {Dependency cycles are commonly recognized as one of the most critical quality anti-patterns. Cycles compromise the modularity of a system, prevent proper reuse and increase the cost of maintenance and testing. Many tools are capable of detecting and visualizing package cycles existing within software projects. Unfortunately, detecting cycles is only half of the work. Once detected, cycles need to be removed and this typically results in a complex process that is only partially supported by current tools. We propose a tool that offers an intelligent guidance mechanism to support developers in removing package cycles. Our tool, Marea, simulates different refactoring strategies and suggests the most cost-effective sequence of refactoring operations that will break the cycle. The optimal refactoring strategy is determined based on a custom profit function. Our approach has been validated on multiple projects and executes in linear time.},
	Keywords = {scg-pub snf-asa1 scg16 jb16 dicto-dsl},
	Booktitle = {Proceedings of the 23rd IEEE International Conference on Software Analysis, Evolution, and Reengineering (SANER)},
	PeerReview = {yes},
	Medium = {2},
	Year = {2016},
	month=mar,
	doi = {10.1109/SANER.2016.11},
	Url = {http://scg.unibe.ch/archive/papers/Cara16b.pdf}}

@inproceedings{Cara16c,
	Annote = {internationalworkshop},
	Author = {Andrea Caracciolo and Mircea Lungu and Oskar Truffer and Kirill Levitin and Oscar Nierstrasz},
	Title = {Evaluating an Architecture Conformance Monitoring Solution},
	Abstract = {Architectural rules are often defined but rarely tested. Current tools offer limited functionality and often require significant effort to be configured, automated and integrated within existing platforms. We propose a platform that is aimed at reducing the overall cost of setting up and maintaining an architectural conformance monitoring environment by decoupling the conceptual representation of a user-defined rule from its technical specification prescribed by the underlying analysis tools. The user is no longer expected to encode her constraints according to the syntax of the chosen tool, but can use a simple high-level DSL that is automatically compiled to an executable specification through custom adapters developed to support the interaction with existing off-the-shelf tools. In this paper we analyze three case studies to show how this approach can be successfully adopted to support truly diverse industrial projects. By discussing qualitative aspects of the approach, we investigate limitations and opportunities for improving general quality assessment solutions in general and DSL-based conformance tools in particular.},
	Keywords = {scg-pub snf-asa1 scg16 jb16 dicto-dsl arch-constr-eval},
	Booktitle = {Proceedings of the 7th IEEE International Workshop on Empirical Software Engineering in Practice (IWESEP)},
	doi = {10.1109/IWESEP.2016.12},
	PeerReview = {yes},
	Medium = {2},
	Year = {2016},
	month = mar,
	Url = {http://scg.unibe.ch/archive/papers/Cara16c.pdf}}

@inproceedings{Chis13a,
	Annote = {internationalworkshop},
	Abstract = {The debugger is an essential tool in any programming environment, as it helps developers understand the dynamic behaviour of software systems. However, traditional debuggers fail in answering domain-specific questions, as the semantics of what they show and do are fixed. In this paper we introduce our work towards a moldable debugger which, unlike traditional debuggers, both adapts itself and can be adapted to a particular debugging context. Thus, it allows developers to answer their questions by using concepts from their own application domains.},
	Author = {Andrei Chi\c{s} and Oscar Nierstrasz and Tudor G\^{i}rba},
	Booktitle = {Proceedings of the 7th Workshop on Dynamic Languages and Applications},
	Series = {DYLA '13},
	Doi = {10.1145/2489798.2489801},
	Keywords = {scg-pub snf-asa1 scg13 jb14 Debugging Customization Domain-specific-tools Smalltalk Andrei Chis girba},
	Medium = {2},
	Peerreview = {yes},
	Title = {Towards a Moldable Debugger},
	Url = {http://scg.unibe.ch/archive/papers/Chis13a-TowardsMoldableDebugger.pdf},
	Year = {2013},
	isbn = {978-1-4503-2041-2},
	location = {Montpellier, France},
	pages = {2:1--2:6},
	articleno = {2},
	numpages = {6},
	acmid = {2489801},
	publisher = {ACM},
	address = {New York, NY, USA},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Chis13a-TowardsMoldableDebugger.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/2489798.2489801}}

@inproceedings{Chis14a,
	Abstract = {Answering run-time questions in object-oriented systems involves reasoning about and exploring connections between multiple objects. Developer questions exercise various aspects of an object and require multiple kinds of interactions depending on the relationships between objects, the application domain and the differing developer needs. Nevertheless, traditional object inspectors, the essential tools often used to reason about objects, favor a generic view that focuses on the low-level details of the state of individual objects. This leads to an inefficient effort, increasing the time spent in the inspector. To improve the inspection process, we propose the Moldable Inspector, a novel approach for an extensible object inspector. The Moldable Inspector allows developers to look at objects using multiple interchangeable presentations and supports a workflow in which multiple levels of connecting objects can be seen together. Both these aspects can be tailored to the domain of the objects and the question at hand. We further exemplify how the proposed solution improves the inspection process, introduce a prototype implementation and discuss new directions for extending the Moldable Inspector.},
	Annote = {internationalworkshop},
	Author = {Andrei Chi\c{s} and Tudor G\^{i}rba and Oscar Nierstrasz},
	Booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2014)},
	medium={1},
	Keywords = {scg14 scg-pub jb14 snf-asa1 skip-doi, Andrei Chis, Tudor Girba, girba},
	Location = {Cambridge, England},
	Peerreview = {yes},
	Title = {The {Moldable Inspector}: a framework for domain-specific object inspection},
	Url = {http://scg.unibe.ch/archive/papers/Chis14a-MoldableInspector.pdf},
	Year = {2014}}

@inproceedings{Chis14b,
	Annote = {internationalconference},
	Author={Chi\c{s}, Andrei and G\^{i}rba, Tudor and Nierstrasz, Oscar},
	Title={The {Moldable Debugger}: A Framework for Developing Domain-Specific Debuggers},
	Abstract={Debuggers are crucial tools for developing object-oriented software systems
		as they give developers direct access to the running systems. Nevertheless, traditional
		debuggers rely on generic mechanisms to explore and exhibit the execution stack and system
		state, while developers reason about and formulate domain-specific questions using concepts
		and abstractions from their application domains. This creates an abstraction gap between the
		debugging needs and the debugging support leading to an inefficient and error-prone debugging
		effort. To reduce this gap, we propose a framework for developing domain-specific debuggers
		called the Moldable Debugger. The Moldable Debugger is adapted to a domain by creating and
		combining domain-specific debugging operations with domain-specific debugging views, and adapts
		itself to a domain by selecting, at run time, appropriate debugging operations and views.
		We motivate the need for domain-specific debugging, identify a set of key requirements and show
		how our approach improves debugging by adapting the debugger to several domains.},
	Year={2014},
	Isbn={978-3-319-11244-2},
	Booktitle={Software Language Engineering},
	Volume={8706},
	Series={Lecture Notes in Computer Science},
	Editor={Combemale, Beno\^{i}t and Pearce, David J. and Barais, Olivier and Vinju, Jurgen J.},
	Doi={10.1007/978-3-319-11245-9_6},
	PeerReview = {yes},
	Medium = {2},
	Url = {http://scg.unibe.ch/archive/papers/Chis14b-MoldableDebugger.pdf},
	Publisher={Springer International Publishing},
	Pages={102-121},
	Language={English},
	Keywords = {scg-pub snf-asa1, scg14 jb15 debugging, development environments, customization, Andrei Chis, Tudor Girba, girba},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Chis14b-MoldableDebugger.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-319-11245-9_6}}

@inproceedings{Chis15a,
     abstract={Object inspectors are an essential category of tools that allow developers to comprehend the run-time of object-oriented systems. Traditional object inspectors favor a generic view that focuses on the low-level details of the state of single objects. Based on 16 interviews with software developers and a follow-up survey with 62 respondents we identified a need for object inspectors that support different high-level ways to visualize and explore objects, depending on both the object and the current developer need. We propose the Moldable Inspector, a novel inspector model that enables developers to adapt the inspection workflow to suit their immediate needs by making the inspection context explicit, providing multiple interchangeable domain-specific views for each object, and supporting  a workflow that groups together multiple levels of connected objects. We show that the Moldable Inspector can address multiple kinds of development needs involving a wide range of objects.},
	 author = {Andrei Chi\c{s} and Tudor G\^irba and Oscar Nierstrasz and Aliaksei Syrel},
	 title = {The {Moldable} {Inspector}},
	 booktitle = {Proceedings of the 2015 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
	Annote = {internationalconference},
	 series = {Onward! 2015},
	 year = {2015},
	 location = {Pittsburgh, PA, USA},
	 pages = {44--60},
	 numpages = {17},
	 url = {http://scg.unibe.ch/archive/papers/Chis15a-MoldableInspector.pdf},
	 doi = {10.1145/2814228.2814234},
	 isbn = {978-1-4503-3688-8},
	 acmid = {2814234},
	 publisher = {ACM},
	 address = {New York, NY, USA},
	 keywords = {scg-pub scg15 jb16 snf-asa1, Andrei Chis, Tudor Girba, girba feenk-pub},
	 peerreview = {yes},
	 medium = {2}
}

@inproceedings{Chis15b,
	Annote = {internationalworkshop},
	abstract={Understanding the run-time behaviour of object-oriented applications entails the comprehension of run-time objects. Traditional object inspectors favor generic views that focus on the low-level details of the state of single objects. While universally applicable, this generic approach does not take into account the varying needs of developers that could benefit from tailored views and exploration possibilities. GTInspector is a novel moldable object inspector that provides different high-level ways to visualize and explore objects, adapted to both the object and the current developer need. More information about the GTInspector can be found at: scg.unibe.ch/research/moldableinspector},
	author = {Andrei Chi\c{s} and Tudor G\^irba and Oscar Nierstrasz and Aliaksei Syrel},
	title={{GTInspector}: A Moldable Domain-Aware Object Inspector},
	booktitle = {Proceedings of the Companion Publication of the 2015 ACM SIGPLAN Conference on Systems, Programming, and Applications: Software for Humanity},
	series = {SPLASH Companion 2015},
	year = {2015},
	location = {Pittsburgh, PA, USA},
	pages = {15--16},
	numpages = {2},
	url = {http://scg.unibe.ch/archive/papers/Chis15b-GTInspector.pdf},
	doi = {10.1145/2814189.2814194},
	isbn = {978-1-4503-3722-9},
	acmid = {2814194},
	publisher = {ACM},
	address = {New York, NY, USA},
	keywords = {scg-pub scg15 jb16 snf-asa1, Andrei Chis, Tudor Girba, girba feenk-pub},
	peerreview = {yes},
	medium = {2}
}

@article{Chis15c,
	abstract = {Understanding the run-time behavior of software systems can be a challenging activity. Debuggers are an essential category of tools used for this purpose as they give developers direct access to the running systems. Nevertheless, traditional debuggers rely on generic mechanisms to introspect and interact with the running systems, while developers reason about and formulate domain-specific questions using concepts and abstractions from their application domains. This mismatch creates an abstraction gap between the debugging needs and the debugging support leading to an inefficient and error-prone debugging effort, as developers need to recover concrete domain concepts using generic mechanisms. To reduce this gap, and increase the efficiency of the debugging process, we propose a framework for developing domain-specific debuggers, called the Moldable Debugger, that enables debugging at the level of the application domain. The Moldable Debugger is adapted to a domain by creating and combining domain-specific debugging operations with domain-specific debugging views, and adapts itself to a domain by selecting, at run time, appropriate debugging operations and views. To ensure the proposed model has practical applicability (i.e., can be used in practice to build real debuggers), we discuss, from both a performance and usability point of view, three implementation strategies. We further motivate the need for domain-specific debugging, identify a set of key requirements and show how our approach improves debugging by adapting the debugger to several domains.},
	title = {Practical domain-specific debuggers using the {Moldable Debugger} framework},
	journal = {Computer Languages, Systems \& Structures},
	volume = {44, Part A},
	pages = {89--113},
	year = {2015},
	Annote = {internationaljournal},
	note = {Special issue on the 6th and 7th International Conference on Software Language Engineering ({SLE} 2013 and {SLE} 2014)},
	issn = {1477-8424},
	doi = {10.1016/j.cl.2015.08.005},
	url = {http://scg.unibe.ch/archive/papers/Chis15c-PracticalDomainSpecificDebuggers.pdf},
	peerReview = {yes},
	author = {Andrei Chi\c{s} and Marcus Denker and Tudor G\^irba and Oscar Nierstrasz},
	medium = {2},
	keywords = {scg-pub scg15 jb16 snf-asa1 Andrei Chis, Tudor Girba, Debugging, Customization, Domain-specific tools, User interfaces, Programming environments, Smalltalk, girba feenk-pub}
}

@inproceedings{Chis15d,
	Abstract = {Developers commonly ask detailed and domain-specific questions about the software systems they are developing and maintaining. Integrated development environments (IDEs) form an essential category of tools for developing software that should support software engineering decision making. Unfortunately, rigid and generic IDEs that focus on low-level programming tasks, that promote code rather than data, and that suppress customization, offer limited support for informed decision making during software development. We propose to improve decision making within IDEs by moving from generic to context-aware IDEs through moldable tools. In this paper, we promote the idea of moldable tools, illustrate it with concrete examples, and discuss future research directions.},
	Author = {Andrei Chi\c{s} and Tudor G\^{i}rba and Oscar Nierstrasz},
	booktitle = {Proceedings of the 6th Workshop on Evaluation and Usability of Programming Languages and Tools},
    series = {PLATEAU '15},
	doi = {10.1145/2846680.2846684},
	Keywords = {scg-pub scg15 jb16 snf-asa1, internationalworkshop, Andrei Chis,Tudor Girba, girba feenk-pub},
	location = {Pittsburgh, PA, USA},
	Peerreview = {yes},
	medium = {2},
	Title = {Towards moldable development tools},
	Url = {http://scg.unibe.ch/archive/papers/Chis15d_TowardsMoldableDevelopmentTools.pdf},
	Year = {2015},
	isbn = {978-1-4503-3907-0},
	pages = {25--26},
	acmid = {2846684},
	publisher = {ACM},
	address = {New York, NY, USA}
}

@inproceedings{Chis16a,
	Abstract = {Software systems involve many different kinds of domain-specific and interrelated software entities.
A common strategy employed by developers to deal with this reality is to perform exploratory investigations by means of searching.
Nevertheless, most integrated development environments (IDEs) support searching through generic and disconnected search tools.
This impedes search tasks over domain-specific entities as considerable effort is wasted by developers locating and linking data and concepts relevant to their application domains. To tackle this problem we propose Spotter, a moldable framework for supporting contextual-aware searching in IDEs by enabling developers to easily create custom searches for domain objects.  In this paper we motivate a set of requirements for Spotter and show, through usage scenarios, that Spotter improves program comprehension by reducing the effort required to find and search through concepts from a wide range of domains. Furthermore, we show that by taking code into account, Spotter can provide a single entry point for embedding search support within an IDE.},
	Author = {Andrei Chi\c{s} and Tudor G\^irba and Juraj Kubelka and Oscar Nierstrasz and Stefan Reichhart and Aliaksei Syrel},
	Booktitle = {Proceedings of the 2016 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
	Annote = {internationalconference},
	Series = {Onward! 2016},
	Title = {Moldable, context-aware searching with {Spotter}},
	Doi = {10.1145/2986012.2986023},
	pages = {128--144},
	Numpages = {17},
	Location = {Amsterdam, Netherlands},
	Year = {2016},
	Peerreview = {yes},
	Medium = {2},
	Publisher = {ACM},
	Keywords = {scg-pub scg16 jb17 snf-asa2 Andrei Chis, Spotter, Tudor Girba, girba feenk-pub},
	Url = {http://scg.unibe.ch/archive/papers/Chis16a-MoldableContextAwareSearchingWithSpotter.pdf},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Chis16a-MoldableContextAwareSearchingWithSpotter.pdf},
	Address = {New York, NY, USA}}

@inproceedings{Chis16b,
	Abstract = {Developing and evolving software requires developers to continuously make decisions about how to steer the design and implementation of their applications. To make informed decisions developers commonly formulate detailed and domain-specific questions about their software systems and  use tools to explore available information and answer those questions. Development tools however focus on generic programming tasks while program comprehension and analysis tools typically are not tightly integrated with their development tools and environments. This  has a negative effect on program comprehension as it increases the effort and the time needed to obtain an answer. To improve program comprehension we propose that developers build software using development tools tailored to their specific application domains, as this can directly answer domain-specific questions. We introduce moldable development as an approach for developing software in which developers evolve development tools together with their applications.  In this paper we sketch the idea of moldable development and give examples to illustrate how it can be applied in practice. Through these examples we show that given a low cost for extending development tools, developers can create relevant and useful customizations to help them evolve their own applications.},
	Annote = {internationalworkshop},
	Author = {Andrei Chi\c{s} and Tudor G\^irba and Juraj Kubelka and Oscar Nierstrasz and Stefan Reichhart and Aliaksei Syrel},
	Booktitle = {Proceedings of the Programming Experience 2016 (PX/16) Workshop},
 	Series = {PX/16},
	Location={Rome, Italy},
	Title = {Exemplifying Moldable Development},
	Doi = {10.1145/2984380.2984385},
	Isbn = {978-1-4503-4776-1},
	Pages= {33--42},
	Numpages = {10},
	Year = {2016},
	Peerreview = {yes},
	Medium = {2},
        Acmid = {2984385},
	Publisher = {ACM},
	Address = {New York, NY, USA},
	Language={English},
	Url = {http://scg.unibe.ch/archive/papers/Chis16b-ExemplifyingMoldableDevelopment.pdf},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Chis16b-ExemplifyingMoldableDevelopment.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/2984380.2984385},
	Keywords = {scg-pub, snf-asa2, scg16, jb16, internationalworkshop, Andrei Chis, Domain-specific tools, User interfaces, Programming environments, Program comprehension, Tudor Girba, girba feenk-pub}
}

@inproceedings{Chis16e,
	abstract={Reasoning about object-oriented applications requires developers to answer contextual questions about their domain objects. Tailored development tools can support developers in this activity by providing relevant domain-specific information. Nonetheless, a high effort for extending development tools to handle domain-specific objects, together with diverging mechanisms for creating, sharing and discovering extensions, discourage developers to adapt their tools. To address this, we propose to enable contextual behavior in development tools by allowing domain objects to decide how they are handled in development tools. We show that combining this idea with mechanisms for specifying extensions using  internal DSLs can significantly reduce the cost of tailoring development tools to specific domains.},
	author = {Andrei Chi\c{s} },
	title={Towards object-aware development tools},
	booktitle = {Companion Proceedings of the 2016 ACM SIGPLAN International Conference on Systems, Programming, Languages and Applications: Software for Humanity},
	series = {SPLASH Companion 2016},
	year = {2016},
	location = {Amsterdam, Netherlands},
	pages = {65-66},
	numpages = {2},
	url = {http://scg.unibe.ch/archive/papers/Chis16e-ObjectAwareDevelopmentTools.pdf},
	doi = {10.1145/2984043.2998546},
	publisher = {ACM},
	address = {New York, NY, USA},
	keywords = {scg-pub, snf-asa2, scg16, jb17, Andrei Chis},
	peerreview = {yes},
	medium = {2},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Chis16e-ObjectAwareDevelopmentTools.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/2984043.2998546}
}

@incollection{Chis17a,
	Abstract = {Object-oriented programming aims to facilitate navigation between domain concepts and the code that addresses those domains by enabling developers to directly model those domain concepts in the code. To make informed decisions developers then  formulate detailed and domain-specific questions about their systems in terms of domain concepts, and use tools to explore available information and answer those questions. Development tools however focus mainly on object-oriented idioms and do not expose or exploit domain concepts constructed on top of object-oriented programming idioms. Analysis tools are typically not tightly integrated with development tools. This has a negative effect on program comprehension, increasing the effort and the time for obtaining answers. To improve program comprehension we propose to better integrate domain concepts and program comprehension tools into the development environment through moldable tools. Moldable tools are development tools that are aware of the current development context and support inexpensive creation of domain-specific extensions. We elaborate on the idea of moldable tools and show how to apply moldable tools to support object-oriented programming. Through practical examples we show how developers can embed domain concepts into their development tools.},
	Author = {Andrei Chi\c{s} and Tudor G\^irba and Juraj Kubelka and Oscar Nierstrasz and Stefan Reichhart and Aliaksei Syrel},
	Booktitle = {PAUSE: Present And Ulterior Software Engineering},
	Editor = {Manuel Mazzara, Bertrand Meyer},
	Title = {Moldable Tools for Object-oriented Development},
	Pages= {77--101},
	Publisher = {Springer, Cham},
	Doi = {10.1007/978-3-319-67425-4_6},
	Peerreview = {yes},
	Medium = {2},
	Keywords = {scg-pub snf-asa2 scg17 jb18, Andrei Chis, Tudor Girba, girba feenk-pub},
	Url = {http://scg.unibe.ch/archive/papers/Chis17a-MoldableToolsPAUSE.pdf},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Chis16c-MoldableToolsPAUSE.pdf},
	Bdsk-Url-2 = {https://link.springer.com/chapter/10.1007/978-3-319-67425-4_6},
	Year = {2017}}

@proceedings{Ciup99b,
	Address = {Forschungszentrum Informatik, Haid-und-Neu-Strasse 10-14, 76131 Karlsruhe, Germany},
	Annote = {workshopproceedings},
	Editor = {Oliver Ciupke and St\'ephane Ducasse},
	Keywords = {skip-pdf stefPub scg-pub skip-abstract skip-doi scg-none jb-none},
	Month = jun,
	Note = {FZI 2-6-6/99},
	Title = {Proceedings of the {ECOOP} '99 Workshop on Experiences in Object-Oriented Re-Engineering},
	Year = {1999}}

@inproceedings{Corr16a,
	author = {Claudio Corrodi and Alexander Heu{\ss}ner and Christopher M. Poskitt},
	title = {A Graph-Based Semantics Workbench for Concurrent Asynchronous Programs},
	abstract = {A number of novel programming languages and libraries have been proposed that offer simpler-to-use models of concurrency than threads. It is challenging, however, to devise execution models that successfully realise their abstractions without forfeiting performance or introducing unintended behaviours. This is exemplified by SCOOP---a concurrent object-oriented message-passing language---which has seen multiple semantics proposed and implemented over its evolution. We propose a "semantics workbench" with fully and semi-automatic tools for SCOOP, that can be used to analyse and compare programs with respect to different execution models. We demonstrate its use in checking the consistency of semantics by applying it to a set of representative programs, and highlighting a deadlock-related discrepancy between the principal execution models of the language. Our workbench is based on a modular and parameterisable graph transformation semantics implemented in the GROOVE tool. We discuss how graph transformations are leveraged to atomically model intricate language abstractions, and how the visual yet algebraic nature of the model can be used to ascertain soundness.},
	PeerReview = {yes},
	medium = {2},
	booktitle = {Proc. International Conference on Fundamental Approaches to Software Engineering (FASE 2016)},
	volume = {9633},
	series ={LNCS},
	pages ={31--48},
	publisher={Springer Berlin Heidelberg},
	year ={2016},
	isbn={978-3-662-49665-7},
	doi = {10.1007/978-3-662-49665-7_3},
	Keywords = {scg-pub snf-none scg16 jb16},
	url = {http://arxiv.org/abs/1603.00307},
	Address = {Berlin, Heidelberg},
	Annote = {internationalconference}
}

@inproceedings{Corr16b,
	Annote = {internationalworkshop},
	Author = {Claudio Corrodi},
	Abstract = {Debuggers are central tools in IDEs for inspecting and repairing software systems. However, they are often generic tools that operate on a low level of abstraction. Developers need to use simple breakpoint capabilities and interpret the raw data presented by the debugger. They are confronted with a large abstraction gap between application domain and debugger presentations. We propose an approach for debugging object-oriented programs, using expressive and flexible breakpoints that operate on sets of objects instead of a particular line of source code. This allows developers to adapt the debugger to their domain and work on a higher level of abstraction, which enables them to be more productive. We give an overview of the approach and demonstrate the idea with a simple use case, and we discuss how our approach differs from existing work.},
	title = {Towards Efficient Object-Centric Debugging with Declarative Breakpoints},
	location = {Bergen, Norway},
	numpages = {8},
	PeerReview = {yes},
	Medium = {2},
	Keywords = {scg-pub snf-asa2 scg16 jb16 skip-doi},
	publisher = {{CEUR}},
	booktitle = {Post-proceedings of the 9th Seminar on Advanced Techniques and Tools for Software Evolution (SATToSE 2016)},
	Volume = {1791},
	year = {2016},
	month = jul,
	Pdf = {http://ceur-ws.org/Vol-1791/paper-04.pdf},
	Url = {http://scg.unibe.ch/archive/papers/Corr16b-DeclarativeBreakpoints.pdf}
}

@inproceedings{Corr18a,
	author    = {Claudio Corrodi and Timo Spring and Mohammad Ghafari and Oscar Nierstrasz},
	title = {Idea: Benchmarking {Android} Data Leak Detection Tools},
	editor = {Mathias Payer and Awais Rashid and Jose M. Such},
	booktitle = {Engineering Secure Software and Systems},
	year = {2018},
	publisher = {Springer International Publishing},
	address = {Cham},
	pages = {116--123},
	abstract = {Virtual application stores for mobile platforms contain many malign and benign applications that exhibit security issues, such as the leaking of sensitive data. In recent years, researchers have proposed a myriad of techniques and tools to detect such issues automatically. However, it is unclear how these approaches perform compared to each other. The tools are often no longer available, thus comparing different approaches is almost infeasible.},
	isbn = {978-3-319-94496-8},
	DOI = {10.1007/978-3-319-94496-8_9},
	Keywords = {scg-pub security snf-asa2 scg18 jb18},
	Peerreview = {yes},
    Annote    = {internationalconference},
	Url = {http://scg.unibe.ch/archive/papers/Corr18a.pdf},
	medium = {2}
}

@inproceedings{Cruz98b,
	Abstract = {Most of the work on coordination technology so far
				  has focused on the development of special
				  coordination languages and environments that provide
				  the basic mechanisms for realizing the coordination
				  layer of an open system. It is clear that the idea
				  of managing separately the coordination aspect from
				  the computation in a language has a lot of
				  advantages in the development of those systems.
				  Nevertheless, most of the coordination languages do
				  not take care that additionally to managing
				  coordination requirements, they must manage other
				  kinds of "openness" related requirements in Open
				  Systems. The most important requirement being to
				  support the evolution of the coordination
				  requirements themselves. This problem manifests
				  during the software development process by the
				  development over and over again of solutions to
				  similar coordination problems. To tackle this
				  problem, and instead of proposing a new language, we
				  are attempting to develop an open set of adaptable
				  and reusable software components that realize
				  various useful coordination abstractions. With these
				  components we provide explicit separation of
				  coordination from computation, and facilitate reuse
				  and evolution of coordination aspects in Open
				  Systems.},
	Address = {Vienna, Austria},
	Author = {Juan Carlos Cruz and Sander Tichelaar},
	Booktitle = {Ninth International Workshop on Database and Expert Systems Applications},
	Doi = {10.1109/DEXA.1998.707460},
	Editor = {Roland R. Wagner},
	Keywords = {snf-none scg-pub scg-coord-98 scg-none jb98 tich-papunr},
	Misc = {August 26-28},
	Month = aug,
	Pages = {578--582},
	Publisher = {IEEE Computer Press},
	Title = {Managing Evolution of Coordination Aspects in Open Systems},
	Url = {http://scg.unibe.ch/archive/papers/Cruz98bManagingEvolution.pdf},
	Year = {1998},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Cruz98bManagingEvolution.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/DEXA.1998.707460}}

@inproceedings{Cruz99a,
	Abstract = {Although coordination of concurrent objects is a
				  fundamental as-pect of object-oriented concurrent
				  programming, there is only little support for its
				  specification and abstraction at the language level.
				  This is a problem because coordination is often
				  buried in the code of the coordinated objects,
				  leading to a lack of abstraction and reuse. Here we
				  present CoLaS, a coordination model and its
				  implementation based on the notion of Coordination
				  Groups. By clearly identifying and separating the
				  coordination from the co-ordinated objects CoLaS
				  provides a better abstraction and reuse of the
				  coordination and the coordinated objects. Moreover
				  CoLaS's high dynamicity provides better support for
				  coordination of active objects.},
	Annote = {internationalconference},
	Author = {Juan-Carlos Cruz and St\'ephane Ducasse},
	Booktitle = {Proceedings of Coordination '99},
	Keywords = {stefPub olit scg-pub skip-doi scg-coord-99 snf99 flo colas scg-none jb99},
	Pages = {355--371},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {A Group Based Approach for Coordinating Active Objects},
	Url = {http://scg.unibe.ch/archive/papers/Cruz99aGroupBasedApproach.pdf},
	Volume = {1594},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Cruz99aGroupBasedApproach.pdf}}

@inproceedings{Cruz99b,
	Abstract = {Open Distributed Systems are the dominating
				  intellectual issue of the end of this century.
				  Figuring out how to build those systems will become
				  a central issue in distributed system research in
				  the next future. Although CORBA seems to provide all
				  the necessary support to construct those systems. It
				  provides a very limited support to the evolution of
				  requirements in those systems. The main problem is
				  that the description of the elements from which
				  systems are built, and the way in which they are
				  composed are mixed into the application code. Making
				  them difficult to understand, modify and customize.
				  We think that a solution to this problem goes
				  through the introduction of the so called
				  coordination models and languages into the CORBA
				  model. We propose in this paper the introduction of
				  our object coordination model called CoLaS into the
				  CORBA model.},
	Annote = {internationalworkshop},
	Author = {Juan-Carlos Cruz and St\'ephane Ducasse},
	Booktitle = {Proceedings of International Workshop in Future Trends in Distributed Computing Systems '99},
	Doi = {10.1109/FTDCS.1999.818794},
	Keywords = {olit scg-pub scg-coord-99 snf99 scg-none jb99 stefPub},
	Title = {Coordinating Open Distributed Systems},
	Url = {http://scg.unibe.ch/archive/papers/Cruz99FTDCS.pdf},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Cruz99FTDCS.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/FTDCS.1999.818794}}

@inproceedings{Cruz01a,
	Abstract = {Open Distributed Systems are the dominating
				  intellectual issue of the research in distributed
				  systems. Figuring out how to build and maintain
				  those systems becomes a central issue in distributed
				  systems research today. Although CORBA seems to
				  provide all the necessary support to the
				  construction of those systems, CORBA provides a very
				  limited support to the evolution of their
				  requirements. The main problem is that the
				  description of the elements from which the systems
				  are built, and the way in which they are composed
				  are mixed into the application code, making systems
				  difficult to understand, modify and customize. A
				  possible solution to this problem goes through the
				  introduction of the so-called coordination models
				  and languages into the CORBA model. We propose in
				  this paper a coordination programming system called
				  CORODS which introduces the CoLaSD coordination
				  model and language into the CORBA model. CoLaSD is a
				  coordination model based on the notion of
				  Coordination Groups, entities that specify, control
				  and enforces the coordination of groups of
				  collaborating active objects.},
	Address = {Le Croisic, France},
	Author = {Juan-Carlos Cruz},
	Booktitle = {Proceedings of LMO 2001},
	Keywords = {olit scg-pub skip-doi scg coordination scg-none jb01},
	Pages = {11--26},
	Title = {CORODS: A Coordination Programming System for Open Distributed Systems},
	Url = {http://scg.unibe.ch/archive/papers/Cruz01LMO.pdf},
	Volume = {7},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Cruz01LMO.pdf}}

@inproceedings{Cruz01b,
	Abstract = {Cooperative Object Information Systems are systems
				  build from objects that work together as a single
				  system. Objects that cooperate in the realization of
				  common tasks. Cooperative Object Information Systems
				  are systems constrained to continuously adapt to new
				  requirements: new objects are introduced into the
				  systems, cooperation protocols change, etc. Building
				  Cooperative Object Information Systems is difficult
				  because most of the concurrent and distributed
				  object oriented programming languages and frameworks
				  used to build them, provide only limited support for
				  their specification and abstraction, making them
				  difficult to understand, modify and customize. We
				  show in this paper how combining distributed active
				  objects, and object oriented coordination models and
				  languages, particularly the CoLaSD coordination
				  model and language, we can simplify the development
				  of Cooperative Object Information Systems, and
				  facilitate at the same time the evolution of their
				  requirements.},
	Address = {Calgary, Canada},
	Author = {Juan-Carlos Cruz},
	Booktitle = {Proceedings of OOIS 2001},
	Keywords = {olit scg-pub skip-doi scg coordination scg-none jb01},
	Title = {Supporting Development of Object Information Systems with CoLaSD},
	Url = {http://scg.unibe.ch/archive/papers/Cruz01OOIS.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Cruz01OOIS.pdf}}

@inproceedings{Cruz02a,
	Abstract = {An important family of existing coordination models
				  and languages is based on the idea of trapping the
				  messages exchanged by the coordinated entities and
				  by the specification of rules governing the
				  coordination. No model, including our CoLaS
				  coordination model, justifies clearly the reason of
				  their coordination rules. Why these rules and not
				  others? Are they all necessary? These are questions
				  that remain still open. In order to try to provide
				  an answer, in particular for the CoLaS model, we
				  propose in this paper OpenCoLaS, a framework for
				  building CoLaS coordination dialects. The OpenCoLaS
				  framework allows to experiment with the definition
				  of coordination rules.},
	Address = {York, United Kingdom},
	Author = {Juan-Carlos Cruz},
	Booktitle = {Proceedings of COORDINATION 2002},
	Keywords = {snf03 olit scg-pub skip-doi scg coordination scg-none jb02},
	Title = {{OpenCoLaS} --- a Coordination Framework for {CoLaS} Dialects},
	Url = {http://scg.unibe.ch/archive/papers/Cruz02Coordination.pdf},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Cruz02Coordination.pdf}}

@inproceedings{DeVo00a,
	Annote = {internationalworkshop},
	Author = {De Volder, Kris and Fabry, Johan and Wuyts, Roel},
	Booktitle = {Proceedings of the ECOOP 2000: Fifth International Workshop on Component-Oriented Programming},
	Keywords = {scg-old scg-pub skip-abstract skip-doi},
	Title = {Logic Meta Components as a Generic Component Model},
	Url = {http://scg.unibe.ch/archive/papers/DeVo00a.pdf},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/DeVo00a.pdf}}

@incollection{Dean15a,
	title={Domain Globalization: Using Languages to Support Technical and Social Coordination},
	author={Deantoni, Julien and Brun, C\'{e}dric and Caillaud, Benoit and France, Robert B. and Karsai, Gabor and Nierstrasz, Oscar and Syriani, Eugene},
	abstract = {When a project is realized in a globalized environment, multiple
		stakeholders from different organizations work on
		the same system. Depending on the stakeholders and their
		organizations, various (possibly overlapping) concerns
		are raised in the development of the system. In this
		context a Domain Specific Language (DSL) supports the
		work of a group of stakeholders who are responsible for
		addressing a specific set of concerns. This chapter
		identifies the open challenges arising from the
		coordination of globalized domain-specific languages. We
		identify two types of coordination: technical
		coordination and social coordination. After presenting an
		overview of the current state of the art, we discuss
		first the open challenges arising from the composition of
		multiple DSLs, and then the open challenges associated to
		the collaboration in a globalized environment.},
	year={2015},
	isbn={978-3-319-26171-3},
	booktitle={Globalizing Domain-Specific Languages},
	peerReview = {yes},
	medium = {2},
	volume={9400},
	series={Lecture Notes in Computer Science},
	editor={Combemale, Benoit and Cheng, Betty H.C. and France, Robert B. and J\'{e}z\'{e}quel, Jean-Marc and Rumpe, Bernhard},
	doi={10.1007/978-3-319-26172-0_5},
	publisher={Springer International Publishing},
	keywords={scg-pub scg15 jb16 skip-pdf},
	pages={70-87}
}

@book{Deme97a,
	Editor = {Serge Demeyer and Harald Gall},
	Keywords = {olit famoos-wrkproc scg-pub skip-abstract skip-doi toBeChecked snf97 scg-none jb97 sergedem-wrkproc oorp},
	Month = sep,
	Publisher = {Technical University of Vienna --- Information Systems Institute --- Distributed Systems Group},
	Series = {TUV-1841-97-10},
	Title = {Proceedings of the {ESEC}/{FSE} Workshop on Object-Oriented Re-engineering},
	Url = {http://scg.unibe.ch/archive/famoos/ESEC97/},
	Year = {1997}}

@article{Deme97b,
	Abstract = {Since the early 1980s, object-oriented frameworks
				  have demonstrated that programmers can encapsulate a
				  reusable, tailorable software architecture as a
				  collection of collaborating, extensible object
				  classes. Such frameworks are particularly important
				  for developing open systems in which not only
				  functionality but architecture is reused across a
				  family of related applications. Unfortunately, the
				  design of frameworks remains an art rather than a
				  science, because of the inherent conflict between
				  reuse --- packaging software components that can be
				  reused in as many contexts as possible --- and
				  tailorability --- designing software architectures
				  easily adapted to target requirements.},
	Annote = {internationaljournal},
	Author = {Serge Demeyer and Theo Dirk Meijler and Oscar Nierstrasz and Patrick Steyaert},
	Doi = {10.1145/262793.262805},
	Journal = {Communications of the ACM},
	Keywords = {olit famoos-papref hypermedia zypher scg-pub snf97 onhindex(68) scg-none jb97 sergedem-papref},
	Month = oct,
	Number = {10},
	Pages = {60--64},
	Publisher = {ACM Press},
	Title = {Design Guidelines for Tailorable Frameworks},
	Url = {http://scg.unibe.ch/archive/papers/Deme97bDesignGuidelines.pdf},
	Volume = {40},
	Year = {1997},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Deme97bDesignGuidelines.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/262793.262805}}

@inproceedings{Deme97m,
	Abstract = {This document describes a hypothetical "Framework
				  Browser" in the form of a scenario describing the
				  ideal framework programming environment.},
	Author = {Serge Demeyer},
	Booktitle = {Proceedings of the 3rd Workshop on Open Hypermedia Systems --- Hypertext '97},
	Editor = {Uffe Kock Wiil},
	Keywords = {olit hypermedia zypher scg-pub skip-doi toBeChecked snf97 scg-none jb97 sergedem-papunr},
	Month = apr,
	Pages = {26--36},
	Publisher = {The Danish National Centre for IT Research --- Forskerparken Gustav Wieds Vej 10 --- DK-8000 Aarhus C --- Denmark},
	Series = {CIT Scientific report SR-97-01},
	Title = {A Framework Browser Scenario},
	Url = {http://www.iam.unibe.ch/~demeyer/Deme97m/ http://www.iam.unibe.ch/~demeyer/Deme97m/OHWS3scenaria.html http://www.daimi.aau.dk/~kock/OHS-HT97/},
	Year = {1997},
	Bdsk-Url-1 = {http://www.iam.unibe.ch/~demeyer/Deme97m/%20http://www.iam.unibe.ch/~demeyer/Deme97m/OHWS3scenaria.html%20http://www.daimi.aau.dk/~kock/OHS-HT97/}}

@book{Deme98c,
	Address = {Kaiserslautern, Germany},
	Editor = {Serge Demeyer and Jan Bosch},
	Isbn = {3-540-65460-7-(Donation-Serge)},
	Keywords = {skip-pdf olit ecoop98proc scg-pub skip-abstract skip-doi toBeChecked scglib snf98 scg-none jb98 sergedem-volume scg-none jb98},
	Month = dec,
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Object-Oriented Technology ({ECOOP}'98 Workshop Reader)},
	Volume = {1543},
	Year = {1998}}

@article{Deme98m,
	Author = {Serge Demeyer and Harald Gall},
	Journal = {Software Engineering Notes},
	Keywords = {olit famoos-papunr scg-pub skip-abstract skip-doi toBeChecked snf98 sergedem-papunr scg-none jb98},
	Month = jan,
	Number = {1},
	Pages = {28--29},
	Publisher = {ACM},
	Title = {Workshop on Object-Oriented Re-engineering ({WOOR}'97)},
	Url = {http://scg.unibe.ch/archive/famoos/ESEC97/WOOR97rprt.html},
	Volume = {23},
	Year = {1998},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/famoos/ESEC97/WOOR97rprt.html}}

@inproceedings{Deme98n,
	Annote = {internationalworkshop},
	Author = {Serge Demeyer and St\'ephane Ducasse},
	Booktitle = {Object-Oriented Technology (ECOOP '98 Workshop Reader)},
	Editor = {Serge Demeyer and Jan Bosch},
	Keywords = {olit famoos-papunr scg-pub skip-pdf skip-abstract skip-doi snf98 metrics scg-none jb98 stefPub},
	Pages = {247--249},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Do Metrics Support Framework Development?},
	Volume = {1543},
	Year = {1998}}

@inproceedings{Deme98o,
	Author = {Serge Demeyer},
	Booktitle = {Object-Oriented Technology (ECOOP '98 Workshop Reader)},
	Editor = {Serge Demeyer and Jan Bosch},
	Keywords = {olit famoos-papunr scg-pub skip-abstract skip-doi toBeChecked snf98 sergedem-papunr scg-none jb98},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Analysis of Overridden Methods to Infer Hot Spots},
	Url = {http://www.iam.unibe.ch/~demeyer/Deme98o/ http://www.iam.unibe.ch/~demeyer/Deme98o/paper.html},
	Volume = {1543},
	Year = {1998},
	Bdsk-Url-1 = {http://www.iam.unibe.ch/~demeyer/Deme98o/%20http://www.iam.unibe.ch/~demeyer/Deme98o/paper.html}}

@misc{Deme98p,
	Abstract = {Whereas a design pattern describes and discusses a
				  solution to a design problem, a reverse engineering
				  pattern describes how to understand aspects of an
				  object-oriented design and how to identify problems
				  in that design. In the context of a project
				  developing a methodology for reengineering
				  object-oriented legacy systems into frameworks,
				  weare working on a pattern language for
				  reengineering. This paper presents three samples of
				  that pattern language, all dealing with reverse
				  engineering.},
	Author = {Serge Demeyer and Matthias Rieger and Sander Tichelaar},
	Keywords = {olit famoos-papunr scg-pub skip-doi sergedem-papunr tich-papunr snf98 scg-none jb98},
	Month = apr,
	Note = {Writing Workshop at EuroPLOP '98},
	Title = {Three Reverse Engineering Patterns},
	Url = {http://scg.unibe.ch/archive/papers/Deme98pThreeRevEngPatterns.pdf},
	Year = {1998},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Deme98pThreeRevEngPatterns.pdf}}

@inproceedings{Deme99a,
	Abstract = {Maturing a well designed framework requires a set of
				  software metrics to steer the iterative development
				  process. Based on a case study of the
				  VisualWorks/Smalltalk framework for user-interface
				  building, we conclude that today's size and
				  inheritance metrics are not reliable to detect
				  problems but are useful in measuring stability. We
				  expect that this work will contribute to the
				  application of metrics as a project management
				  tool.},
	Annote = {nationalconference},
	Author = {Serge Demeyer and St\'ephane Ducasse},
	Booktitle = {Proceedings of Languages et Mod\`eles \`a Objets (LMO'99)},
	Editor = {Jacques Malenfant},
	Keywords = {olit famoos-papref scg-pub skip-doi snf99 scg-none jb99 oorp stefPub moose-pub},
	Pages = {69--82},
	Publisher = {HERMES Science Publications, Paris},
	Title = {Metrics, Do They Really Help?},
	Url = {http://scg.unibe.ch/archive/papers/Deme99aDemeyerDucasseLMO99.pdf},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Deme99aDemeyerDucasseLMO99.pdf}}

@article{Deme99b,
	Abstract = {Object-oriented frameworks are a particularly
				  appealing approach towards software reuse. An
				  object-oriented framework represents a design for a
				  family of applications, where variations in the
				  application domain are tackled by filling in the
				  so-called hot spots. However, experience has shown
				  that the current object-oriented mechanisms (class
				  inheritance and object composition) are not able to
				  elegantly support the "fill in the hot spot" idea.
				  This paper introduces class composition as a more
				  productive approach towards hot spots, offering all
				  of the advantages of both class inheritance and
				  object composition but involving extra work for the
				  framework designer.},
	Author = {Serge Demeyer and Matthias Rieger and Theo Dirk Meijler and Edzard Gelsema},
	Journal = {Theory and Practice of Object Systems (TAPOS)},
	Keywords = {olit famoos-papref face scg-pub skip-doi toBeChecked snf98 sergedem-papref scg-none jb98},
	Month = apr,
	Number = {2},
	Pages = {73--81},
	Publisher = {John Wiley \& Sons},
	Title = {Class Composition for Specifying Framework Design},
	Url = {http://scg.unibe.ch/archive/papers/Deme99bClassComposition.pdf},
	Volume = {5},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Deme99bClassComposition.pdf}}

@inproceedings{Deme99c,
	Abstract = {Surprising as it may seem, many of the early
				  adopters of the object-oriented paradigm already
				  face a number of problems typically encountered in
				  large-scale legacy systems. Consequently, reverse
				  engineering techniques are relevant in an
				  object-oriented context as well. This paper
				  investigates a hybrid approach, combining the
				  immediate appeal of visualisations with the
				  scalability of metrics. We validate such a hybrid
				  approach by showing how CodeCrawler ---the
				  experimental platform we built--- allowed us to
				  understand the program structure of, and identify
				  potential design anomalies in a public domain
				  software system.},
	Annote = {internationalconference},
	Author = {Serge Demeyer and St\'ephane Ducasse and Michele Lanza},
	Booktitle = {Proceedings of 6th Working Conference on Reverse Engineering (WCRE '99)},
	Doi = {10.1109/WCRE.1999.806958},
	Editor = {Francoise Balmas and Mike Blaha and Spencer Rugaber},
	Keywords = {olit famoos-papref scg-pub snf99 scg-none jb99 oorp stefPub moose-pub},
	Month = oct,
	Publisher = {IEEE Computer Society},
	Title = {A Hybrid Reverse Engineering Platform Combining Metrics and Program Visualization},
	Url = {http://scg.unibe.ch/archive/papers/Deme99cCodeCrawler.pdf},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Deme99cCodeCrawler.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.1999.806958}}

@inproceedings{Deme99d,
	Abstract = {UML is currently embraced as "the" standard in
				  object-oriented modeling languages, the recent work
				  of OMG on the Meta Object Faci lity (MOF) being the
				  most noteworthy example. We welcome these
				  standardisation efforts, yet warn against the
				  tendency to use UML as the panacea for all exchange
				  standards. In particular, we argue that UML is not
				  sufficient to serve as a tool-interoperability
				  standard for integrating round-trip engineering
				  tools, because one is forced to rely on UML's
				  built-in extension mechanisms to a dequately model
				  the reality in source-code. Meanwhile, our
				  argumentation includes a number of constructive
				  suggestions that we ho pe will influence future
				  releases of the UML and MOF standards.},
	Acceptnum = {44},
	Accepttotal = {166},
	Address = {Kaiserslautern, Germany},
	Annote = {internationalconference},
	Author = {Serge Demeyer and St\'ephane Ducasse and Sander Tichelaar},
	Booktitle = {Proceedings UML '99 (The Second International Conference on The Unified Modeling Language)},
	Editor = {Bernhard Rumpe},
	Keywords = {olit famoos-papref scg-pub skip-doi snf99 scg-none jb99 stefPub moose-pub},
	Misc = {acceptance rate: 44/166 = 26\%, SCI impact 0.515, ranked 39/69},
	Month = oct,
	Pages = {630--644},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Why Unified is not Universal. {UML} Shortcomings for Coping with Round-trip Engineering},
	Url = {http://scg.unibe.ch/archive/papers/Deme99dUML99.pdf},
	Volume = {1723},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Deme99dUML99.pdf}}

@misc{Deme99e,
	Author = {Isabelle Borne and Serge Demeyer and Galal Hassan Galal},
	Keywords = {olit famoos-wrkproc scg-pub skip-abstract skip-doi toBeChecked sergedem-wrkproc scg-none jb99},
	Month = jun,
	Title = {Proceedings of the {ECOOP}'99 Workshop on Object-Oriented Architectural Evolution},
	Url = {http://www.iam.unibe.ch/~demeyer/Deme99e/ http://www.emn.fr/borne/ECOOP99-OOAE.html},
	Year = {1999},
	Bdsk-Url-1 = {http://www.iam.unibe.ch/~demeyer/Deme99e/%20http://www.emn.fr/borne/ECOOP99-OOAE.html}}

@book{Deme99f,
	Doi = {10.1145/340855.340857},
	Editor = {Serge Demeyer and Harald Gall},
	Keywords = {olit famoos-wrkproc scg-pub skip-abstract sergedem-wrkproc snf99 scg-none jb99},
	Month = sep,
	Publisher = {Technical University of Vienna --- Information Systems Institute --- Distributed Systems Group},
	Series = {TUV-1841-99-13},
	Title = {Proceedings of the {ESEC}/{FSE}'99 Workshop on Object-Oriented Re-engineering ({WOOR}'99)},
	Url = {http://www.iam.unibe.ch/~demeyer/Deme99f/},
	Year = {1999},
	Bdsk-Url-1 = {http://www.iam.unibe.ch/~demeyer/Deme99f/},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/340855.340857}}

@inproceedings{Deme99m,
	Abstract = {-No abstract, the paper is only 2 pages-},
	Author = {Serge Demeyer},
	Booktitle = {Proceedings of the 1st Workshop on Structural Computing --- Hypertext '99},
	Editor = {Peter Nuernberg},
	Keywords = {olit famoos-papunr scg-pub skip-doi toBeChecked sergedem-papunr snf99 scg-none jb99},
	Month = feb,
	Title = {Structural Computing: The Case for Reengineering Tools},
	Url = {http://www.iam.unibe.ch/~demeyer/Deme99m/ http://www.iam.unibe.ch/~demeyer/Deme99m/ht99_02.html},
	Year = {1999},
	Bdsk-Url-1 = {http://www.iam.unibe.ch/~demeyer/Deme99m/%20http://www.iam.unibe.ch/~demeyer/Deme99m/ht99_02.html}}

@inproceedings{Deme99n,
	Abstract = {This pattern language describes how to reverse
				  engineer an object-oriented software system. Since
				  the only way to achieve a truly reusable
				  object-oriented design is recognised to be iterative
				  development, reverse engineering is indeed an
				  essential facet of any object-oriented development
				  process. The pattern language itself covers the
				  different phases one encounters when reverse
				  engineering a large software system: from being
				  unfamiliar with a software system up untill
				  preparations for actual reengineering. What you read
				  here is a short version of a complete pattern
				  language. We present only five patterns in full
				  detail and include a summary for the remaining
				  patterns.},
	Address = {Konstanz, Germany},
	Annote = {internationalworkshop},
	Author = {Serge Demeyer and St\'ephane Ducasse and Sander Tichelaar},
	Booktitle = {Proceedings of the 4th European Conference on Pattern Languages of Programming and Computing, 1999},
	Editor = {Paul Dyson},
	Keywords = {olit famoos-papunr scg-pub skip-doi sergedem-papunr tich-papunr snf99 scg-none jb99 stefPub},
	Month = jul,
	Publisher = {UVK Universit\"atsverlag Konstanz GmbH},
	Title = {A Pattern Language for Reverse Engineering},
	Url = {http://scg.unibe.ch/archive/papers/Deme99nEuroplop99.pdf},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Deme99nEuroplop99.pdf}}

@inproceedings{Deme00a,
	Abstract = {Reverse engineering is the process of uncovering the
				  design and the design rationale from a functioning
				  software system. Reverse engineering is an integral
				  part of any successful software system, because
				  changing requirements lead to implementations that
				  drift from their original design. In contrast to
				  traditional reverse engineering techniques -which
				  analyse a single snapshot of a system- we focus the
				  reverse engineering effort by determining where the
				  implementation has changed. Since changes of
				  object-oriented software are often phrased in terms
				  of refactorings, we propose a set of heuristics for
				  detecting refactorings by applying lightweight,
				  object-oriented metrics to successive versions of a
				  software system. We validate our approach with three
				  separate case studies of mature object-oriented
				  software systems for which multiple versions are
				  available. The case studies suggest that the
				  heuristics support the reverse engineering process
				  by focusing attention on the relevant parts of a
				  software system.},
	Acceptnum = {26},
	Accepttotal = {142},
	Address = {New York NY},
	Annote = {internationalconference topconference},
	Author = {Serge Demeyer and St\'ephane Ducasse and Oscar Nierstrasz},
	Booktitle = {Proceedings of 15th International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA '00)},
	Doi = {10.1145/353171.353183},
	Keywords = {olit scg-pub scg-none jb00 snf00 oorp stefPub moose-pub onhindex(208)},
	Misc = {acceptance rate: 26/142 = 18\%, SCI impact factor 0.190, ranked 66/77},
	Note = {Also in ACM SIGPLAN Notices 35 (10)},
	Pages = {166--178},
	Publisher = {ACM Press},
	Title = {Finding Refactorings via Change Metrics},
	Url = {http://scg.unibe.ch/archive/papers/Deme00aFindingRefactoring.pdf},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Deme00aFindingRefactoring.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/353171.353183}}

@inproceedings{Deme00d,
	Abstract = {Since object-oriented programming is usually
				  associated with iterative development, reverse
				  engineering must be considered an essential facet of
				  the object-oriented paradigm. The reverse
				  engineering pattern language presented here
				  summarises the reverse engineering experience
				  gathered as part of the FAMOOS project, a project
				  with the explicit goal of investigating reverse and
				  reengineering techniques in an object-oriented
				  context. Due to limitations on EuroPLOP submissions,
				  only part of the full pattern language is presented,
				  namely the patterns describing how to gain an
				  initial understanding of a software system.},
	Annote = {internationalworkshop},
	Author = {Serge Demeyer and St\'ephane Ducasse and Oscar Nierstrasz},
	Booktitle = {Proceedings of EuroPLoP '2000},
	Isbn = {3-87940-775-4},
	Keywords = {snf-none stefPub olit scg-pub skip-doi scg-none jb00},
	Pages = {189--208},
	Publisher = {UVK GmbH},
	Title = {A Pattern Language for Reverse Engineering},
	Url = {http://scg.unibe.ch/archive/papers/Deme00dRevEng.pdf},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Deme00dRevEng.pdf}}

@article{Deme00m,
	Author = {Serge Demeyer and Harald Gall},
	Doi = {10.1145/340855.340857},
	Journal = {Software Engineering Notes},
	Keywords = {olit famoos-papunr scg-pub skip-abstract toBeChecked snf99 scg-none sergedem-papunr scg-none jb-none},
	Month = jan,
	Number = {1},
	Publisher = {ACM},
	Title = {Workshop on Object-Oriented Re-engineering ({WOOR}'99)},
	Url = {http://scg.unibe.ch/archive/famoos/ESEC99/WOOR99report.html},
	Volume = {25},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/famoos/ESEC99/WOOR99report.html},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/340855.340857}}

@book{Deme02a,
	Abstract = {The rapid growth of object-oriented development over
				  the past twenty years has given rise to many
				  object-oriented systems that are large, complex and
				  hard to maintain. Object-Oriented Reengineering
				  Patterns addresses the problem of understanding and
				  reengineering such object-oriented legacy systems.
				  This book collects and distills successful
				  techniques in planning a reengineering project,
				  reverse-engineering, problem detection, migration
				  strategies and software redesign. The material in
				  this book is presented as a set of "reengineering
				  patterns" --- recurring solutions that experts apply
				  while reengineering and maintaining object-oriented
				  systems. The principles and techniques described in
				  this book have been observed and validated in a
				  number of industrial projects, and reflect best
				  practice in object-oriented reengineering.},
	Annote = {book},
	Author = {Serge Demeyer and St\'ephane Ducasse and Oscar Nierstrasz},
	Isbn = {1-55860-639-4},
	Keywords = {olit scg-pub skip-doi scg-none jb02 patterns reeng snf02 stefPub moose-pub onhindex(291)},
	Publisher = {Morgan Kaufmann},
	Title = {Object-Oriented Reengineering Patterns},
	Url = {http://scg.unibe.ch/download/oorp},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/download/oorp}}

@inproceedings{Deme03a,
	Annote = {workshopproceedings},
	Author = {Serge Demeyer and St\'ephane Ducasse and Kim Mens and Adrian Trifu and Rajesh Vasa},
	Booktitle = {Object-Oriented Technology (ECOOP'03 Workshop Reader)},
	Keywords = {skip-pdf skip-doi skip-abstract scg-pub scg-none jb04 stefPub recast03},
	Pages = {72-85},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Report of the {ECOOP}'03 Workshop on Object-Oriented Reengineering},
	Year = {2003}}

@misc{Deme03b,
	Annote = {workshopproceedings},
	Author = {Wolfgang Demeuter and St\'ephane Ducasse and Theo D'hondt and Ole Lehrmann Madsen},
	Booktitle = {Object-Oriented Technology (ECOOP'03 Workshop Reader)},
	Keywords = {skip-pdf skip-doi skip-abstract scg-pub scg-none jb04 stefPub snf03},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Report of the {ECOOP}'03 Workshop on Object-Oriented Language Engineering in Post-Java Era},
	Year = {2003}}

@inproceedings{Deme05a,
	Abstract = {The notion of refactoring --- transforming the
				  source-code of an object-oriented program without
				  changing its external behaviour --- has been studied
				  intensively within the last decade. This diversity
				  has created a plethora of toy-examples, cases and
				  code snippets, which make it hard to assess the
				  current state-of-the-art. Moreover, due to this
				  diversity, there is currently no accepted way of
				  teaching good refactoring practices, despite the
				  acknowledgment in the software engineering body of
				  knowledge. Therefore, this paper presents a common
				  example --- the LAN simulation --- which has been
				  used by a number of European Universities for both
				  research and teaching purposes.},
	Acceptnum = {13},
	Accepttotal = {54},
	Address = {Los Alamitos CA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalworkshop},
	Author = {Serge Demeyer and Filip Van Rysselberghe and Tudor G\^irba and Jacek Ratzinger and Radu Marinescu and Tom Mens and Bart Du Bois and Dirk Janssens and St\'ephane Ducasse and Michele Lanza and Matthias Rieger and Harald Gall and Michel Wermelinger and Mohammad El-Ramly},
	Booktitle = {Proceedings of IWPSE 2005 (8th International Workshop on Principles of Software Evolution)},
	Doi = {10.1109/IWPSE.2005.30},
	Inri = {hors},
	Keywords = {scg-pub evolution stefPub jointERCIM girba recast06 scg-none jb06 moose-pub},
	Location = {Lisbon, Portugal},
	Misc = {acceptance rate: 13/54=24\%},
	Pages = {123--131},
	Publisher = {IEEE Computer Society Press},
	Rate = {24%},
	Selectif = {oui},
	Title = {The {LAN}-simulation: A Research and Teaching Example for Refactoring},
	Url = {http://scg.unibe.ch/archive/papers/Deme05aLANRefactoring.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Deme05aLANRefactoring.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/IWPSE.2005.30}}

@inproceedings{Deme06a,
	Annote = {workshopproceedings},
	Author = {Serge Demeyer and Kim Mens and Roel Wuyts and Yann-Ga\"el Gu\'e{e}h\'{e}neuc and Andy Zaidman and Neil Walkinshaw and Ademar Aguiar and St\'ephane Ducasse},
	Booktitle = {Object-Oriented Technology. ECOOP'05 Workshop Reader},
	Keywords = {scg-pub skip-abstract skip-doi scg-none jb-none stefPub},
	Title = {Report of the 6th ECOOP'05 Workshop on Object-Oriented Reengineering},
	Url = {https://released.info.ucl.ac.be/pmwiki/uploads/Publications/ReportOfTheSixthInternationalWorkshopOnObject-OrientedReengineering/ecoop05reader.pdf},
	Year = {2006}}

@book{Deme08a,
	Abstract = {The rapid growth of object-oriented development over
				  the past twenty years has given rise to many
				  object-oriented systems that are large, complex and
				  hard to maintain. Object-Oriented Reengineering
				  Patterns addresses the problem of understanding and
				  reengineering such object-oriented legacy systems.
				  This book collects and distills successful
				  techniques in planning a reengineering project,
				  reverse-engineering, problem detection, migration
				  strategies and software redesign. The material in
				  this book is presented as a set of "reengineering
				  patterns" --- recurring solutions that experts apply
				  while reengineering and maintaining object-oriented
				  systems. The principles and techniques described in
				  this book have been observed and validated in a
				  number of industrial projects, and reflect best
				  practice in object-oriented reengineering.},
	Annote = {book},
	Author = {Serge Demeyer and St\'ephane Ducasse and Oscar Nierstrasz},
	Isbn = {978-3-9523341-2-6},
	Keywords = {olit scg08 scg-pub snf-none jb09 skip-doi stefPub mooseCincom moose-pub},
	Medium = {2},
	Peerreview = {no},
	Publisher = {Square Bracket Associates},
	Title = {Object-Oriented Reengineering Patterns},
	Url = {http://scg.unibe.ch/download/oorp/},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/download/oorp/}}

@inproceedings{Deni09a,
	Abstract = {The increasing amount of data available about
				  software systems poses new challenges for re- and
				  reverse engineering research, as the proposed
				  approaches need to scale. In this context, concerns
				  about meta-modeling and analysis techniques need to
				  be augmented by technical concerns about how to
				  reuse and how to build upon the efforts of previous
				  research. MOOSE is an extensive infrastructure for
				  reverse engineering evolved for over 10 years that
				  promotes the reuse of engineering efforts in
				  research. MOOSE accommodates various types of data
				  modeled in the FAMIX family of meta-models. The goal
				  of this half-day workshop is to strengthen the
				  community of researchers and practitioners who are
				  working in re- and reverse engineering, by providing
				  a forum for building future research starting from
				  MOOSE and FAMIX as shared infrastructure.},
	Annote = {internationalworkshop},
	Author = {Simon Denier and Tudor G\^irba},
	Booktitle = {16th Working Conference on Software Maintenance and Reengineering (WCRE 2009)},
	Doi = {10.1109/WCRE.2009.56},
	Keywords = {scg09 scg-pub girba jb10 moose-pub hasler10},
	Medium = {2},
	Month = oct,
	Pages = {325--326},
	Peerreview = {yes},
	Title = {Workshop on {FAMIX} and {Moose} in Software Reengineering ({FAMOOSr} 2009)},
	Url = {http://scg.unibe.ch/archive/papers/Deni09aFAMOOSr2009.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Deni09aFAMOOSr2009.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.2009.56}}

@article{Denk06a,
	Abstract = {Transforming programs to alter their semantics is of
				  wide interest, for purposes as diverse as
				  off-the-shelf component adaptation, optimization,
				  trace generation, and experimentation with new
				  language features. The current wave of interest in
				  advanced technologies for better separation of
				  concerns, such as aspect-oriented programming, is a
				  solid testimony of this fact. Strangely enough,
				  almost all proposals are formulated in the context
				  of {Java}, in which tool providers encounter severe
				  restrictions due to the rigidity of the environment.
				  This paper present ByteSurgeon, a library to
				  transform binary code in Smalltalk. ByteSurgeon
				  takes full advantage of the flexibility of the
				  Squeak environment to enable bytecode transformation
				  at runtime, thereby allowing dynamic, on-the-fly
				  modification of applications. ByteSurgeon operates
				  on bytecode in order to cope with situations where
				  the source code is not available, while providing
				  appropriate high-level abstractions so that users do
				  not need to program at the bytecode level. We
				  illustrate the use of ByteSurgeon via the
				  implementation of method wrappers and a simple MOP,
				  and report on its efficiency.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Marcus Denker and St\'ephane Ducasse and {\'E}ric Tanter},
	Doi = {10.1016/j.cl.2005.10.002},
	Impactfactor = {0.467, SCI 2005},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {scg-pub stefPub scg-none jb06 snf-actsc snf06},
	Misc = {SCI impact factor 0.467 (2005)},
	Month = jul,
	Number = {2-3},
	Pages = {125--139},
	Publisher = {Elsevier},
	Selectif = {non},
	Title = {Runtime Bytecode Transformation for {Smalltalk}},
	Url = {http://scg.unibe.ch/archive/papers/Denk06aRuntimeByteCodeESUGJournal.pdf},
	Volume = {32},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Denk06aRuntimeByteCodeESUGJournal.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.cl.2005.10.002}}

@inproceedings{Denk06c,
	Abstract = {The developers of tools for dynamic analysis are
				  faced with choosing from the many approaches to
				  gathering runtime data. Typically, dynamic analysis
				  involves instrumenting the program under
				  investigation to record its runtime behavior.
				  Current approaches for byte-code based systems like
				  Java and Smalltalk rely often on inserting byte-code
				  into the program under analysis. However, detailed
				  knowledge of the target programming language or
				  virtual machine is required to implement dynamic
				  analysis tools. Obtaining and exploiting this
				  knowledge to build better analysis tools is
				  cumbersome and often distracts the tool builder from
				  the actual goal, which is the analysis of the
				  runtime behavior of a system. In this paper, we
				  argue that we need to adopt a higher level view of a
				  software system when considering the task of
				  abstracting runtime information. We focus on
				  object-oriented virtual machine based languages. We
				  want to be able to deal with the runtime system as a
				  collection of reified first-class entities. We
				  propose to achieve this by introducing a layer of
				  abstraction, i.e., a behavioral middle layer. This
				  has the advantage that the task of collecting
				  dynamic information is not concerned with low level
				  details of a specific language or virtual machine.
				  The positive effect of such a behavioral middle
				  layer is twofold: on the one hand it provides us
				  with a standard API for all dynamic analysis based
				  tools to use, on the other hand it allows the tool
				  developer to abstract from the actual implementation
				  technique.},
	Annote = {internationalworkshop},
	Author = {Marcus Denker and Orla Greevy and Michele Lanza},
	Booktitle = {2nd International Workshop on Program Comprehension through Dynamic Analysis (PCODA 2006)},
	Keywords = {scg-pub skip-doi snf07 scg-none jb07 fb06 reflectivity},
	Medium = {2},
	Pages = {32--38},
	Peerreview = {yes},
	Title = {Higher Abstractions for Dynamic Analysis},
	Url = {http://scg.unibe.ch/archive/papers/Denk06cHigherAbstractionsPCODA06.pdf http://www.lore.ua.ac.be/Events/PCODA2006/index.html},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Denk06cHigherAbstractionsPCODA06.pdf%20http://www.lore.ua.ac.be/Events/PCODA2006/index.html}}

@inproceedings{Denk07a,
	Abstract = {Over the last few years, we actively participated in
				  the maintenance and evolution of Squeak, an
				  open-source Smalltalk. The community is constantly
				  faced with the problem of enabling changes while at
				  the same time preserving compatibility. In this
				  paper we describe the current situation, the
				  problems that faced the community and we outline the
				  solutions that have been put in place. We also
				  identify some areas where problems continue to exist
				  and propose these as potential problems to addressed
				  by the research community.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalworkshop},
	Author = {Marcus Denker and St\'ephane Ducasse},
	Booktitle = {Proceedings of the ERCIM Working Group on Software Evolution (2006)},
	Doi = {10.1016/j.entcs.2006.08.003},
	Inria = {hors},
	Issn = {1571-0661},
	Keywords = {scg07 stefPub scg-pub snf06 recast06 jb07},
	Medium = {2},
	Month = jan,
	Pages = {81--91},
	Peerreview = {yes},
	Publisher = {Elsevier},
	Selectif = {non},
	Series = {Electronic Notes in Theoretical Computer Science},
	Title = {Software Evolution from the Field: an Experience Report from the {Squeak} Maintainers},
	Url = {http://scg.unibe.ch/archive/papers/Denk07aErcimEvolutionSqueak.pdf},
	Volume = {166},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Denk07aErcimEvolutionSqueak.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.entcs.2006.08.003}}

@inproceedings{Denk07b,
	Abstract = {Reflection has proved to be a powerful feature to
				  support the design of development environments and
				  to extend languages. However, the granularity of
				  structural reflection stops at the method level.
				  This is a problem since without sub-method
				  reflection developers have to duplicate efforts, for
				  example to introduce transparently pluggable
				  type-checkers or fine-grained profilers. In this
				  paper we present Persephone, an efficient
				  implementation of a sub-method meta-object protocol
				  (MOP) based on AST annotations and dual methods (a
				  compiled method and its meta-object) that reconcile
				  AST expressiveness with bytecode execution. We
				  validate the MOP by presenting TreeNurse, a method
				  instrumentation framework and TypePlug, an optional,
				  pluggable type system which is based on Persephone.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Marcus Denker and St\'ephane Ducasse and Adrian Lienhard and Philippe Marschall},
	Booktitle = {Journal of Object Technology, Special Issue. Proceedings of TOOLS Europe 2007},
	Cached = {http://scg.unibe.ch/archive/papers/Denk07bPersephoneTools.pdf},
	Doi = {10.5381/jot.2007.6.9.a14},
	Inria = {hors},
	Issn = {1660-1769},
	Keywords = {scg07 scg-pub jb08 snf07 jot snf-bmcc reflectivity},
	Medium = {2},
	Month = oct,
	Pages = {231--251},
	Peerreview = {yes},
	Publisher = {ETH},
	Selectif = {non},
	Title = {Sub-Method Reflection},
	Url = {http://www.jot.fm/contents/issue_2007_10/paper14.html},
	Volume = {6/9},
	Year = {2007},
	Bdsk-Url-1 = {http://www.jot.fm/issues/issue_2007_10/paper14.html}}

@inproceedings{Denk07c,
	Abstract = {Real world software systems change continuously to
				  meet new demands. Most programming languages and
				  development environments, however, are more
				  concerned with limiting the effects of change rather
				  than enabling and exploiting change. Various
				  techniques and technologies to exploit change have
				  been developed over the years, but there exists no
				  common support for these approaches. We propose
				  Changeboxes as a general-purpose mechanism for
				  encapsulating change as a first-class entity in a
				  running software system. Changeboxes support
				  multiple, concurrent and possibly inconsistent views
				  of software artifacts within the same running
				  system. Since Changeboxes are first-class, they can
				  be manipulated to control the scope of change in a
				  running system.Furthermore, Changeboxes capture the
				  semantics of change. Changeboxes can be used, for
				  example, to encapsulate refactorings, or to replay
				  or analyze the history of changes. In this paper we
				  introduce Changeboxes by means of a prototype
				  implementation. We illustrate the benefits that
				  Changeboxes offer for evolving software systems, and
				  we present the results of a preliminary performance
				  evaluation that assesses the costs associated with
				  Changeboxes while suggesting possible strategies for
				  improvement.},
	Address = {Lugano, Switzerland},
	Annote = {internationalconference},
	Author = {Marcus Denker and Tudor G\^irba and Adrian Lienhard and Oscar Nierstrasz and Lukas Renggli and Pascal Zumkehr},
	Booktitle = {ICDL'07: Proceedings of the 15th International Conference on Dynamic Languages},
	Doi = {10.1145/1352678.1352681},
	Isbn = {978-1-60558-084-5},
	Keywords = {scg07 scg-pub jb08 snf08 girba cop-lit},
	Medium = {2},
	Month = aug,
	Pages = {25--49},
	Peerreview = {yes},
	Publisher = {ACM Digital Library},
	Title = {Encapsulating and Exploiting Change with {Changeboxes}},
	Url = {http://scg.unibe.ch/archive/papers/Denk07cChangeboxes.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Denk07cChangeboxes.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1352678.1352681}}

@inproceedings{Denk07d,
	Abstract = {The dynamic analysis approach to feature
				  identification describes a technique for capturing
				  feature behavior and mapping it to source code.
				  Major drawbacks of this approach are (1) large
				  amounts of data and (2) lack of support for
				  sub-method elements. In this paper we propose to
				  leverage sub-method reflection to identify and model
				  features. We perform an on-the-fly analysis
				  resulting in annotating the operations participating
				  in a feature's behavior with meta-data.The primary
				  advantage of our annotation approach is that we
				  obtain a fine-grained level of granularity while at
				  the same time eliminating the need to retain and
				  analyze large traces for feature analysis.},
	Annote = {internationalworkshop},
	Author = {Marcus Denker and Orla Greevy and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 3rd International Workshop on Program Comprehension through Dynamic Analysis (PCODA 2007)},
	Issn = {1872-5392},
	Keywords = {scg07 scg-pub skip-doi snf08 jb08 reflectivity},
	Medium = {2},
	Pages = {29--33},
	Peerreview = {yes},
	Publisher = {Technische Universiteit Delft},
	Title = {Supporting Feature Analysis with Runtime Annotations},
	url = {http://scg.unibe.ch/archive/papers/Denk07dFeatureAnnotationPCODA.pdf},
	url2 = {http://swerl.tudelft.nl/bin/view/Main/PCODA2007},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Denk07dFeatureAnnotationPCODA.pdf%20http://swerl.tudelft.nl/bin/view/Main/PCODA2007}}

@inproceedings{Denk08b,
	Abstract = {Behavioral reflection is crucial to support for
				  example functional upgrades, on-the-fly debugging,
				  or monitoring critical applications. However the use
				  of reflective features can lead to severe problems
				  due to infinite metacall recursion even in simple
				  cases. This is especially a problem when reflecting
				  on core language features since there is a high
				  chance that such features are used to implement the
				  reflective behavior itself. In this paper we analyze
				  the problem of infinite meta-object call recursion
				  and solve it by providing a first class
				  representation of meta-level execution: at any point
				  in the execution of a system it can be determined if
				  we are operating on a meta-level or base level so
				  that we can prevent infinite recursion. We present
				  how meta-level execution can be represented by a
				  meta-context and how reflection becomes
				  context-aware. Our solution makes it possible to
				  freely apply behavioral reflection even on system
				  classes: the meta-context brings stability to
				  behavioral reflection. We validate the concept with
				  a robust implementation and we present benchmarks.},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalconference},
	Author = {Marcus Denker and Mathieu Suen and St\'ephane Ducasse},
	Booktitle = {Proceedings of TOOLS EUROPE 2008},
	Doi = {10.1007/978-3-540-69824-1_13},
	Hal = {inria-00271286,p56w09p},
	Inria = {RMD},
	Issn = {1865-1348},
	Keywords = {scg08 scg-pub jb08 fb08 snf08 reflectivity},
	Medium = {2},
	Pages = {218--237},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Selectif = {non},
	Series = {LNBIP},
	Title = {The Meta in Meta-object Architectures},
	Url = {http://scg.unibe.ch/archive/papers/Denk08bMetaContextLNBIP.pdf},
	Volume = 11,
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Denk08bMetaContextLNBIP.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-540-69824-1_13}}

@inproceedings{Denk10a,
	Abstract = {A feature represents a functional requirement
				  fulfilled by a system. Since many maintenance tasks
				  are expressed in terms of features, it is important
				  to establish the correspondence between a feature
				  and its implementation in source code. Traditional
				  approaches to establish this correspondence exercise
				  features to generate a trace of runtime events,
				  which is then processed by post-mortem analysis.
				  These approaches typically generate large amounts of
				  data to analyze. Due to their static nature, these
				  approaches do not support incremental and
				  interactive analysis of features. We propose a
				  radically different approach called live feature
				  analysis, which provides a model at runtime of
				  features. Our approach analyzes features on a
				  running system and also makes it possible to grow
				  feature representations by exercising different
				  scenarios of the same feature, and identifies
				  execution elements even to the sub-method level. We
				  describe how live feature analysis is implemented
				  effectively by annotating structural representations
				  of code based on abstract syntax trees. We
				  illustrate our live analysis with a case study where
				  we achieve a more complete feature representation by
				  exercising and merging variants of feature behavior
				  and demonstrate the efficiency or our technique with
				  benchmarks.},
	Annote = {internationalconference},
	Author = {Marcus Denker and Jorge Ressia and Orla Greevy and Oscar Nierstrasz},
	Booktitle = {Proceedings of MODELS 2010 Part II},
	Doi = {10.1007/978-3-642-16129-2_11},
	Isbn = {978-3-642-16128-5},
	Keywords = {snf10 jb11 scg-pub scg10 bifrost},
	Medium = {2},
	Misc = {Acceptance rate: 20.8\%},
	Month = oct,
	Pages = {138--152},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Modeling Features at Runtime},
	Url = {http://scg.unibe.ch/archive/papers/Denk10a-Models10-FeatureModels.pdf},
	Volume = 6395,
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Denk10a-Models10-FeatureModels.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-642-16129-2_11}}

@inproceedings{Deri96a,
	Abstract = {The increasing complexity and heterogeneity of
				  modern networks has pushed industry and research
				  towards a single and consistent way of managing
				  networks. The effort to define a single
				  industry-standard API for network management
				  basically failed because it did not address aspects
				  like complexity and ease of programming. Recently, a
				  common approach is to map established network
				  management standards into another object model,
				  often based on the emerging Corba standard.
				  Unfortunately even this approach has shown many
				  drawbacks related primarily to the significant
				  amount of code that has to be linked with the final
				  application and to the many limitations and
				  imperfections of the mapping itself. This paper
				  describes a new approach to inter-domain management
				  that attempts to overcome the limitations of current
				  solutions. The goal is to allow people to write
				  hybrid CMIP and SNMP-based network management
				  applications using a single and simple object model.
				  Relevant characteristics of this approach are that
				  it is light, extensible, object-oriented,
				  language-neutral, built upon software-components,
				  string-syntax based and Internet-ready. This
				  demonstrates that it is feasible to implement simple
				  and light applications for inter-domain management
				  without the need for expensive or complex
				  technologies.},
	Author = {Luca Deri},
	Booktitle = {ECOOP '96 Workshop on 'OO Technologies For Network and Service Management' Proceedings},
	Brokenurl = {http://www.zurich.ibm.com/~lde/SimpleNM.ps.Z},
	Keywords = {olit scg-pub skip-doi toBeChecked snf96 scg-none jb96},
	Month = jul,
	Title = {Network Management for the 90s},
	Year = {1996}}

@inproceedings{Deri96b,
	Abstract = {Network management standards provide a basis for
				  hiding differences between network resources, along
				  with a method of managing them in a consistent way.
				  Frequently, network management tools are based on
				  proprietary products and are often complex both to
				  use and to install. The increasing popularity of the
				  World Wide Web, with its established user interface
				  and the ability to run on almost any platform,
				  offers a new way to provide wide access to complex
				  software applications. This paper describes the
				  architecture and implementation of two new network
				  management applications that are accessible through
				  the web and are targeted to run on powerful hosts as
				  well as small mobile computers. The GDMO/ASN.1
				  Search Engine enables users to perform complex
				  queries and to navigate OSI management documents
				  exploiting the web hypertext facilities. Liaison is
				  a web-based browser for CMIP/SNMP agents equipped
				  with powerful tools such as a directory service and
				  a metadata facility.},
	Author = {Luca Deri},
	Booktitle = {2nd International IEEE Workshop on Systems Management Proceedings},
	Brokenurl = {http://www.zurich.ibm.com/~lde/Surfin.ps.Z},
	Keywords = {olit scg-pub skip-doi toBeChecked snf96 scg-none jb96},
	Month = jun,
	Pages = {158--167},
	Title = {Surfin' Network Resources Across the Web},
	Year = {1996}}

@inproceedings{Deza08a,
	Abstract = {The demands of developing modern, highly dynamic
				  applications have led to an increasing interest in
				  dynamic programming languages and mechanisms. Not
				  only applications must evolve over time, but the
				  object models themselves may need to be adapted to
				  the requirements of different run-time contexts.
				  Class-based models and prototype-based models, for
				  example, may need to co-exist to meet the demands of
				  dynamically evolving applications. Multi-dimensional
				  dispatch, fine-grained and dynamic software
				  composition, and run-time evolution of behaviour are
				  further examples of diverse mechanisms which may
				  need to co-exist in a dynamically evolving run-time
				  environment How can we model the semantics of these
				  highly dynamic features, yet still offer some
				  reasonable safety guarantees? To this end we present
				  an original calculus in which objects can adapt
				  their behaviour at run-time to changing contexts.
				  Both objects and environments are represented by
				  first-class mappings between variables and values.
				  Message sends are dynamically resolved to method
				  calls. Variables may be dynamically bound, making it
				  possible to model a variety of dynamic mechanisms
				  within the same calculus. Despite the highly dynamic
				  nature of the calculus, safety properties are
				  assured by a type assignment system.},
	Annote = {internationalworkshop},
	Author = {Mariangiola Dezani-Ciancaglini and Paola Giannini and Oscar Nierstrasz},
	Bdsk-Url-1 = {http://homepages.fh-regensburg.de/~mpool/mpool08/programme.html http://scg.unibe.ch/archive/papers/Deza08aEvolvingObjects.pdf},
	Booktitle = {Proceedings of the 6th International Workshop on Multiparadigm Programming with Object-Oriented Languages (MPOOL 2008)},
	Keywords = {snf08 scg08 scg-pub skip-doi jb08 cop-lit},
	Medium = {2},
	Note = {Extended version published in Scientific Annals of Computer Science},
	Peerreview = {yes},
	Title = {A Calculus of Evolving Objects},
	url = {http://scg.unibe.ch/archive/papers/Deza08aEvolvingObjects.pdf},
	url2 = {http://homepages.fh-regensburg.de/~mpool/mpool08/programme.html},
	Year = {2008},
	Bdsk-Url-2 = {http://homepages.fh-regensburg.de/~mpool/mpool08/programme.html%20http://scg.unibe.ch/archive/papers/Deza08aEvolvingObjects.pdf}}

@article{Deza08b,
	Abstract = {The demands of developing modern, highly dynamic
				  applications have led to an increasing interest in
				  dynamic programming languages and mechanisms. Not
				  only must applications evolve over time, but the
				  object models themselves may need to be adapted to
				  the requirements of different run-time contexts.
				  Class-based models and prototype-based models, for
				  example, may need to co-exist to meet the demands of
				  dynamically evolving applications. Multi-dimensional
				  dispatch, fine-grained and dynamic software
				  composition, and run-time evolution of behaviour are
				  further examples of diverse mechanisms which may
				  need to co-exist in a dynamically evolving run-time
				  environment. How can we model the semantics of these
				  highly dynamic features, yet still offer some
				  reasonable safety guarantees? To this end we present
				  an original calculus in which objects can adapt
				  their behaviour at run-time. Both objects and
				  environments are represented by first-class mappings
				  between variables and values. Message sends are
				  dynamically resolved to method calls. Variables may
				  be dynamically bound, making it possible to model a
				  variety of dynamic mechanisms within the same
				  calculus. Despite the highly dynamic nature of the
				  calculus, safety properties are assured by a type
				  assignment system.},
	Annote = {internationaljournal},
	Author = {Mariangiola Dezani-Ciancaglini and Paola Giannini and Oscar Nierstrasz},
	Bdsk-Url-1 = {http://www.info.uaic.ro/bin/Annals/XVIII http://scg.unibe.ch/archive/papers/Deza08bEvolvingObjects.pdf},
	Journal = {Scientific Annals of Computer Science},
	Keywords = {snf09 scg08 scg-pub skip-doi jb09 cop-lit},
	Medium = {2},
	Organization = {``A.I. Cuza'' University, Ia\c{s}i, Rom\^ania},
	Pages = {63-98},
	Peerreview = {yes},
	Publisher = {``A.I. Cuza'' University Press, Ia\c{s}i},
	Title = {A Calculus of Evolving Objects},
	url = {http://scg.unibe.ch/archive/papers/Deza08bEvolvingObjects.pdf},
	url2 = {http://www.info.uaic.ro/bin/Annals/XVIII},
	Volume = {XVIII},
	Year = {2008},
	Bdsk-Url-2 = {http://www.info.uaic.ro/bin/Annals/XVIII%20http://scg.unibe.ch/archive/papers/Deza08bEvolvingObjects.pdf}}

@article{Dout09a,
	Abstract = {In rapidly evolving domains such as Computer
				  Assisted Orthopaedic Surgery (CAOS) emphasis is
				  often put first on innovation and new functionality,
				  rather than in developing the common infrastructure
				  needed to support integration and reuse of these
				  innovations. In fact, developing such an
				  infrastructure is often considered to be a high-risk
				  venture given the volatility of such a domain. We
				  present CompAS, a method that exploits the very
				  evolution of innovations in the domain to carry out
				  the necessary quantitative and qualitative
				  commonality and variability analysis, especially in
				  the case of scarce system documentation. We show how
				  our technique applies to the CAOS domain by using
				  conference proceedings as a key source of
				  information about the evolution of features in CAOS
				  systems over a period of several years. We detect
				  and classify evolution patterns to determine
				  functional commonality and variability. We also
				  identify non-functional requirements to help capture
				  domain variability. We have validated our approach
				  by evaluating the degree to which representative
				  test systems can be covered by the common and
				  variable features produced by our analysis.},
	Annote = {internationaljournal},
	Author = {Gis\`ele Douta and Haydar Talib and Oscar Nierstrasz and Frank Langlotz},
	Doi = {10.1016/j.infsof.2008.05.017},
	Issn = {0950-5849},
	Journal = {Information and Software Technology},
	Keywords = {scg09 scg-pub jb09 snf09},
	Medium = {2},
	Number = {2},
	Pages = {448-459},
	Peerreview = {yes},
	Title = {{CompAS}: A new approach to commonality and variability analysis with applications in computer assisted orthopaedic surgery},
	Url = {http://scg.unibe.ch/archive/papers/Dout09aCompAS.pdf},
	Volume = {51},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Dout09aCompAS.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.infsof.2008.05.017}}

@inproceedings{Dozs08a,
	Abstract = {Many reverse engineering approaches have been
				  developed to analyze software systems written in
				  different languages like C/C++ or Java. These
				  approaches typically rely on a meta-model, that is
				  either specific for the language at hand or language
				  independent (e.g. UML). However, one language that
				  was hardly addressed is Lisp. While at first sight
				  it can be accommodated by current language
				  independent meta-models, Lisp has some unique
				  features (e.g. macros, CLOS entities) that are
				  crucial for reverse engineering Lisp systems. In
				  this paper we propose a suite of new visualizations
				  that reveal the special traits of the Lisp language
				  and thus help in understanding complex Lisp systems.
				  To validate our approach we apply them on several
				  large Lisp case studies, and summarize our
				  experience in terms of a series of recurring visual
				  patterns that we have detected.},
	Annote = {internationalconference},
	Author = {Adrian Dozsa and Tudor G\^irba and Radu Marinescu},
	Booktitle = {European Conference on Software Maintenance and Re-Engineering (CSMR 2008)},
	Doi = {10.1109/CSMR.2008.4493317},
	Keywords = {girba moose-pub scg08 scg-pub visualization metrics lisp jb08 hasler08},
	Medium = {2},
	Pages = {223--232},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society Press},
	Title = {How {Lisp} systems look different},
	Url = {http://scg.unibe.ch/archive/papers/Dozs08aLispLooksDifferent.pdf},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Dozs08aLispLooksDifferent.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/CSMR.2008.4493317}}

@inproceedings{Duca96b,
	Abstract = {The FLO language integrates management of
				  inter-object dependencies into the object oriented
				  paradigms. In this paper, we focus on the use of
				  reactive dependencies (links) in object-oriented
				  knowledge representation. In particular, we present
				  different meta-links (links between links) and show
				  how the FLO links allow one to design some
				  composition relationships.},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Mireille Blay-Fornarino and Anne-Marie Pinna},
	Booktitle = {Proceedings of International Symposium on Methodologies for Intelligent Systems (ISMIS '96)},
	Doi = {10.1007/3-540-61286-6_154},
	Keywords = {flo scg-old scg-pub stefPub},
	Month = jun,
	Number = 1079,
	Pages = {295--304},
	Publisher = {Springer-Verlag},
	Series = {LNIA (Lectures Notes in Artificial Intelligence)},
	Title = {Object and Dependency Oriented Programming in FLO},
	Url = {http://scg.unibe.ch/archive/papers/Duca96bDependencyOP.pdf},
	Year = {1996},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca96bDependencyOP.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/3-540-61286-6_154}}

@inproceedings{Duca97b,
	Abstract = {The decomposition of a software application into
				  components and connectors at the design stage has
				  been promoted as a way to describe and reason about
				  complex software architectures. There is, however,
				  surprisingly little language support for this
				  decomposition at implementation level. Interaction
				  relationships which are identified at design time
				  are lost as they get spread out into the
				  participating entities at implementation. In this
				  paper, we propose first-class connectors in an
				  object-oriented language as a first step towards
				  making software architecture more explicit at
				  implementation level. Our connectors are run-time
				  entities which control the interaction of components
				  and can express a rich repertoire of interaction
				  relationships. We show how connectors can be reused
				  and how they enhance the reuse of components.},
	Acceptnum = {19},
	Accepttotal = {197},
	Annote = {internationalconference topconference},
	Author = {St\'ephane Ducasse and Tamar Richner},
	Booktitle = {Proceedings of European Software Engineering Conference and Foundations on Software Engineering (ESEC/FSE'97)},
	Doi = {10.1007/3-540-63531-9_32},
	Isbn = {978-3-540-63531-4},
	Keywords = {olit famoos-papref scglit oobib scg-pub flo snf97 scg-none jb97 scg-coord-98 stefPub},
	Misc = {acceptance rate: 19/197 = 9\%},
	Pages = {483--500},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Executable Connectors: Towards Reusable Design Elements},
	Url = {http://scg.unibe.ch/archive/papers/Duca97bExecutableConnectors.pdf},
	Volume = {1301},
	Year = {1997},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca97bExecutableConnectors.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/3-540-63531-9_32}}

@inproceedings{Duca97c,
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse},
	Booktitle = {Object-Oriented Technology (ECOOP '97 Workshop Reader)},
	Editor = {Jan Bosch and Stuart Mitchell},
	Keywords = {olit famoos-papunr scglit oobib flo scg-pub skip-doi skip-pdf skip-abstract toBeChecked snf97 scg-none jb97 stefPub},
	Month = jun,
	Pages = {96--99},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Message Passing Abstractions as Elementary Bricks for Design Pattern Implementation},
	Volume = 1357,
	Year = {1997}}

@inproceedings{Duca97d,
	Annote = {nationalconference},
	Author = {St\'ephane Ducasse},
	Booktitle = {Actes de Langages et Mod\`eles \`a Objets (LMO'97)},
	Keywords = {olit famoos-papref scglit oobib scg-pub skip-doi skip-abstract snf97 scg-none jb97 stefPub flo},
	Pages = {95--110},
	Title = {R\'eification de Sch\'emas de Conception: Une Exp\'erience},
	Url = {http://scg.unibe.ch/archive/papers/Duca97dReificationDP.ps.gz},
	Year = {1997},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca97dReificationDP.ps.gz}}

@article{Duca97e,
	Annote = {nationaljournal},
	Author = {St\'ephane Ducasse},
	Journal = {Revue des Sciences et Technologies de l'Information (RSTI) --- L'Objet},
	Keywords = {olit famoos-papref scglit oobib scg-pub skip-abstract skip-doi scg-none jb-none snf97 stefPub flo},
	Number = {4},
	Pages = {355--377},
	Publisher = {Hermes, Paris},
	Title = {Des techniques de contr\^ole de l'envoi de messages en {Smalltalk}},
	Url = {http://scg.unibe.ch/archive/papers/Duca97eMessagePassing.pdf},
	Volume = {3},
	Year = {1997},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca97eMessagePassing.pdf}}

@techreport{Duca97g,
	Annote = {report notrefereed},
	Author = {St\'ephane Ducasse},
	Institution = {University of Bern, Institut of Applied Mathematics and Computer Sciences},
	Keywords = {scg-pub skip-doi skip-pdf skip-abstract scg-none jb-none flo},
	Note = {Extension version of Duca97e: Des techniques de contr\^ole de l'envoi de messages en Smalltalk},
	Number = {97-004},
	Title = {Des techniques de contr\^ole de l'envoi de messages en {Smalltalk}},
	Year = {1997}}

@inproceedings{Duca98b,
	Abstract = {A reengineering pattern describes how to go from an
				  existing legacy solution to a new refactored
				  solution. In this paper we discuss the role of
				  reengineering patterns and contrast them with design
				  patterns and antipatterns. We then highlight the
				  structure of a reengineering pattern and present two
				  simple, related patterns for type-check
				  elimination.},
	Address = {Konstanz, Germany},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Robb Nebbe and Tamar Richner},
	Booktitle = {Proceedings of the 4th European Conference on Pattern Languages of Programming and Computing, 1999},
	Editor = {Paul Dyson},
	Keywords = {scg-pub skip-doi olit famoos-papunr oobib snf98 pattern scg-none jb98 stefPub},
	Month = jul,
	Publisher = {UVK Universit\"atsverlag Konstanz GmbH},
	Title = {Two Reengineering Patterns: Eliminating Type Checking},
	Url = {http://scg.unibe.ch/archive/papers/Duca98bTwoReengPatterns.pdf},
	Year = {1998},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca98bTwoReengPatterns.pdf}}

@inproceedings{Duca98c,
	Abstract = {Although coordination of multiple activities is a
				  fundamental goal of object-oriented concurrent
				  programming languages, there is only limited support
				  for their specification and abstraction at the
				  language level. This leads to a mismatch between
				  conceptional designs, using high-level abstractions,
				  and the implementation, using the low-level
				  coordination constructs. Often coordination is
				  hard-wired into the components they coordinate,
				  which leads to evolution, maintenance and
				  composibility problems. We propose a model called
				  FLO/C that relies on the notion of connectors. A
				  connector is an entity that enforces the
				  coordination of the entities it coordinates. This
				  model supports a clear separation between the
				  coordinated active objects and their coordination.
				  An active object only defines specific domain
				  information and a connector only defines
				  coordination between a group of active objects (its
				  participants). The coordination is abstractly
				  defined refering to components in terms of the
				  object interface. Coordination and coordinated
				  entities are independant and can evolve separately.
				  Coordination can be composed and replaced easily.},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Manuel G{\"u}nter},
	Booktitle = {Proceedings of the DEXA workshops},
	Keywords = {scg-pub skip-doi flo floc olit coordination oobib snf98 scg-coord-98 scg-none jb98 stefPub},
	Month = aug,
	Pages = {572--577},
	Publisher = {IEEE Computer Society Press},
	Title = {Coordination of Active Objects by Means of Explicit Connectors},
	Url = {http://scg.unibe.ch/archive/papers/Duca98cExplicitConnectors.pdf},
	Year = {1998},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca98cExplicitConnectors.pdf}}

@proceedings{Duca98d,
	Address = {Forschungszentrum Informatik, Haid-und-Neu-Strasse 10-14, 76131 Karlsruhe, Germany},
	Annote = {workshopproceedings},
	Editor = {St\'ephane Ducasse and Joachim Weisbrod},
	Keywords = {skip-pdf scg-pub skip-abstract skip-doi olit famoos-wrkproc oobib snf98 scg-none jb98 stefPub},
	Month = jun,
	Note = {FZI 6/7/98},
	Title = {Proceedings of the {ECOOP}'98 Workshop on Experiences in Object-Oriented Re-Engineering},
	url = {https://link.springer.com/content/pdf/10.1007%2F3-540-49255-0_16.pdf},
	Year = {1998}}

@misc{Duca98z,
	Annote = {workshopproceedings},
	Author = {St\'ephane Ducasse and Joachim Weisbrod},
	Booktitle = {Object-Oriented Technology (ECOOP'98 Workshop Reader)},
	Keywords = {scg-pub skip-abstract skip-doi scg-none jb-none stefPub},
	Number = 1543,
	Pages = {72--96},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Report of the {ECOOP}'98 Workshop on Experiences in Object-Oriented Re-Engineering},
	url = {https://link.springer.com/chapter/10.1007/3-540-49255-0_16},
	Year = {1998}}

@article{Duca99a,
	Abstract = {In a language like Smalltalk in which objects
				  communicate only via message passing, message
				  passing control is a fundamental tool for the
				  analysis of object behavior (trace, spying) or for
				  the definition of new semantics (asynchronous
				  messages, proxy,...). Different techniques exist,
				  from the well known approach based on the
				  specialization of the doesNotUnderstand: method to
				  the exploitation the method lookup algorithm done by
				  the virtual machine. Until now no comparison between
				  these techniques has been made. In this article we
				  compare the different techniques taking into account
				  the reflective aspects used, the scope, the limit
				  and the cost of the control.},
	Annote = {internationaljournal},
	Author = {St\'ephane Ducasse},
	Journal = {Journal of Object-Oriented Programming (JOOP)},
	Keywords = {olit famoos-papref snf98 oobib scg-pub skip-doi scg-none jb99 stefPub flo},
	Misc = {SCI impact factor 0.306},
	Month = jun,
	Number = {6},
	Pages = {39--44},
	Publisher = {SIGS Press},
	Title = {Evaluating Message Passing Control Techniques in {Smalltalk}},
	Url = {http://scg.unibe.ch/archive/papers/Duca99aMsgPassingControl.pdf},
	Volume = {12},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca99aMsgPassingControl.pdf}}

@inproceedings{Duca99b,
	Abstract = {Code duplication is one of the factors that severely
				  complicates the maintenance and evolution of large
				  software systems. Good tools for detecting
				  duplicated code are scarce because of the large
				  amount of data to be checked, because duplicated
				  code is not known a priori and because especially it
				  requires parsing technology. In this paper we show
				  that is possible to circumvent these complicating
				  factors by applying a language independent and
				  lightweigth approach, i.e. a tool that requires no
				  parsing and a little learning and configuration
				  time, yet is able to detect a significant amount of
				  code duplication. We validate our approach on a
				  number of case studies, involving five different
				  implementation languages and ranging from 256 K up
				  untill 26Mb of source code.},
	Acceptnum = {49},
	Accepttotal = {100},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Matthias Rieger and Serge Demeyer},
	Booktitle = {Proceedings of 15th IEEE International Conference on Software Maintenance (ICSM'99)},
	Doi = {10.1109/ICSM.1999.792593},
	Editor = {Hongji Yang and Lee White},
	Keywords = {olit famoos-papref scg-pub toBeChecked sergedem-papref duploc snf99 scg-none jb99 oorp stefPub moose-pub},
	Misc = {acceptance rate: 49/100 = 49\%},
	Month = sep,
	Pages = {109--118},
	Publisher = {IEEE Computer Society},
	Title = {A Language Independent Approach for Detecting Duplicated Code},
	Url = {http://scg.unibe.ch/archive/papers/Duca99bCodeDuplication.pdf},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca99bCodeDuplication.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICSM.1999.792593}}

@inproceedings{Duca99c,
	Abstract = {In reengineering an object-oriented system we want
				  to benefit from the expertise developed in earlier
				  efforts. It is therefore essential to have a way to
				  communicate expertise at different levels: from
				  knowledge about how to approach a system to be
				  reengineered, to knowledge about improving code by
				  eliminating 'bad' style. In this paper we propose to
				  use a pattern form to communicate knowledge about
				  reengineering. A reengineering pattern connects an
				  observable problem in the code to a reengineering
				  goal: it describes the process of going from the
				  existing legacy solution causing or aggravating the
				  problem to a new refactored solution which meets the
				  reengineering goal. It thus gives a method
				  appropriate for a specific problem, rather than
				  proposing a general methodology, and makes reference
				  to the appropriate tools or techniques for obtaining
				  the refactored solution. In this paper we discuss
				  the role of reengineering patterns and contrast them
				  with related kinds of patterns. We then highlight
				  the form of reengineering patterns and present two
				  simple patterns for type-check elimination.},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Tamar Richner and Robb Nebbe},
	Booktitle = {Proceedings of 6th Working Conference on Reverse Engineering (WCRE'99)},
	Doi = {10.1109/WCRE.1999.806956},
	Editor = {Francoise Balmas and Mike Blaha and Spencer Rugaber},
	Keywords = {olit famoos-papref scg-pub scg-none jb99 stefPub},
	Month = oct,
	Pages = {157--168},
	Publisher = {IEEE Computer Society},
	Title = {Type-Check Elimination: Two Object-Oriented Reengineering Patterns},
	Url = {http://scg.unibe.ch/archive/papers/Duca99cTypeCheckElim.pdf},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca99cTypeCheckElim.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.1999.806956}}

@inproceedings{Duca99d,
	Abstract = {Code duplication is an important problem in
				  application maintenance. Tools exist that support
				  code duplication detection. However, few of them
				  propose a solution for the problem, i.e.
				  refactorings. We propose an approach that uses the
				  information given by code duplication detection to
				  guide the refactorings of OO applications.},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Matthias Rieger and Georges Golomingi},
	Booktitle = {Proceedings of the ECOOP '99 Workshop on Experiences in Object-Oriented Re-Engineering},
	Editor = {St\'ephane Ducasse and Oliver Ciupke},
	Keywords = {olit famoos-papref scg-pub skip-doi scg-none jb99 stefPub},
	Month = jun,
	Note = {FZI-Report 2-6-6/99},
	Publisher = {Forschungszentrum Informatik, Karlsruhe},
	Title = {Tool Support for Refactoring Duplicated {OO} Code},
	Url = {http://scg.unibe.ch/archive/papers/Rieg99aToolSuppRefacOOCode.pdf},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Rieg99aToolSuppRefacOOCode.pdf}}

@proceedings{Duca99e,
	Annote = {workshopproceedings},
	Editor = {St\'ephane Ducasse and Oliver Ciupke},
	Keywords = {skip-pdf scg-pub skip-abstract skip-doi olit famoos-wrkproc oobib snf99 scg-none jb99 stefPub},
	Month = jun,
	Note = {FZI 2-6-6/99},
	Publisher = {Forschungszentrum Informatik, Karlsruhe, Germany},
	Title = {Proceedings of the {ECOOP}'99 Workshop on Experiences in Object-Oriented Re-Engineering},
	Year = {1999}}

@inproceedings{Duca99s,
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Michele Lanza and Serge Demeyer},
	Booktitle = {Object-Oriented Technology (ECOOP'99 Workshop Reader)},
	Keywords = {scg-pub snf-none skip-pdf scg-none jb-none skip-abstract skip-doi},
	Number = {1743},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Reverse Engineering based on Metrics and Program Visualization},
	Year = {1999}}

@book{Duca99x,
	Annote = {notrefereed handbook},
	Editor = {St\'ephane Ducasse and Serge Demeyer},
	Keywords = {olit scg-pub skip-abstract skip-doi scg-none jb-none famoos stePub},
	Month = oct,
	Publisher = {University of Bern},
	Title = {The {FAMOOS} Object-Oriented Reengineering Handbook},
	Url = {http://scg.unibe.ch/archive/papers/Duca99xFamoosHandBook.pdf},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca99xFamoosHandBook.pdf}}

@inproceedings{Duca00a,
	Abstract = {Reengineering is an inherent aspect of modern
				  software development, with its emphasis on iterative
				  and incremental development. The reengineering
				  pattern presented in this paper shows how you can
				  support your understanding during system
				  reengineering by linking your questions or
				  information about the code in the code itself.},
	Annote = {internationalworkshop},
	Author = {St{\'e}phane Ducasse and Serge Demeyer and Oscar Nierstrasz},
	Booktitle = {Proceedings of EuroPLoP '2000},
	Keywords = {snf-none olit scg-pub skip-doi scg-none jb00 stefPub},
	Pages = {209--217},
	Title = {Tie Code And Questions: a Reengineering Pattern},
	Url = {http://scg.unibe.ch/archive/papers/Duca00aTieCode.pdf},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca00aTieCode.pdf}}

@inproceedings{Duca00b,
	Abstract = {Surprising as it may seem, many of the early
				  adopters of the object-oriented paradigm already
				  face a number of problems typically encountered in
				  large-scale legacy systems. The reengineering of
				  those systems often poses problems because of the
				  considerable size and complexity of such systems. In
				  the context of the FAMOOS project we have developed
				  a language independent environment called Moose
				  which can deal with that complexity. This paper
				  describes the architecture of Moose, the tools which
				  have been developed around it and the industrial
				  experiences we have obtained.},
	Annote = {internationalworkshop},
	Author = {Ducasse, St\'ephane and Lanza, Michele and Tichelaar, Sander},
	Booktitle = {Proceedings of CoSET '00 (2nd International Symposium on Constructing Software Engineering Tools)},
	Keywords = {components scg-pub skip-doi snf00 scg-none jb00 repository abb oorp stefPub moose-pub},
	Month = jun,
	Title = {Moose: an extensible language-independent environment for reengineering object-oriented systems},
	Url = {http://scg.unibe.ch/archive/papers/Duca00bMooseCoset.pdf},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca00bMooseCoset.pdf}}

@inproceedings{Duca00c,
	Abstract = {Conditionals -i.e., switch statements, nested ifs-
				  that are used to simulate polymorphism hamper
				  evolution and flexibility of applications. The
				  reengineering patterns presented in this paper show
				  you how to transform conditionals in object-oriented
				  code to improve the flexibility of application.},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Serge Demeyer and Oscar Nierstrasz},
	Booktitle = {Proceedings of EuroPLoP '2000},
	Keywords = {snf-none skip-doi olit scg-pub scg-none jb00 stefPub},
	Pages = {219--252},
	Title = {Transform Conditionals to Polymorphism},
	Url = {http://scg.unibe.ch/archive/papers/Duca00cTransform.pdf},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca00cTransform.pdf}}

@inproceedings{Duca00d,
	Abstract = {Tuple spaces have turned out to be one of the most
				  fundamental abstractions for coordinating
				  communicating agents. At the same time, researchers
				  continue to propose new variants of tuple spaces,
				  since no one approach seems to be universally
				  applicable to all problem domains. Some models offer
				  a certain configurability, but existing approaches
				  generally stop at afixed set of configuration
				  options and static configuration at instantiation
				  time. We argue that a more open approach is needed,
				  and present OpenSpaces, an object-oriented framework
				  that supports static configurability through
				  subclassing across several dimensions, as well as
				  dynamic configurability of policies through runtime
				  composition. We introduce OpenSpaces by showing how
				  it can be used to instantiate a typical application,
				  and we present an overview of the framework,
				  implemented in Smalltalk, detailing the various
				  degrees of configurability.},
	Acceptnum = {18},
	Accepttotal = {52},
	Address = {Limassol, Cyprus},
	Annote = {internationalconference},
	Author = {St{\'e}phane Ducasse and Thomas Hofmann and Oscar Nierstrasz},
	Booktitle = {Coordination Languages and Models},
	Doi = {10.1007/3-540-45263-X_1},
	Editor = {Ant{\'o}nio Porto and Gruia-Catalin Roman},
	Isbn = {978-3-540-41020-1},
	Keywords = {olit scg-pub coordination scg-none jb00 scg-coord-00 stefPub},
	Misc = {acceptance rate: 18/52 = 35\%},
	Month = sep,
	Pages = {1--19},
	Series = {LNCS},
	Title = {OpenSpaces: An Object-Oriented Framework For Reconfigurable Coordination Spaces},
	Url = {http://scg.unibe.ch/archive/papers/Duca00dOpenSpaces.pdf},
	Volume = {1906},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca00dOpenSpaces.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/3-540-45263-X_1}}

@inproceedings{Duca00f,
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Michele Lanza and Lukas Steiger},
	Booktitle = {ECOOP 2000 International Workshop of Architecture Evolution},
	Keywords = {scg-pub skip-abstract skip-pdf skip-doi snf00 scg-none jb00 stefPub design-recovery moose-pub},
	Title = {Supporting Evolution Recovery: a Query-based Approach},
	Year = {2000}}

@article{Duca00x,
	Address = {13 rue du Jura, Paris 13},
	Annote = {notrefereed},
	Author = {St\'ephane Ducasse and Florence Ducasse},
	Journal = {Journal de l'association EPI Enseignement Public et Informatiques},
	Keywords = {snf-none scg-pub skip-abstract skip-doi scg-none jb00 stefPub},
	Month = sep,
	Number = 97,
	Title = {De l'enseignement de concepts informatiques},
	Url = {http://scg.unibe.ch/archive/papers/Duca00xExperienceEnseig.pdf},
	Volume = 4,
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca00xExperienceEnseig.pdf}}

@article{Duca01a,
	Abstract = {The reverse engineering of object-oriented legacy
				  systems presents a number of problems typically
				  encountered in large-scale legacy systems: the lack
				  of overview and the need to focus on interesting
				  parts. To help in reverse engineering large
				  object-oriented legacy systems, we proposed a hybrid
				  approach combining the immediate appeal of
				  visualisations with the scalability of metrics.
				  However, our approach lacked of a methodology that
				  guides the reverse engineer. In this paper we
				  present a first methodology that we developed from
				  our industrial experiments.},
	Annote = {nationaljournal},
	Author = {St\'ephane Ducasse and Michele Lanza},
	Journal = {Technique et science informatiques},
	Keywords = {scg-pub skip-doi scg-none jb01 snf02 stePub},
	Number = {4},
	Pages = {539--566},
	Title = {Towards a Methodology for the Understanding of Object-Oriented Systems},
	Url = {http://scg.unibe.ch/archive/papers/Duca01aTowardsAMethod.pdf},
	Volume = {20},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca01aTowardsAMethod.pdf}}

@article{Duca01b,
	Abstract = {This article presents the Moose Reengineering
				  Environment, a language-independent tool environment
				  to reverse engineer, i.e., understand, and
				  reengineer software systems, as well as the tools
				  which have been developed around it and the
				  experience, both academic and industrial, we have
				  obtained.},
	Annote = {notrefereed},
	Author = {St\'ephane Ducasse and Michele Lanza and Sander Tichelaar},
	Journal = {Smalltalk Chronicles},
	Keywords = {scg-pub skip-doi repository reengineering snf01 scg-none jb01 stefPub moose-pub},
	Month = aug,
	Title = {The {Moose} Reengineering Environment},
	Url = {http://scg.unibe.ch/archive/papers/Duca01bMoose.pdf http://www.smalltalkchronicles.net/edition3-2/Pages/moose.htm},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca01bMoose.pdf%20http://www.smalltalkchronicles.net/edition3-2/Pages/moose.htm}}

@techreport{Duca01c,
	Abstract = {Reengineering ob ject-oriented applications is
				  becoming a vital activity in today industry where
				  the developer turnover drains the system oral memory
				  out of the systems themselves and where applications
				  should constantly evolve to meet new requirements.
				  This document summarizes the research effort led on
				  reverse engineering and reengineering ob
				  ject-oriented legacy systems. It includes (1) the
				  definition of a suitable meta-model for
				  reengineering, FAMIX. This meta-model, even if flat,
				  supports both reverse engineering and code refac-
				  toring analysis, (2) the presentation of a
				  reengineering platform, MOOSE, (3) the evalution of
				  software metrics for reengineer, (4) the definition
				  of simple visual techniques to support large system
				  understanding or finer grain code element, (5) the
				  identification and cure sup- port for duplicated
				  code, (6) the use of dynamic information to support
				  composable views and collaboration extraction, and
				  (7) the identification of reengineer patterns.
				  Keywords. Meta-Modeling, Language Independence,
				  Reengineering, Reverse Engineering, Code Duplica-
				  tion, Reengineering Patterns, Program Traces,
				  Dynamic Information, Program Visualization, Software
				  Metrics, Refactorings, Interexchange Format,
				  CODECRAWLER, FAMIX, MOOSE, FAMOOS, Smalltalk, Java,
				  C++.},
	Annote = {habilitation},
	Author = {Ducasse, St\'ephane},
	Institution = {Universit\'e Pierre et Marie Curie (Paris 6)},
	Keywords = {scg-pub skip-doi scg-none jb-none reengineering snf02 stefPub moose-pub},
	Month = sep,
	Note = {TR University of Bern, Institute of Computer Science and Applied Mathematics --- iam-03-008},
	Title = {Reengineering Object-Oriented Applications},
	Url = {http://scg.unibe.ch/archive/papers/Duca01cHab.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca01cHab.pdf}}

@inproceedings{Duca02a,
	Abstract = {In this paper we stress the fact that a language and
				  an environment for teaching object-oriented
				  programming should support the anthropomorphic
				  metaphor promoted by the paradigm. We show that all
				  the cultural aspects of Smalltalk, i.e., the
				  vocabulary and the syntax support the object
				  metaphor. In addition, we stress that the
				  programming environment should also support the
				  metaphor. We show that Smalltalk environments offer
				  an important property we named liveness or object
				  proximity that promotes the anthropomorphic
				  perception of objects. By providing excerpt from our
				  forth coming book, we show how Squeak with the
				  Morphic framework reinforces this ability to make
				  object into living entities.},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Roel Wuyts},
	Booktitle = {Proceedings of the Ecoop'02 International Educator Symposium},
	Keywords = {snf-none stefPub scg-pub skip-doi scg-none jb04},
	Title = {Supporting Objects as An Anthropomorphic View at Computation or Why {Smalltalk} for Teaching Objects?},
	Url = {http://scg.unibe.ch/archive/papers/Duca02aTeacherWorkshop.pdf},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca02aTeacherWorkshop.pdf}}

@article{Duca03a,
	Abstract = {Although component-based software development (CBSD)
				  has become mainstream for conventional applications,
				  it has remained elusive for embedded applications
				  due to non-functional constraints. The PECOS project
				  has demonstrated that CBSD can also be applied to
				  severely constrained embedded devices, with timing
				  and memory requirements being taken into account.},
	Annote = {notrefereed},
	Author = {St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
	Cvs = {ErcimPecos},
	Journal = {ERCIM News},
	Keywords = {scg-pub skip-doi pecos scg-none jb03 stefPub},
	Month = jan,
	Title = {Composing Embedded Real-Time Software Components: the {PECOS} Data-Centric Approach},
	Url = {http://www.ercim.org/publication/Ercim_News/enw52/nierstrasz.html},
	Volume = 52,
	Year = {2003},
	Bdsk-Url-1 = {http://www.ercim.org/publication/Ercim_News/enw52/nierstrasz.html}}

@inproceedings{Duca03b,
	Abstract = {Current languages contain visibility mechanisms such
				  as private, protected, or public to control who can
				  see what. However, these visibility mechanisms are
				  fixed once for all. Moreover, they do not solve all
				  problems related to the visibility, and are
				  typically of a static nature. In this position paper
				  we present an open and uniform way of dealing with
				  visibility and introduce surfaces: i.e., list of
				  methods that control the way the behavior of an ob
				  ject is accessible. We introduce two problems that
				  other visibility mechanisms cannot solve, and show
				  how surfaces can.},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Nathanael Sch{\"a}rli and Roel Wuyts},
	Booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
	Keywords = {snf03 scg-pub skip-doi scg-none jb03 stefPub schaerli},
	Month = jul,
	Title = {Open Surfaces for Controlled Visibility},
	Url = {http://scg.unibe.ch/archive/papers/Duca03bSurfaces.pdf},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca03bSurfaces.pdf}}

@inproceedings{Duca03c,
	Abstract = {Array programming shines in its ability to express
				  computations at a high-level of abstraction,
				  allowing one to manipulate and query whole sets of
				  data at once. This paper presents the OOPAL model
				  that enhances object-oriented programming with array
				  programming features. The goal of OOPAL is to
				  determine a minimum set of modifications that must
				  be made to the traditional object model in order to
				  take advantage of the possibilities of array
				  programming. It is based on a minimal extension of
				  method invocation and the definition of a kernel of
				  methods implementing the fundamental array
				  programming operations. The model is validated in
				  F-SCRIPT, a new scripting language.},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Philippe Mougin},
	Booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
	Keywords = {snf03 scg-pub skip-doi scg-none jb03 stefPub},
	Month = jul,
	Title = {Power to Collections: Generalizing Polymorphism by Unifying Array Programming and Object-Oriented Programming},
	Url = {http://scg.unibe.ch/archive/papers/Duca03cOOPALEcoop.pdf},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca03cOOPALEcoop.pdf}}

@article{Duca03d,
	Abstract = {Over the last decade many research groups and
				  commercial companies have been developing
				  reengineering environments. However, many design
				  decisions such as support for multiple models,
				  incremental loading of information, tool
				  integration, entity grouping, and their impacts on
				  the underlying meta-model and resulting environment
				  have remained implicit. Based on the experience
				  accumulated while developing the Moose reengineering
				  environment and on a survey of reengineering
				  environments, we present a design space defined by a
				  set of criteria that makes explicit the different
				  options and especially their dependencies and
				  trade-offs. Using this design space, developers of
				  future environments should have a better
				  understanding of the problems they face and the
				  impact of design choices.},
	Annote = {internationaljournal},
	Author = {St\'ephane Ducasse and Sander Tichelaar},
	Doi = {10.1002/smr.279},
	Journal = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
	Keywords = {scg-pub recast04 scg-none jb04 stefPub moose-pub},
	Misc = {SCI impact factor 0.595},
	Month = oct,
	Number = 5,
	Pages = {345--373},
	Title = {Dimensions of Reengineering Environment Infrastructures},
	Url = {http://scg.unibe.ch/archive/papers/Duca03dInfrastructures.pdf},
	Volume = 15,
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca03dInfrastructures.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1002/smr.279}}

@inproceedings{Duca04a,
	Abstract = {Understanding the run-time behavior of
				  object-oriented legacy systems is a complex task due
				  to factors such as late binding and polymorphism.
				  Current approaches extract and use information from
				  the complete execution trace of a system. The sheer
				  size and complexity of such traces make their
				  handling, storage, and analysis difficult. Current
				  software systems which run almost non-stop do not
				  permit such a full analysis. In this paper we
				  present a lightweight approach based on the
				  extraction of a condensed amount of information,
				  e.g., measurements, that does not require a full
				  trace. Using this condensed information, we propose
				  a visualization approach which allows us to identify
				  and understand certain aspects of the objects'
				  lifetime such as their role played in the creation
				  of other objects and the communication architecture
				  they support.},
	Acceptnum = {33},
	Accepttotal = {62},
	Address = {Los Alamitos CA},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Michele Lanza and Roland Bertuli},
	Booktitle = {Proceedings of 8th European Conference on Software Maintenance and Reengineering (CSMR'04)},
	Doi = {10.1109/CSMR.2004.1281433},
	Keywords = {recast04 scg-pub stefPub scg-none jb04 moose-pub},
	Misc = {acceptance rate: 33/62 = 52\%},
	Pages = {309--318},
	Publisher = {IEEE Computer Society Press},
	Title = {High-Level Polymetric Views of Condensed Run-Time Information},
	Url = {http://scg.unibe.ch/archive/papers/Duca04aRuntimePolymetricViews.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca04aRuntimePolymetricViews.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/CSMR.2004.1281433}}

@inproceedings{Duca04b,
	Abstract = {Due to the size and the extreme complexity of legacy
				  systems, it is nearly impossible to write from
				  scratch tests before refactoring them. In addition
				  object-oriented legacy systems present specific
				  requirements to test them. Indeed late-binding allow
				  subclasses to change fundamental aspects of the
				  superclass code and in particular call flows.
				  Moreover Object-oriented programming promotes a
				  distribution of the responsibilities to multiple
				  entities leading to complex scenario to be tested.
				  In such a context one of the few trustable source of
				  information is the execution of the application
				  itself. Traditional forward engineering approaches
				  such as unit testing do not really provide adequate
				  solution to this problem. Therefore there is a need
				  for a more expressive way of testing the execution
				  of object-oriented applications. We propose to
				  represent the trace of object-oriented applications
				  as logic facts and express tests over the trace.
				  This way complex sequences of message exchanges,
				  sequence matching, or expression of negative
				  information are expressed in compact form. We
				  validated our approach by implementing TestLog a
				  prototype tool and testing the Moose reengineering
				  environment and a meta-interpreter.},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Michael Freidig and Roel Wuyts},
	Booktitle = {Fifth International Workshop on Object-Oriented Reengineering (WOOR 2004)},
	Keywords = {scg-pub skip-doi recast04 scg-none jb04 evolution visualization test stefPub},
	Title = {Logic and Trace-based Object-Oriented Application Testing},
	Url = {http://scg.unibe.ch/archive/papers/Duca04bTestLogicWoor04.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca04bTestLogicWoor04.pdf}}

@techreport{Duca04d,
	Abstract = {Understanding packages is an important activity in
				  the reengineering of large object-oriented systems.
				  The relationships between packages and their
				  contained classes can affect the cost of modifying
				  the system. The main problem of this task is to
				  quickly grasp the structure of a package and how it
				  interacts with the rest of the system. In this paper
				  we present a top-down program comprehension strategy
				  based on polymetric views, radar charts, and
				  software metrics. We illustrate this approach on two
				  applications and show how we can retrieve the
				  important characteristics of packages.},
	Annote = {report notrefereed},
	Author = {St\'ephane Ducasse and Michele Lanza and Laura Ponisio},
	Institution = {University of Bern, Institut of Applied Mathematics and Computer Sciences},
	Keywords = {scg-none jb05 scg-pub skip-doi stefPub snf04 recast05 moose-pub},
	Number = {IAM-04-007},
	Title = {A Top-Down Program Comprehension Strategy for Packages},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Duca04dPackageVisualization.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca04dPackageVisualization.pdf}}

@inproceedings{Duca04e,
	Abstract = {Developing web applications is difficult since (1)
				  the client-server relationship is asymmetric: the
				  server cannot update clients but only responds to
				  client requests and (2) the navigation facilities of
				  web browsers lead to a situation where servers
				  cannot control the state of the clients.
				  Page-centric web application frameworks fail to
				  offer adequate solutions to model control flow at a
				  high-level of abstraction. Developers have to work
				  manually around the shortcomings of the HTTP
				  protocol. Some approaches offer better abstractions
				  by composing an application out of components,
				  however they still fail to offer modeling control
				  flow at a high level. Continuation-based approaches
				  solve this problem by providing the facilities to
				  model a control flow over several pages with one
				  piece of code. However combining multiple flows
				  inside the same page is difficult. This article
				  presents Seaside. Seaside is a framework which
				  combines an object-oriented approach with a
				  continuation-based one. A Seaside application is
				  built out of components (i.e., objects) and the
				  logic of the application benefits from the
				  continuation-based program flow infrastructure.
				  Seaside offers a unique way to have multiple control
				  flows on a page, one for each component. This
				  enables the developer to write components that are
				  highly reusable and that can be used to compose
				  complex web applications with higher quality in less
				  time.},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Adrian Lienhard and Lukas Renggli},
	Booktitle = {Proceedings of 12th International Smalltalk Conference (ISC'04)},
	Cvs = {seaside},
	Keywords = {scg-pub skip-doi scg-none jb05 snf05 stefPub seaside-article},
	Misc = {Also Technical Report IAM-04-008},
	Month = sep,
	Pages = {231--257},
	Title = {Seaside --- a Multiple Control Flow Web Application Framework},
	Url = {http://scg.unibe.ch/archive/papers/Duca04eSeaside.pdf http://www.iam.unibe.ch/publikationen/techreports/2004/iam-04-008},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca04eSeaside.pdf%20http://www.iam.unibe.ch/publikationen/techreports/2004/iam-04-008}}

@inproceedings{Duca04f,
	Abstract = {The histories of software systems hold useful
				  information when reasoning about the systems at hand
				  or about general laws of software evolution. Yet,
				  the approaches developed so far, do not rely on an
				  explicit meta-model and do not facilitate the
				  comparison of different evolutions. We argue for the
				  need to define history as a first class entity and
				  propose a meta-model centered around the notion of
				  history. We show the usefulness of our a meta-model
				  by discussing the different analysis it enables.},
	Address = {Amsterdam},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Tudor G\^irba and Jean-Marie Favre},
	Booktitle = {Proceedings Workshop on Software Evolution Through Transformation (SETra 2004)},
	Doi = {10.1016/j.entcs.2004.08.035},
	Keywords = {scg-pub evolution van stefPub recast05 jointERCIM girba hismo scg-none jb05 moose-pub},
	Pages = {75--86},
	Publisher = {Elsevier},
	Title = {Modeling Software Evolution by Treating History as a First Class Entity},
	Url = {http://scg.unibe.ch/archive/papers/Duca04fHismo.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca04fHismo.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.entcs.2004.08.035}}

@incollection{Duca05a,
	Abstract = {Software systems are complex and difficult to
				  analyze. Reverse engineering is a complex analysis
				  that usually involves combining different techniques
				  and tools. Moreover, oftentimes the existing tools
				  are not perfectly suitable for the task, and
				  customization of existing tools, or development of
				  new tools is required. Moose is an extensible
				  reengineering environment designed to provide the
				  necessary infrastructure for tool integration. Moose
				  centers on a language independent meta-model, and
				  offers services like grouping, querying, navigation,
				  and advanced tool integration mechanism.},
	Address = {Milano},
	Aeres = {OS},
	Aeresstatus = {aeres08},
	Annote = {articlebook},
	Author = {St\'ephane Ducasse and Tudor G\^irba and Michele Lanza and Serge Demeyer},
	Booktitle = {Tools for Software Maintenance and Reengineering},
	Inria = {hors},
	Isbn = {88-464-6396-X},
	Keywords = {moose-pub scg-pub skip-doi scg-none jb05 recast05 stefPub jointERCIM girba},
	Pages = {55--71},
	Publisher = {Franco Angeli},
	Series = {RCOST / Software Technology Series},
	Title = {Moose: a Collaborative and Extensible Reengineering Environment},
	Url = {http://scg.unibe.ch/archive/papers/Duca05aMooseBookChapter.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca05aMooseBookChapter.pdf}}

@article{Duca05b,
	Abstract = {Understanding source code is an important task in
				  the maintenance of software systems. Legacy systems
				  are not only limited to procedural languages, but
				  are also written in object-oriented languages. In
				  such a context, understanding classes is a key
				  activity as they are the cornerstone of the
				  object-oriented paradigm and the primary abstraction
				  from which applications are built. Such an
				  understanding is however difficult to obtain because
				  of reasons such as the presence of late binding and
				  inheritance. A first level of class understanding
				  consists of the understanding of its overall
				  structure, the control flow among its methods, and
				  the accesses on its attributes. We propose a novel
				  visualization of classes called class blueprint that
				  is based on a semantically enriched visualization of
				  the internal structure of classes. This
				  visualization allows a software engineer to build a
				  first mental model of a class that he validates via
				  opportunistic code-reading. Furthermore, we have
				  identified visual patterns that represent recurrent
				  situations and as such convey additional information
				  to the viewer. The contributions of this article are
				  the class blueprint, a novel visualization of the
				  internal structure of classes, the identification of
				  visual patterns, and the definition of a vocabulary
				  based on these visual patterns. We have performed
				  several case studies of which one is presented in
				  depth, and validated the usefulness of the approach
				  in a controlled experiment.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {St\'ephane Ducasse and Michele Lanza},
	Doi = {10.1109/TSE.2005.14},
	Impactfactor = {1.967, SCI 2006},
	Inria = {hors},
	Journal = {Transactions on Software Engineering (TSE)},
	Keywords = {hasler07 scg-none jb05 scg-pub stefPub recast05 mooseCincom moose-pub},
	Misc = {SCI impact factor 1.967},
	Month = jan,
	Number = {1},
	Pages = {75--90},
	Publisher = {IEEE Computer Society},
	Selectif = {oui},
	Title = {The {Class} {Blueprint}: Visually Supporting the Understanding of Classes},
	Url = {http://scg.unibe.ch/archive/papers/Duca05bTSEClassBlueprint.pdf},
	Volume = {31},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca05bTSEClassBlueprint.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/TSE.2005.14}}

@inproceedings{Duca05e,
	Abstract = {Understanding sets of classes, or packages, is an
				  important activity in the development and
				  reengineering of large object-oriented systems.
				  Packages represent the coarse-grained structure of
				  an application. They are artefacts to deploy and
				  structure software, and therefore more than a simple
				  generalization of classes. The relationships between
				  packages and their contained classes are key in the
				  decomposition of an application and its
				  (re)-modularisation. However, it is difficult to
				  quickly grasp the structure of a package and to
				  understand how a package interacts with the rest of
				  the system. We tackle this problem using butterfly
				  visualizations, i.e. dedicated radar charts built
				  from simple package metrics based on a
				  language-independent meta-model. We illustrate our
				  approach on two applications and show how we can
				  retrieve the relevant characteristics of packages.},
	Acceptnum = {39},
	Accepttotal = {89},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Michele Lanza and Laura Ponisio},
	Booktitle = {Proceedings of the 11th IEEE International Software Metrics Symposium (METRICS'05)},
	Cvs = {AlchemistPackageMETRICS05},
	Doi = {10.1109/METRICS.2005.15},
	Inria = {hors},
	Keywords = {scg-none jb06 scg-pub stefPub moose-pub recast06},
	Misc = {acceptance rate: 39/89 = 44\%},
	Pages = {70--77},
	Publisher = {IEEE Computer Society},
	Rate = {44%},
	Selectif = {non},
	Title = {Butterflies: A Visual Approach to Characterize Packages},
	Url = {http://scg.unibe.ch/archive/papers/Duca05ePackageVisualization.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca05ePackageVisualization.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/METRICS.2005.15}}

@inproceedings{Duca05f,
	Abstract = {Software systems are complex and difficult to
				  analyze. Reengineering is a complex activity that
				  usually involves combining different techniques and
				  tools. Moose is an reengineering environment
				  designed to provide the necessary infrastructure for
				  building new tools and for integrating them. Moose
				  centers on a language independent meta-model, and
				  offers services like grouping, querying, navigation,
				  and meta-descriptions. Several tools have been built
				  on top of Moose dealing with different aspects of
				  reengineering like: visualization, evolution
				  analysis, semantic analysis, concept analysis or
				  dynamic analysis.},
	Annote = {conference tooldemo},
	Author = {St\'ephane Ducasse and Tudor G\^irba and Oscar Nierstrasz},
	Booktitle = {Proceedings of ESEC/FSE 2005},
	Cvs = {MooseDemoESEC05},
	Doi = {10.1145/1081706.1081723},
	Keywords = {scg-pub moose-pub stefPub scg-none jb06 recast06 girba},
	Month = sep,
	Note = {Tool demo},
	Pages = {99--102},
	Title = {{Moose}: an Agile Reengineering Environment},
	Url = {http://scg.unibe.ch/archive/papers/Duca05fMooseDemo.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca05fMooseDemo.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1081706.1081723}}

@article{Duca05g,
	Abstract = {In pure object-oriented languages, classes are
				  objects, instances of other classes called
				  metaclasses. In the same way as classes define the
				  properties of their instances, metaclasses define
				  the properties of classes. It is therefore very
				  natural to wish to reuse class properties, utilizing
				  them amongst several classes. However this
				  introduced metaclass composition problems, i.e.,
				  code fragments applied to one class may break when
				  used on another class due to the inheritance
				  relationship between their respective metaclasses.
				  Numerous approaches have tried to solve metaclass
				  composition problems, but they always resort to an
				  ad-hoc manner of handling conflicting properties,
				  alienating the meta-programmer. We propose a uniform
				  approach that represents class properties as traits,
				  groups of methods that act as a unit of reuse from
				  which classes are composed. Like all the other
				  classes in the system, metaclasses are composed out
				  of traits. This solution supports the reuse of class
				  properties, and their safe and automatic composition
				  based on explicit conflict resolution. The paper
				  discusses traits and our solution, shows concrete
				  examples implemented in the Smalltalk environment
				  Squeak, and compares our approach with existing
				  models for composing class properties.},
	Aeres = {ACL},
	Aeresstastus = {2008},
	Annote = {internationaljournal},
	Author = {St\'ephane Ducasse and Nathanael Sch{\"a}rli and Roel Wuyts},
	Doi = {10.1016/j.cl.2004.11.003},
	Impactfactor = {0.467, SCI 06},
	Inria = {hors},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {scg08 scg-pub stefPub schaerli jb05 snf05},
	Medium = {2},
	Misc = {SCI impact factor 0.467},
	Month = dec,
	Number = {3-4},
	Pages = {143--164},
	Peerreview = {yes},
	Publisher = {Elsevier},
	Selectif = {non},
	Title = {Uniform and Safe Metaclass Composition},
	Url = {http://scg.unibe.ch/archive/papers/Duca05ySafeMetaclassTrait.pdf},
	Volume = {31},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca05ySafeMetaclassTrait.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.cl.2004.11.003}}

@inproceedings{Duca05h,
	Abstract = {Wikis are often implemented using string-based
				  approaches to parse and generate their pages. While
				  such approaches work well for simple wikis, they
				  hamper the customization and adaptability of wikis
				  to the variety of end-users when more sophisticated
				  needs are required (i.e., different output formats,
				  user-interfaces, wiki managment, security policies,
				  ...). In this paper we present SmallWiki, the second
				  version of a fully object-oriented implementation of
				  a wiki. SmallWiki is implemented with objects from
				  the top to the bottom and it can be customized
				  easily to accommodate new needs. In addition,
				  SmallWiki is based on a powerful meta-description
				  called Magritte that allows one to create
				  user-interface elements declaratively.},
	Address = {New York, NY, USA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Lukas Renggli and Roel Wuyts},
	Booktitle = {Proceedings ACM International Symposium on Wikis (WikiSym'05)},
	Cvs = {SmallWikiTwoOOPSLASymp2005},
	Doi = {10.1145/1104973.1104981},
	Inria = {hors},
	Keywords = {scg-none jb06 scg-pub snf-none stefPub moose-pub},
	Pages = {75--82},
	Publisher = {ACM Computer Society},
	Selectif = {non},
	Title = {{SmallWiki} --- A Meta-Described Collaborative Content Management System},
	Url = {http://scg.unibe.ch/archive/papers/Duca05hSmallwikiWikiSymp05.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca05hSmallwikiWikiSymp05.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1104973.1104981}}

@inproceedings{Duca05i,
	Abstract = {Understanding classes and methods is a key activity
				  in object-oriented programming, since classes
				  represent the primary abstractions from which
				  applications are built, while methods contain the
				  actual program logic. The main problem of this task
				  is to quickly grasp the purpose and inner structure
				  of a class. To achieve this goal, one must be able
				  to overview multiple methods at once. In this paper,
				  we present microprints, pixel-based representations
				  of methods enriched with semantical information. We
				  present three specialized microprints each dealing
				  with a specific aspect we want to understand of
				  methods: (1) state access, (2) control flow, and (3)
				  invocation relationship.},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Michele Lanza and Romain Robbes},
	Booktitle = {Proceedings of {VISSOFT} 2005 (3th IEEE International Workshop on Visualizing Software for Understanding)},
	Keywords = {scg-pub scg-none jb06 stefPub recast06},
	Month = sep,
	Title = {Multi-level Method Understanding Using {Microprints}},
	Url = {http://scg.unibe.ch/archive/papers/Duca05imicroprintsVissoft.pdf},
	Year = {2005},
  Doi = {10.1109/VISSOF.2005.1684300},
  Pages = {1--6},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca05imicroprintsVissoft.pdf}}

@inproceedings{Duca06a,
	Abstract = {When reengineering legacy systems, it is crucial to
				  assess if the legacy behavior has been preserved or
				  how it changed due to the reengineering effort.
				  Ideally if a legacy system is covered by tests,
				  running the tests on the new version can identify
				  potential differences or discrepancies. However,
				  writing tests for an unknown and large system is
				  difficult due to the lack of internal knowledge. It
				  is especially difficult to bring the system to an
				  appropriate state. Our solution is based on the
				  acknowledgment that one of the few trustable piece
				  of information available when approaching a legacy
				  system is the running system itself. Our approach
				  reifies the execution traces and uses logic
				  programming to express tests on them. Thereby it
				  eliminates the need to programatically bring the
				  system in a particular state, and handles the
				  test-writer a high-level abstraction mechanism to
				  query the trace. The resulting system, called
				  TESTLOG, was used on several real-world case studies
				  to validate our claims.},
	Acceptnum = {27},
	Accepttotal = {65},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Tudor G\^irba and Roel Wuyts},
	Booktitle = {Proceedings of 10th European Conference on Software Maintenance and Reengineering (CSMR'06)},
	Doi = {10.1109/CSMR.2006.37},
	Inria = {hors},
	Keywords = {scg-pub recast06 snf06 scg-none jb06 fb06 stefPub girba},
	Medium = {2},
	Misc = {acceptance rate: 27/65 = 42 \%},
	Pages = {35--44},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society Press},
	Selectif = {non},
	Title = {Object-Oriented Legacy System Trace-based Logic Testing},
	Url = {http://scg.unibe.ch/archive/papers/Duca06aTestLogtestingCSMR.pdf},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca06aTestLogtestingCSMR.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/CSMR.2006.37}}

@article{Duca06b,
	Abstract = {Inheritance is well-known and accepted as a
				  mechanism for reuse in object-oriented languages.
				  Unfortunately, due to the coarse granularity of
				  inheritance, it may be difficult to decompose an
				  application into an optimal class hierarchy that
				  maximizes software reuse. Existing schemes based on
				  single inheritance, multiple inheritance, or mixins,
				  all pose numerous problems for reuse. To overcome
				  these problems we propose traits, pure units of
				  reuse consisting only of methods. We develop a
				  formal model of traits that establishes how traits
				  can be composed, either to form other traits, or to
				  form classes. We also outline an experimental
				  validation in which we apply traits to refactor a
				  non-trivial application into composable units.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {St\'ephane Ducasse and Oscar Nierstrasz and Nathanael Sch{\"a}rli and Roel Wuyts and Andrew P. Black},
	Cvs = {TraitsTOPLAS2005},
	Doi = {10.1145/1119479.1119483},
	Inria = {hors},
	Issn = {0164-0925},
	Journal = {TOPLAS: ACM Transactions on Programming Languages and Systems},
	Keywords = {scg-pub stefPub snf05 snf06 scg-none jb06 toplas traits onhindex(131) schaerli toplastraits stlit-traits},
	Misc = {SCI impact factor 1.404 (2005)},
	Miscmisc = {was Duca05z},
	Month = mar,
	Number = {2},
	Pages = {331--388},
	Selectif = {oui},
	Title = {Traits: A Mechanism for fine-grained Reuse},
	Url = {http://scg.unibe.ch/archive/papers/Duca06bTOPLASTraits.pdf},
	Volume = {28},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca06bTOPLASTraits.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1119479.1119483}}

@inproceedings{Duca06c,
	Abstract = {Understanding large software systems is a
				  challenging task, and to support it many approaches
				  have been developed. Often, the result of these
				  approaches categorize existing entities into new
				  groups or associates them with mutually exclusive
				  properties. In this paper we present the
				  Distribution Map as a generic technique to visualize
				  and analyze this type of result. Our technique is
				  based on the notion of focus, which shows whether a
				  property is well-encapsulated or cross-cutting, and
				  the notion of spread, which shows whether the
				  property is present in several parts of the system.
				  We present a basic visualization and complement it
				  with measurements that quantify focus and spread. To
				  validate our technique we show evidence of applying
				  it on the result sets of different analysis
				  approaches. As a conclusion we propose that the
				  Distribution Map technique should belong to any
				  reverse engineering toolkit.},
	Acceptnum = {41},
	Accepttotal = {147},
	Address = {Los Alamitos CA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Tudor G\^irba and Adrian Kuhn},
	Booktitle = {Proceedings of 22nd IEEE International Conference on Software Maintenance (ICSM '06)},
	Doi = {10.1109/ICSM.2006.22},
	Inria = {hors},
	Keywords = {scg-pub scg-none jb07 fb06 stefPub moose-pub girba recast07 snf06 akuhn},
	Medium = {2},
	Misc = {acceptance rate: 41/147 = 28\%},
	Pages = {203--212},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Rate = {28%},
	Selectif = {oui},
	Title = {Distribution Map},
	Url = {http://scg.unibe.ch/archive/papers/Duca06cDistributionMap.pdf},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca06cDistributionMap.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICSM.2006.22}}

@inproceedings{Duca06d,
	Abstract = {Object-oriented meta-languages such as MOF or EMOF
				  are often used to specify domain specific languages.
				  However, these meta-languages lack the ability to
				  describe behavior or operational semantics. Several
				  approaches used a subset of Java mixed with OCL as
				  executable meta-languages. In this paper, we report
				  our experience of using Smalltalk as an executable
				  and integrated meta-language. We validated this
				  approach in incrementally building over the last
				  decade, Moose, a meta-described reengineering
				  environment. The reflective capabilities of
				  Smalltalk support a uniform way of letting the base
				  developer focus on his tasks while at the same time
				  allowing him to meta-describe his domain model. The
				  advantage of our this approach is that the developer
				  uses the same tools and environment},
	Address = {Berlin, Germany},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Tudor G\^irba},
	Booktitle = {International Conference on Model Driven Engineering Languages and Systems (Models/UML 2006)},
	Doi = {10.1007/11880240_42},
	Inria = {hors},
	Isbn = {978-3-540-45772-5},
	Keywords = {scg-pub scg-none jb07 fb06 girba moose-pub stefPub recast07 norex06},
	Medium = {2},
	Pages = {604--618},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Rate = {28%},
	Selectif = {oui},
	Series = {LNCS},
	Title = {Using {Smalltalk} as a Reflective Executable Meta-Language},
	Url = {http://scg.unibe.ch/archive/papers/Duca06dMOOSEMODELS2006.pdf},
	Volume = {4199},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca06dMOOSEMODELS2006.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/11880240_42}}

@article{Duca06i,
	Abstract = {Although duplicated code is known to pose severe
				  problems for software maintenance, it is difficult
				  to identify in large systems. Many different
				  techniques have been developed to detect software
				  clones, some of which are very sophisticated, but
				  are also expensive to implement and adapt.
				  Lightweight techniques based on simple string
				  matching are easy to implement, but how effective
				  are the
          y? We present a simple stringbased approach
				  which we have successfully applied to a number of
				  different languages such COBOL, {Java}, C++, Pascal,
				  Python, Smalltalk, C and PDP-11 assembler. In each
				  case the maximum time to adapt the approach to a new
				  language was less than 45 minutes. In this article
				  we investigate a number of simple variants of
				  string-based clone detection that abstract away from
				  common editing operations, and assess the quality of
				  clone detection for very different case studies. Our
				  results confirm that this inexpensive clone
				  detection technique generally achieves high recall
				  and acceptable precision. Over-zealous normalization
				  of the code before comparison, however, can result
				  in unacceptable numbers of false positives.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {St\'ephane Ducasse and Oscar Nierstrasz and Matthias Rieger},
	Cvs = {DuplocJournalPaper},
	Doi = {10.1002/smr.317},
	Impactfactor = {0.457, SCI 2005},
	Inria = {hors},
	Journal = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
	Keywords = {scg-pub recast06 scg-none jb06 stefPub duploc onhindex(38)},
	Misc = {SCI impact factor 0.457 (2005)},
	Month = jan,
	Number = 1,
	Pages = {37--58},
	Selectif = {non},
	Title = {On the Effectiveness of Clone Detection by String Matching},
	Url = {http://scg.unibe.ch/archive/papers/Duca06iDuplocJSMEPaper.pdf},
	Volume = 18,
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca06iDuplocJSMEPaper.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1002/smr.317}}

@article{Duca07a,
	Abstract = {Nowadays, many complex applications are built with a
				  web browser as their main user interface. However,
				  despite the increasing popularity of the web as an
				  application platform, implementing and maintaining
				  web applications still remains difficult and lags
				  behind conventional desktop application development.
				  The underlying technologies such as HTTP for the
				  interaction and XHTML/CSS for the presentation were
				  originally built to display and link static
				  documents. Unfortunately, most mainstream frameworks
				  provide only little abstraction over the
				  page-oriented structure imposed by those
				  technologies. Inevitably, the goto-like manner of
				  how pages are linked leads to spaghetti code and
				  hampers reuse. In this article we present Seaside, a
				  web application framework that provides an uniform
				  and pure object-oriented view on web applications.
				  In this way, Seaside avoids the unwieldily goto-like
				  style. Exploiting the reflective features of
				  Smalltalk, Seaside reintroduces procedure call
				  abstraction in the client-server context. Seaside's
				  key concepts are: (i) a component architecture
				  supporting multiple, simultaneously active control
				  flows, (ii) a programmatic XHTML generation, and
				  (iii) fully supported on-the-fly debugging,
				  code-editing, and recompilation. In this article we
				  discuss these key features of Seaside and explain
				  how they are made possible by the dynamic nature and
				  the reflective capabilities of Smalltalk.},
	Address = {Los Alamitos, CA, USA},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {St\'ephane Ducasse and Adrian Lienhard and Lukas Renggli},
	Doi = {10.1109/MS.2007.144},
	Inria = {hors},
	Issn = {0740-7459},
	Journal = {IEEE Software},
	Keywords = {scg07 scg-pub jb08 snf07 seaside-article},
	Medium = {2},
	Number = {5},
	Pages = {56--63},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Selectif = {oui},
	Title = {Seaside: A Flexible Environment for Building Dynamic Web Applications},
	Url = {http://scg.unibe.ch/archive/papers/Duca07a-SeasideIEEE-SCG.pdf},
	Volume = {24},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca07a-SeasideIEEE-SCG.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/MS.2007.144}}

@inproceedings{Duca07b,
	Abstract = {A trait is a unit of behaviour that can be composed
				  with other traits and used by classes. Traits offer
				  an alternative to multiple inheritance. Conflict
				  resolution of traits, while flexible, does not
				  completely handle accidental method name conflicts:
				  if a trait with method m is composed with another
				  trait defining a different method m then resolving
				  the conflict may prove delicate or infeasible in
				  cases where both versions of m are still needed. In
				  this paper we present freezable traits, which
				  provide an expressive composition mechanism to
				  support unanticipated method composition conflicts.
				  Our solution introduces private trait methods and
				  lets the class composer change method visibility at
				  composition time (from public to private and vice
				  versa). Moreover two class composers may use
				  different composition policies for the same trait,
				  something which is not possible in mainstream
				  languages. This approach respects the two main
				  design principles of traits: the class composer is
				  empowered and traits can be flattened away. We
				  present an implementation of freezable traits in
				  Smalltalk. As a side-effect of this implementation
				  we introduced private (early-bound and invisible)
				  methods to Smalltalk by distinguishing object-sends
				  from self-sends. Our implementation uses
				  compile-time bytecode manipulation and, as such,
				  introduces no run-time penalties.},
	Acceptnum = {33},
	Accepttotal = {156},
	Address = {New York, NY, USA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference topconference},
	Author = {St\'ephane Ducasse and Roel Wuyts and Alexandre Bergel and Oscar Nierstrasz},
	Booktitle = {Proceedings of 22nd International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA'07)},
	Doi = {10.1145/1297027.1297040},
	Inria = {hors},
	Isbn = {978-1-59593-786-5},
	Keywords = {scg07 snf08 stefPub alexPub jb08 scg-pub},
	Location = {Montreal, Quebec, Canada},
	Medium = {2},
	Misc = {Acceptance rate: 33/156:21\%},
	Month = oct,
	Pages = {171--190},
	Peerreview = {yes},
	Publisher = {ACM Press},
	Rate = {21%},
	Selectif = {oui},
	Title = {User-Changeable Visibility: Resolving Unanticipated Name Clashes in Traits},
	Url = {http://scg.unibe.ch/archive/papers/Duca07b-FreezableTrait.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca07b-FreezableTrait.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1297027.1297040}}

@inproceedings{Duca08b,
	Abstract = {The increasing amount of data available about
				  software systems poses new challenges for re- and
				  reverse engineering research, as the proposed
				  approaches need to scale. In this context, concerns
				  about meta-modeling and analysis techniques need to
				  be augmented by technical concerns about how to
				  reuse and how to build upon the efforts of previous
				  research. Moose is an extensive infrastructure for
				  reverse engineering evolved for over 10 years that
				  promotes the reuse of engineering efforts in
				  research. Moose accommodates various types of data
				  modeled in the FAMIX family of meta-models. The goal
				  of this half-day workshop is to strengthen the
				  community of researchers and practitioners who are
				  working in re- and reverse engineering, by providing
				  a forum for building future research starting from
				  Moose and FAMIX as shared infrastructure.},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Tudor G\^irba and Orla Greevy and Michele Lanza and Oscar Nierstrasz},
	Booktitle = {15th Working Conference on Software Maintenance and Reengineering (WCRE 2008)},
	Doi = {10.1109/WCRE.2008.51},
	Keywords = {scg08 scg-pub greevy girba jb09 hasler08 moose-pub stefPub},
	Medium = {2},
	Month = oct,
	Pages = {343--344},
	Peerreview = {yes},
	Title = {Workshop on {FAMIX} and {Moose} in Software Reengineering ({FAMOOSr} 2008)},
	Url = {http://scg.unibe.ch/archive/papers/Duca08bFAMOOSr2008.pdf},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca08bFAMOOSr2008.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.2008.51}}

@article{Duca08a,
	Abstract = {Object-oriented modelling languages such as EMOF are
				  often used to specify domain specific meta-models.
				  However, these modelling languages lack the ability
				  to describe behavior or operational semantics.
				  Several approaches have used a subset of Java mixed
				  with OCL as executable meta-languages. In this
				  experience report we show how we use Smalltalk as an
				  executable meta-language in the context of the Moose
				  reengineering environment. We present how we
				  implemented EMOF and its behavioral aspects. Over
				  the last decade we validated this approach through
				  incrementally building a meta-described
				  reengineering environment. Such an approach bridges
				  the gap between a code-oriented view and a
				  meta-model driven one. It avoids the creation of yet
				  another language and reuses the infrastructure and
				  run-time of the underlying implementation language.
				  It offers an uniform way of letting developers focus
				  on their tasks while at the same time allowing them
				  to meta-describe their domain model. The advantage
				  of our approach is that developers use the same
				  tools and environment they use for their regular
				  tasks. Still the approach is not Smalltalk specific
				  but can be applied to language offering an
				  introspective API such as Ruby, Python, CLOS, Java
				  and C#.},
	Aeres = {ACL},
	Annote = {internationaljournal cook},
	Author = {St\'ephane Ducasse and Tudor G\^irba and Adrian Kuhn and Lukas Renggli},
	Doi = {10.1007/s10270-008-0081-4},
	Inria = {hors},
	Journal = {Journal of Software and Systems Modeling (SOSYM)},
	Keywords = {scg09 scg-pub snf09 jb09 stefPub moose-pub girba cook remoose akuhn},
	Medium = {2},
	Month = feb,
	Number = {1},
	Pages = {5--19},
	Peerreview = {yes},
	Publisher = {Springer Verlag},
	Selectif = {oui},
	Title = {Meta-Environment and Executable Meta-Language using {Smalltalk}: an Experience Report},
	Url = {http://scg.unibe.ch/archive/drafts/Duca08a-Sosym-ExecutableMetaLanguage.pdf},
	Volume = {8},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/drafts/Duca08a-Sosym-ExecutableMetaLanguage.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/s10270-008-0081-4}}

@inproceedings{Duca09b,
	Abstract = {Traits are method groups that can be used to compose
				  classes. They do not have a runtime existence and
				  are conceptually folded into the classes that use
				  them. Traits have been implemented in different
				  languages. While implementing them in Smalltalk, our
				  first reflex was to take advantage of the fact that
				  traits are not run-time entities: we optimized the
				  implementation for space and hence shared methods
				  between traits and classes. However, by doing so we
				  broke the introspective API of Smalltalk. This paper
				  illustrates a more general problem seen in all
				  reflective systems: the implementation serves both
				  as a model for execution and as the model that is
				  exposed to the programmer. There is a conflict of
				  interests between the information necessary for
				  execution and the information the programmer is
				  interested in. In addition, as soon as the
				  implementation is exposed via reflection, we are not
				  free to optimize. As the complete implementation is
				  visible reflectively, there is no way to hide the
				  optimizations. Few papers report errors and this is
				  one of them. We report our experience facing the
				  initial API mismatch, which has a significant impact
				  on the system because the language is reflective
				  (i.e., written in itself and causally connected). We
				  present the new introspective API we put in place.},
	Address = {New York, NY, USA},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Ducasse, St\'ephane and Denker, Marcus and Lienhard, Adrian},
	Booktitle = {Proceedings of the International Workshop on Smalltalk Technologies (IWST'09)},
	Doi = {10.1145/1735935.1735949},
	Inria = {dans},
	Isbn = {978-1-60558-899-5},
	Keywords = {stefPub jb10 scg-pub scg10 snf10},
	PeerReview = {yes},
	Medium = {1},
	Location = {Brest, France},
	Month = {jun},
	Pages = {82--86},
	Publisher = {ACM},
	Selectif = {non},
	Title = {Evolving a Reflective Language},
	Url = {http://scg.unibe.ch/archive/papers/Duca09bTraitsEvolution.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Duca09bTraitsEvolution.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1735935.1735949}}

@book{Duca10a,
	Abstract = {Seaside is the open source framework of choice for
				  developing sophisticated and dynamic web
				  applications. Seaside uses the power of objects to
				  master the web. With Seaside web applications is as
				  simple as building desktop applications. Seaside
				  lets you build highly dynamic and interactive web
				  applications. Seaside supports agile development
				  through interactive debugging and unit testing.
				  Seaside is based on Smalltalk, a proven and robust
				  language implemented by different vendors. Seaside
				  is now available for all the major Smalltalk
				  including Pharo, Squeak, GNU Smalltalk, Cincom
				  Smalltalk, GemStone Smalltalk, and VA Smalltalk.},
	Annote = {book},
	Author = {St\'ephane Ducasse and Lukas Renggli and C. David Shaffer and Rick Zaccone and Michael Davies},
	Isbn = {978-3-9523341-1-9},
	Keywords = {scg-pub scg10 skip-doi snf-none jb10 evol11},
	Medium = {2},
	Note = {http://book.seaside.st/book},
	Peerreview = {no},
	Publisher = {Square Bracket Associates},
	Title = {Dynamic Web Development with Seaside},
	Url = {http://book.seaside.st/book},
	Year = {2010},
	Bdsk-Url-1 = {http://book.seaside.st/book}}

@inproceedings{Ebra22a,
	author={Arash Ale Ebrahim and Mohammadreza Hazhirpasand and Oscar Nierstrasz and Mohammad Ghafari},
	booktitle={29th edition of the IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)},
	title={{FuzzingDriver}: the Missing Dictionary to Increase Code Coverage in Fuzzers},
	Annote = {internationalconference},
	PeerReview = {yes},
	Medium = {2},
	abstract={We propose a tool, called FuzzingDriver, to generate
		dictionary tokens for coverage-based greybox fuzzers
		(CGF) from the codebase of any target program.
		FuzzingDriver does not add any overhead to the fuzzing
		job as it is run beforehand. We compared FuzzingDriver to
		Google dictionaries by fuzzing six open-source targets,
		and we found that FuzzingDriver consistently achieves
		higher code coverage in all tests. We also executed eight
		benchmarks on FuzzBench to demonstrate how utilizing
		FuzzingDriver's dictionaries can outperform six
		widely-used CGF fuzzers. In future work, investigating
		the impact of FuzzingDriver's dictionaries on improving
		bug coverage might prove important.},
	keywords={scg-pub snf-asa3 scg22 jb22},
	Url = {http://scg.unibe.ch/archive/papers/Ebra22a.pdf},
  Doi = {10.1109/SANER53432.2022.00042},
	month=mar,
	year={2022}
}

@article{Gadi18a,
	author = {Gadient, Pascal and Ghafari, Mohammad and Frischknecht, Patrick and Nierstrasz, Oscar},
	title = {Security Code Smells in {Android} {ICC}},
	editor = {De Roover, Coen and Zhao, Jianjun and Lo, David},
	journal = {Empirical Software Engineering},
	volume = {24},
	issue = {5},
	year = {2019},
	pages = {3046--3076},
	keywords = {scg-pub security snf-asa3 scg18 jb19; Security code smells; Vulnerability; Static analysis; Android},
	Annote = {internationaljournal},
	medium = {2},
	peerreview = {yes},
	publisher = {Springer US},
	doi = {10.1007/s10664-018-9673-y},
	abstract = {Android Inter-Component Communication (ICC) is complex, largely unconstrained, and hard for developers to understand. As a consequence, ICC is a common source of security vulnerability in Android apps. To promote secure programming practices, we have reviewed related research, and identified avoidable ICC vulnerabilities in Android-run devices and the security code smells that indicate their presence. We explain the vulnerabilities and their corresponding smells, and we discuss how they can be eliminated or mitigated during development. We present a lightweight static analysis tool on top of Android Lint that analyzes the code under development and provides just-in-time feedback within the IDE about the presence of such smells in the code. Moreover, with the help of this tool we study the prevalence of security code smells in more than 700 open-source apps, and manually inspect around 15% of the apps to assess the extent to which identifying such smells uncovers ICC security vulnerabilities.},
	url = {http://scg.unibe.ch/archive/papers/Gadi18a.pdf}}

@inproceedings{Gadi20a,
	author={Gadient, Pascal and Ghafari, Mohammad and Tarnutzer, Marc-Andrea and Nierstrasz, Oscar},
	booktitle={27th edition of the IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)},
	title={Web {APIs} in {Android} through the Lens of Security},
	year={2020},
	Annote    = {internationalconference},
	PeerReview = {yes},
	Medium = {2},
	abstract={Web communication has become an indispensable characteristic of mobile apps. However, it is not clear what data the apps transmit, to whom, and what consequences such transmissions have. We analyzed the web communications found in mobile apps from the perspective of security. We first manually studied 160 Android apps to identify the commonly-used communication libraries, and to understand how they are used in these apps. We then developed a tool to statically identify web API URLs used in the apps, and restore the JSON data schemas including the type and value of each parameter. We extracted 9,714 distinct web API URLs that were used in 3,376 apps. We found that developers often use the java.net package for network communication, however, third-party libraries like OkHttp are also used in many apps. We discovered that insecure HTTP connections are seven times more prevalent in closed-source than in open-source apps, and that embedded SQL and JavaScript code is used in web communication in more than 500 different apps. This finding is devastating; it leaves billions of users and API service providers vulnerable to attack.},
	keywords={scg-pub security snf-asa3 scg20 jb20 snf-imad},
	doi = {10.1109/SANER48275.2020.9054850},
	month=mar,
	Url={http://scg.unibe.ch/archive/papers/Gadi20a.pdf}
}

@inproceedings{Gadi21a,
	author={Gadient, Pascal and Tarnutzer, Marc-Andrea and Nierstrasz, Oscar and Ghafari, Mohammad},
	booktitle={ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)},
	title={Security Smells Pervade Mobile App Servers},
	year={2021},
	Annote    = {internationalconference},
	PeerReview = {yes},
	Medium = {2},
	abstract={[Background] Web communication is universal in cyberspace, and security risks in this domain are devastating. [Aims] We analyzed the prevalence of six security smells in mobile app servers, and we investigated the consequence of these smells from a security perspective. [Method] We used an existing dataset that includes 9,714 distinct URLs used in 3,376 Android mobile apps. We exercised these URLs twice within 14 months and investigated the HTTP headers and bodies. [Results] We found that more than 69% of tested apps suffer from three kinds of security smells, and that unprotected communication and misconfigurations are very common in servers. Moreover, source-code and version leaks, or the lack of update policies expose app servers to security risks. [Conclusions] Poor app server maintenance greatly hampers security.},
	keywords={scg-pub security snf-asa3 scg21 jb22},
	doi = {10.1145/3475716.3475780},
	month=oct,
	Url={http://scg.unibe.ch/archive/papers/Gadi21a.pdf}
}

@inproceedings{Gadi21b,
	author={Gadient, Pascal and Gerig, Pascal and Nierstrasz, Oscar and Ghafari, Mohammad},
	booktitle={21st IEEE International Conference on Software Quality, Reliability, and Security (QRS)},
	title={Phish What You Wish},
	year={2021},
	Annote    = {internationalconference},
	PeerReview = {yes},
	Medium = {2},
	abstract={IT professionals have no simple tool to create phishing websites and raise the awareness of users. We developed a prototype that can dynamically mimic websites by using enriched screenshots, which requires no additional programming experience and is simple to set up. The generated websites are functional and remain up-to-date. We found that 98% of the hyperlinks in mimicked websites are functional with our tool, compared to 43% with the best competitor, and only two participants suspected phishing attempts at the time they were performing tasks with our prototype. This work intends to raise awareness for phishing attempts especially with local websites by providing an easy to use prototype to set up such phishing sites.},
	keywords={scg-pub security snf-asa3 scg21 jb22},
	month=dec,
	Url={http://scg.unibe.ch/archive/papers/Gadi21b.pdf},
	Doi = {10.1109/QRS54544.2021.00113}
}

@inproceedings{Gadi21c,
	author={Gadient, Pascal and Nierstrasz, Oscar and Ghafari, Mohammad},
	booktitle={21st IEEE International Conference on Software Quality, Reliability, and Security (QRS)},
	title={Security Header Fields in {HTTP} Clients},
	year={2021},
	Annote    = {internationalconference},
	PeerReview = {yes},
	Medium = {2},
	abstract={HTTP headers are commonly used to establish web communications, and some of them are relevant for security. However, we have only little information about the usage and support of security-relevant headers in mobile applications. We explored the adoption of such headers in mobile app communication by querying 9,714 distinct URLs that were used in 3,376 apps and collected each server's response information. We discovered that support for secure HTTP header fields is absent in all major HTTP clients, and it is barely provided with any server response. Based on these results, we discuss opportunities for improvement particularly to reduce the likelihood of data leaks and arbitrary code execution. We advocate more comprehensive use of existing HTTP headers and timely development of relevant web browser security features in HTTP client libraries.},
	keywords={scg-pub security snf-asa3 scg21 jb22},
	month=dec,
	Url={http://scg.unibe.ch/archive/papers/Gadi21c.pdf},
	Doi = {10.1109/QRS54544.2021.00020}
}

@techreport{Gael03b,
	Abstract = {A single software fault may cause several tests to
				  break, if they cover the same methods. The coverage
				  sets of tests may not just overlap, but include one
				  another. This information could be of great use to
				  developers who would like to focus on the most
				  specific test that concerns a given fault.
				  Unfortunately, existing unit testing tools neither
				  gather nor exploit this information. We have
				  developed a simple approach that analyses a set of
				  test suites, and infers the partial order
				  corresponding to inclusion hierarchy of the coverage
				  sets. When several tests in an inclusion chain
				  break, we can guide the developer to the most
				  specific test in the chain. Our first experiments
				  with three case studies suggest that most unit tests
				  for typical applications are, in fact, comparable to
				  other tests, and can therefore be partially ordered.
				  Furthermore, we show that this partial order is
				  semantically meaningful, since faults that cause a
				  test to break will, in nearly all cases cause less
				  specific tests too break too.},
	Address = {Universit\"at Bern, Switzerland},
	Author = {Markus Gaelli and Oscar Nierstrasz and Roel Wuyts},
	Classification = {D.2.6 Programming Environments D.2.10 Design D.1.5 Object-oriented Programming; D.3.3 Language Constructs and Features},
	Cvs = {EgTecReportPartialOrdering},
	General_Terms = {Testing, Refactoring, Test Composition, Unit Tests, Reuse, Smalltalk, Test Prioritizing, OOP},
	Institution = {Institut f\"ur Informatik},
	Keywords = {scg-none jb-none scg-pub skip-doi gaelli},
	Misc = {gaelli},
	Month = sep,
	Note = {Technical Report},
	Number = {IAM-03-013},
	Title = {Partial ordering tests by coverage sets},
	Url = {http://scg.unibe.ch/archive/papers/Gael03bPartialOrderingTestsByCoverageSets.pdf},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gael03bPartialOrderingTestsByCoverageSets.pdf}}

@inproceedings{Gael03c,
	Abstract = {While assertions of Design by Contract from Eiffel
				  found its way into the language-definitions of
				  Python and of Java SDK 1.4, current object-oriented
				  languages do not make the concepts of unit-testing
				  explicit in their definitions or meta-models. Not
				  having support of unit-testing in a programming
				  language makes it harder to compose and re-compose
				  test-scenarios and tests. We propose, that an
				  object-oriented language should include explicit
				  concepts for example objects, example methods and
				  instance-specific assertions. This concepts ease the
				  composition of complex test-scenarios, they help to
				  refactor the program with the tests and also to keep
				  the duration of the tests as low and the coverage of
				  the tests as high as possible.},
	Annote = {internationalworkshop},
	Author = {Markus Gaelli},
	Booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
	Doi = {10.1007/b98806},
	Isbn = {978-3-540-22405-1},
	Keywords = {snf03 scg-none jb-none scg-pub gaelli},
	Misc = {gaelli},
	Month = jul,
	Note = {Abstract only --- full version availabe as technical report IAM-03-009},
	Pages = {143--153},
	Series = {LNCS},
	Title = {Test composition with example objects and example methods.},
	Url = {http://scg.unibe.ch/archive/papers/Gael03aTestComposition.pdf},
	Volume = {3013},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gael03aTestComposition.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/b98806}}

@inproceedings{Gael04a,
	Abstract = {Current unit test frameworks present broken unit
				  tests in an arbitrary order, but developers want to
				  focus on the most specific ones first. We therefore
				  inferred a partial order of unit tests corresponding
				  to a coverage hierarchy of their sets of covered
				  method signatures: When several unit tests in this
				  coverage hierarchy break, we can guide the developer
				  to the test calling the smallest number of methods.
				  Our experiments with four case studies indicate that
				  this partial order is semantically meaningful, since
				  faults that cause a unit test to break generally
				  cause less specific unit tests to break as well.},
	Annote = {internationalconference},
	Author = {Markus Gaelli and Michele Lanza and Oscar Nierstrasz and Roel Wuyts},
	Booktitle = {20th International Conference on Software Maintenance (ICSM 2004)},
	Cvs = {EgICSM2004},
	Doi = {10.1109/ICSM.2004.1357796},
	Keywords = {scg-pub testing scg-none jb05 snf04 gaelli},
	Misc = {gaelli},
	Pages = {114--123},
	Title = {Ordering Broken Unit Tests for Focused Debugging},
	Url = {http://scg.unibe.ch/archive/papers/Gael04aOrderingBrokenUnitTestsForFocusedDebugging.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gael04aOrderingBrokenUnitTestsForFocusedDebugging.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICSM.2004.1357796}}

@inproceedings{Gael04c,
	Abstract = {Although unit testing is essential for programming,
				  current languages only barely support the developer
				  in composing unit tests into new ones or in
				  navigating between unit tests and their
				  corresponding methods under test. We have taken
				  several Smalltalk programs and analyzed the
				  relationships between unit tests and methods under
				  test, and the re- lationships amongst unit tests.
				  First results indicate that most unit tests can be
				  seen or at least decomposed into commands which
				  focus on single methods, and that large portions of
				  unit tests overlap each other. But these
				  relationships between unit tests and methods under
				  test are not reflected in current languages. We
				  therefore first conceptually extend the meta-model
				  of Smalltalk with one-method commands so that unit
				  tests become both com- posable and navigable. Then
				  we introduce a first lightweight implementation of
				  this meta model using method comments to
				  differentiate between the several test phases of
				  existing XUnit test case methods.},
	Annote = {internationalworkshop},
	Author = {Markus Gaelli and Oscar Nierstrasz and St{\'e}phane Ducasse},
	Booktitle = {OOPSLA Workshop on Revival of Dynamic Languages},
	Cvs = {EgRDL2004},
	Keywords = {snf05 scg-pub skip-doi gaelli scg-none jb05},
	Month = oct,
	Title = {One-Method Commands: Linking Methods and Their Tests},
	Url = {http://scg.unibe.ch/archive/papers/Gael04cLinkingMethodsAndTests.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gael04cLinkingMethodsAndTests.pdf}}

@inproceedings{Gael04d,
	Author = {Markus Gaelli},
	Booktitle = {5th International Conference on Extreme Programming and Agile Processes in Software Engineering (XP 2004)},
	Doi = {10.1007/b98150},
	Isbn = {978-3-540-22137-1},
	Keywords = {scg-pub testing scg-none jb05 snf04 skip-abstract gaelli},
	Misc = {gaelli},
	Month = jun,
	Pages = {317},
	Series = {LNCS},
	Title = {{PhD}-Symposium: Correlating Unit Tests and Methods under Test},
	Url = {http://scg.unibe.ch/archive/papers/Gael04dCorrelatingUnitTestsAndMethodsUnderTest.pdf},
	Volume = {3092},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gael04dCorrelatingUnitTestsAndMethodsUnderTest.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/b98150}}

@inproceedings{Gael05a,
	Abstract = {Not all unit tests are alike. Some tests are simple
				  one-liners, while others contain a battery of
				  assertions. Certain tests focus on a single method,
				  while others test interactions between methods.
				  There are even tests that do not contain assertions
				  at all. This can make it difficult for a developer
				  to understand which methods are tested by which
				  tests, to what degree they are tested, and what to
				  take into account while refactoring. We have
				  manually analyzed the test base of a large existing
				  object-oriented system in order to derive a first
				  taxonomy of unit tests. We have then developed some
				  simple tools to semi-automatically categorize tests
				  according to this taxonomy, and applied it to two
				  case studies. Beside explaining our taxonomy, we
				  report on our initial results using it, namely that
				  a majority of unit tests focus on single methods and
				  that our lightweight automatic categorization could
				  already classify more than 50\% of these single
				  method commands.},
	Annote = {internationalconference},
	Author = {Markus Gaelli and Michele Lanza and Oscar Nierstrasz},
	Booktitle = {Proceedings of 13th International Smalltalk Conference (ISC'03)},
	Cvs = {EgESUG2005},
	Keywords = {scg-pub skip-doi scg-none jb06 snf05 testing unit tests gaelli},
	Misc = {gaelli},
	Month = sep,
	Title = {Towards a Taxonomy of {SUnit} Tests},
	url = {http://scg.unibe.ch/archive/papers/Gael05aTowardsATaxonomyOfUnitTests.pdf},
	url2 = {http://www.esug.org/conferences/thirteenthinternationalconference2005/researchconference/acceptedpapers/},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gael05aTowardsATaxonomyOfUnitTests.pdf%20http://www.esug.org/conferences/thirteenthinternationalconference2005/researchconference/acceptedpapers/}}

@inproceedings{Gael05b,
	Abstract = {If we were to apply the testing techniques of
				  object-oriented systems prescribed by the XUnit
				  framework to a car factory, the result would be an
				  inefficient process: A tire would be created,
				  quality assured and then thrown away, only to be
				  recreated later to test the functionality of the
				  whole car. XUnit makes it difficult to reuse
				  intermediate results of low level unit tests. As a
				  consequence a higher level unit test is forced to
				  recreate test scenarios which were already created
				  by lower level unit tests. This duplicated testing
				  effort is time-consuming both for setting up new
				  scenarios and for running the tests. To address this
				  problem we suggest a semi-automatic approach to
				  compose tests. First we describe how we can detect
				  candidates of composable test cases by partially
				  ordering their sets of covered method signatures,
				  then we present techniques to refactor unit tests
				  accordingly.},
	Annote = {internationalworkshop},
	Author = {Markus Gaelli and Orla Greevy and Oscar Nierstrasz},
	Booktitle = {Proceedings of SPLiT 2005 (2nd International Workshop on Software Product Line Testing)},
	Cvs = {EgSplit2005},
	Keywords = {scg-pub scg-none jb-none skip-doi gaelli},
	Misc = {gaelli},
	Month = sep,
	Title = {Composing Unit Tests},
	url = {http://scg.unibe.ch/archive/papers/Gael05bComposingUnitTests.pdf},
	url2 = {http://www.biglever.com/split2005/Presentations/SPLiT2005_Proceedings.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gael05bComposingUnitTests.pdf%20http://www.biglever.com/split2005/Presentations/SPLiT2005_Proceedings.pdf}}

@inproceedings{Gael06a,
	Abstract = {Creating ones own games has been the main motiva-
				  tion for many people to learn programming. But the
				  barrier to learn a general purpose programming
				  language is very high, especially if some positive
				  results can only be expected after having manually
				  written more than 100 lines of code. With this paper
				  we first motivate potential users by showing that
				  one can create classic board- and arcade games like
				  Lights Out, TicTacToe, or Pacman within the playful
				  and constructivist visual learning environment Etoys
				  dragging together only a few lines of code. Then we
				  present recurring idioms which helped to develop
				  these games with only a few lines of code.},
	Annote = {internationalconference},
	Author = {Markus Gaelli and Oscar Nierstrasz and Serge Stinckwich},
	Booktitle = {Proceedings of C5 2006 (The Fourth International Conference on Creating, Connecting and Collaborating through Computing)},
	Cvs = {EgGamesCCC2005},
	Doi = {10.1109/C5.2006.20},
	Keywords = {scg-pub scg-none jb06 snf06 games idioms pattern visprog visual languages gaelli},
	Misc = {gaelli},
	Month = jan,
	Pages = {222--321},
	Title = {Idioms for Composing Games with {Etoys}},
	Url = {http://scg.unibe.ch/archive/papers/Gael06aC5.pdf},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gael06aC5.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/C5.2006.20}}

@inproceedings{Gael07a,
	Abstract = {Understanding and maintaining complex software
				  systems is a difficult task. In principle, tests can
				  be a good source of information about how the system
				  works. Unfortunately, tests are frequently
				  unstructured and disconnected from each other and
				  from their units under test. We propose a new
				  approach to organizing unit tests in which tests
				  produce examples of their units under tests which
				  also can be reused for composing higher-level tests.
				  The approach is based on the Eg meta-model, which
				  classifies tests according to their granularity and
				  their goals. We have developed the EgBrowser, an
				  experimental tool for specifying tests that conform
				  to the Eg metamodel while keeping track of the
				  connection between tests themselves and their units
				  under test. Initial usability studies suggest that
				  the approach is both easy to learn and more
				  efficient than the programmatic approach to
				  developing tests.},
	Annote = {internationalconference internationaljournal},
	Author = {Markus Gaelli and Rafael Wampfler and Oscar Nierstrasz},
	Booktitle = {Journal of Object Technology, Special Issue. Proceedings of TOOLS Europe 2007},
	Cached = {http://scg.unibe.ch/archive/papers/Gael07aComposingTests.pdf},
	Doi = {10.5381/jot.2007.6.9.a4},
	Keywords = {scg07 scg-pub skip-doi snf07 jb08 gaelli},
	Medium = {2},
	Month = oct,
	Pages = {71--86},
	Peerreview = {yes},
	Title = {Composing Tests from Examples},
	url = {http://www.jot.fm/issues/issue_2007_10/paper4.pdf},
	url2 = {http://www.jot.fm/contents/issue_2007_10/paper4.html},
	Volume = {6/9},
	Year = {2007},
	Bdsk-Url-1 = {http://www.jot.fm/issues/issue_2007_10/paper4/index.html%20http://www.jot.fm/issues/issue_2007_10/paper4.pdf}}

@book{Gens02a,
	Abstract = {This Handbook presents the PECOS approach for
				  developing field device software. It has been
				  written for the developer who wants to apply the
				  method in a realistic setting. By following this
				  tutorial the reader will get a good understanding of
				  PECOS and will learn how to use PECOS to develop
				  software for embedded real-time systems.},
	Annote = {notrefereed handbook},
	Author = {Thomas Genssler and Alexander Christoph and Benedikt Schulz and Michael Winter and Chris M. Stich and Christian Zeidler and Peter M\"uller and Andreas Stelter and Oscar Nierstrasz and St\'ephane Ducasse and Gabriela Ar{\'e}valo and Roel Wuyts and Peng Liang and Bastiaan Sch\"onhage and Reinier van den Born},
	Keywords = {olit scg-pub skip-doi scg-none jb02 pecos arevalo stefPub},
	Month = sep,
	Publisher = {The Pecos Consortium},
	Title = {PECOS in a Nutshell},
	Url = {http://www.pecos-project.org/public_documents/pecosHandbook.pdf},
	Year = {2002},
	Bdsk-Url-1 = {http://www.pecos-project.org/public_documents/pecosHandbook.pdf}}

@inproceedings{Gens02b,
	Abstract = {Software is more and more becoming the major cost
				  factor for embedded devices. Already today, software
				  accounts for more than 50 percent of the development
				  costs of such a device. However, software
				  development practices in this area lag far behind
				  those in the traditional software industry. Reuse is
				  hardly ever heard of in some areas, development from
				  scratch is common practice and component-based
				  software is usually a foreign word. PECOS is a
				  collaborative project between industrial and
				  research partners that seeks to enable
				  component-based technology for a certain class of
				  embedded systems known as "field devices" by taking
				  into account the specific properties of this
				  application area. In this paper we introduce a
				  component model for field device software.
				  Furthermore we report on the PECOS component
				  composition language CoCo and the mapping from CoCo
				  to {Java} and C++.},
	Annote = {internationalconference},
	Author = {Thomas Gen{\ss}ler and Oscar Nierstrasz and Bastiaan Sch\"onhage},
	Booktitle = {Proc. International Conference on Compilers, Architectures and Synthesis for Embedded Systems},
	Doi = {10.1145/581630.581634},
	Keywords = {olit pecos scg-pub scg-none jb04},
	Title = {Components for Embedded Software --- The {PECOS} Approach},
	Url = {http://scg.unibe.ch/archive/pecos/public_documents/Gens02b.pdf},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/pecos/public_documents/Gens02b.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/581630.581634}}

@article{Ghaf17a,
	author = {Ghafari, Mohammad and Rubinov, Konstantin and Pourhashem K., Mohammad Mehdi},
	title = {Mining unit test cases to synthesize {API} usage examples},
	journal = {Journal of Software: Evolution and Process},
	issn = {2047-7481},
	volume = {29},
	number = {12},
	PeerReview = {yes},
	Medium = {2},
	url = {https://www.researchgate.net/profile/Mohammad_Ghafari3/publication/312669557_Mining_unit_test_cases_to_synthesize_API_usage_examples/links/5a0ab38c45851551b78d51c9/Mining-unit-test-cases-to-synthesize-API-usage-examples.pdf},
	doi = {10.1002/smr.1841},
	pages = {e1841--n/a},
	keywords = {scg-pub snf-asa2 scg17 jb17},
	year = {2017},
	note = {e1841 smr.1841},
	abstract = {Software developers study and reuse existing source code to understand how to properly use application programming interfaces (APIs). However, manually finding sufficient and adequate code examples for a given API is a difficult and a time-consuming activity. Existing approaches to find or generate examples assume availability of a reasonable set of client code that uses the API. This assumption does not hold for newly released API libraries, non-widely used APIs, nor private ones.In this work we reuse the important information that is naturally present in test code to circumvent the lack of usage examples for an API when other sources of client code are not available. We propose an approach for automatically identifying the most representative API uses within each unit test case. We then develop an approach to synthesize API usage examples by extracting relevant statements representing the usage of such APIs. We compare the output of a prototype implementation of our approach to both human-written examples and to a state-of-the-art approach. The obtained results are encouraging; the examples automatically generated with our approach are superior to the state-of-the-art approach and highly similar to the manually constructed examples.}
}

@inproceedings{Ghaf17b,
author={Ghafari, Mohammad and Moradi, Hamidreza},
booktitle={2017 IEEE 24th International Conference on Software Analysis, Evolution and Reengineering (SANER)},
title={A framework for classifying and comparing source code recommendation systems},
year={2017},
PeerReview = {yes},
Medium = {2},
pages={555-556},
abstract={The use of Application Programming Interfaces (APIs) is pervasive in software systems; it makes the development of new software much easier, but remembering large APIs with sophisticated usage protocol is arduous for software developers. Code recommendation systems alleviate this burden by providing developers with a ranked list of API usages that are estimated to be most useful to their development tasks. The promise of these systems has motivated researchers to invest considerable effort to develop many of them over the past decade, yet the achievements are not evident. To assess the state of the art in code recommendation, we propose a framework for classifying and comparing these systems. We hope the framework will help the community to conduct a systematic study to gain insight into how much code recommendation has so far achieved, in both research and practice.},
keywords={scg-pub snf-none scg17 jb17},
doi={10.1109/SANER.2017.7884674},
url = {http://dx.doi.org/10.1109/SANER.2017.7884674}
}

@inproceedings{Ghaf17c,
author={Ghafari, Mohammad and Gadient, Pascal and Nierstrasz, Oscar},
booktitle={17th IEEE International Working Conference on Source Code Analysis and Manipulation (SCAM)},
title={Security Smells in {Android}},
year={2017},
Annote    = {internationalconference},
PeerReview = {yes},
Medium = {2},
abstract={The ubiquity of smartphones, and their very broad capabilities and usage, make the security of these devices tremendously important. Unfortunately, despite all progress in security and privacy mechanisms, vulnerabilities continue to proliferate. Research has shown that many vulnerabilities are due to insecure programming practices. However, each study has often dealt with a specific issue, making the results less actionable for practitioners. To promote secure programming practices, we have reviewed related research, and identified avoidable vulnerabilities in Android-run devices and the security code smells that indicate their presence. In particular, we explain the vulnerabilities, their corresponding smells, and we discuss how they could be eliminated or mitigated during development. Moreover, we develop a lightweight static analysis tool and discuss the extent to which it successfully detects several vulnerabilities in about 46,000 apps hosted by the official Android market.},
keywords={scg-pub security snf-asa2 scg17 jb18},
doi = {10.1109/SCAM.2017.24},
pages = {121-130},
month=sep,
Url={http://scg.unibe.ch/archive/papers/Ghaf17c.pdf}
}

@inproceedings{Ghaf19a,
	author={M. {Ghafari} and M. {Eggiman} and O. {Nierstrasz}},
	booktitle={2019 ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)},
	title={Testability First!},
	year={2019},
	pages={1-6},
	abstract={Background: The pivotal role of testing in
		high-quality software production has driven a significant
		effort in evaluating and assessing testing practices. Aims:
		We explore the state of testing in a large industrial
		project over an extended period. Method: We study the
		interplay between bugs in the project and its test cases,
		and interview developers and stakeholders to uncover
		reasons underpinning our observations. Results: We realized
		that testing is not well adopted, and that
		testability(i.e., ease of testing) is low. We found that
		developers tended to abandon writing tests when they
		assessed the effort to be high. Frequent changes in
		requirements and pressure to add new features also hindered
		developers from writing tests. Conclusions: Regardless of
		the debates on test first or later, we hypothesize that the
		underlying reasons for poor test quality are rooted in a
		lack of attention to testing early in the development of a
		software component, leading to poor testability of the
		component. However, testability is usually overlooked in
		research that studies the impact of testing practices, and
		should be explicitly taken into account.},
	keywords = {scg-pub snf-asa3 scg19 jb19},
	doi={10.1109/ESEM.2019.8870170},
	url = {http://scg.unibe.ch/archive/papers/Ghaf19a-TestabilityFirst.pdf},
	medium = {2},
	peerreview = {yes},
    Annote = {internationalconference},
	ISSN={1949-3770},
	month={sep}
}

@inproceedings{Girb04a,
	Abstract = {Analyzing historical information can show how a
				  software system evolved into its current state, but
				  it can also show which parts of the system are more
				  evolution prone. Yet, historical analysis implies
				  processing a vast amount of information which makes
				  the interpretation difficult. To address this issue,
				  we introduce the notion of history of source code
				  artifacts as a first class entity and define
				  measurements which summarize the evolution of such
				  entities. We then use these measurements to define
				  polymetric views for visualizing the effect of time
				  on class hierarchies. We show the application of our
				  approach on one large open source case study and
				  reveal how we can classify the class hierarchies
				  based on their history.},
	Annote = {internationalworkshop},
	Author = {Tudor G\^irba and Michele Lanza},
	Booktitle = {WOOR 2004 (5th ECOOP Workshop on Object-Oriented Reengineering)},
	Keywords = {scg-pub skip-doi evolution metrics visualization van hismo girba recast04 scg-none jb04 moose-pub},
	Title = {Visualizing and Characterizing the Evolution of Class Hierarchies},
	Url = {http://scg.unibe.ch/archive/papers/Girb04aHierarchiesEvolution.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Girb04aHierarchiesEvolution.pdf}}

@inproceedings{Girb05b,
	Abstract = {Understanding how software systems evolve is useful
				  from different perspectives: reverse engineering,
				  empirical studies etc.. For an effective
				  understanding we need an explicit meta-model. We
				  introduce Hismo, a meta-model which is centered
				  around the notion of history and we show how we can
				  obtain it from a snapshot meta-model. Based on our
				  experience in developing the Hismo reverse
				  engineering system, we show how we can transform a
				  snapshot meta-model in a history metamodel.},
	Annote = {internationalworkshop},
	Author = {Tudor G\^irba and Jean-Marie Favre and St\'ephane Ducasse},
	Booktitle = {Proceedings of 2nd International Workshop on Meta-Models and Schemas for Reverse Engineering (ATEM 2004)},
	Doi = {10.1016/j.entcs.2005.07.005},
	Keywords = {scg-pub evolution meta-modeling hismo van moose-pub recast05 jointERCIM girba stefPub scg-none jb05},
	Pages = {57--64},
	Title = {Using Meta-Model Transformation to Model Software Evolution},
	Url = {http://scg.unibe.ch/archive/papers/Girb05bMetaModelTransATEM2004.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Girb05bMetaModelTransATEM2004.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.entcs.2005.07.005}}

@inproceedings{Girb04b,
	Abstract = {Knowing where to start reverse engineering a large
				  software system, when no information other than the
				  system`s source code itself is available, is a
				  daunting task. Having the history of the code (i.e.,
				  the versions) could be of help if this would not
				  imply analyzing a huge amount of data. In this paper
				  we present an approach for identifying candidate
				  classes for reverse engineering and reengineering
				  efforts. Our solution is based on summarizing the
				  changes in the evolution of object-oriented software
				  systems by defining history measurements. Our
				  approach, named Yesterday`s Weather, is an analysis
				  based on the retrospective empirical observation
				  that classes which changed the most in the recent
				  past also suffer important changes in the near
				  future. We apply this approach on two case studies
				  and show how we can obtain an overview of the
				  evolution of a system and pinpoint its classes that
				  might change in the next versions.},
	Acceptnum = {38},
	Accepttotal = {122},
	Address = {Los Alamitos CA},
	Annote = {internationalconference},
	Author = {Tudor G\^irba and St\'ephane Ducasse and Michele Lanza},
	Booktitle = {Proceedings of 20th IEEE International Conference on Software Maintenance (ICSM'04)},
	Doi = {10.1109/ICSM.2004.1357788},
	Keywords = {scg-pub evolution metrics hismo stefPub van moose-pub girba recast05 scg-none jb05},
	Location = {Illinois, USA},
	Misc = {acceptance rate: 38/122 = 31\%},
	Month = sep,
	Pages = {40--49},
	Publisher = {IEEE Computer Society},
	Title = {{Yesterday's} {Weather}: Guiding Early Reverse Engineering Efforts by Summarizing the Evolution of Changes},
	Url = {http://scg.unibe.ch/archive/papers/Girb04bYesterdayWeather.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Girb04bYesterdayWeather.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICSM.2004.1357788}}

@inproceedings{Girb04d,
	Abstract = {Software system need to change over time to cope
				  with the new requirements. Furthermore, due to
				  design decisions, the new requirements happen to
				  crosscut the system's structure. Understanding how
				  changes appear in the system can reveal hidden
				  dependencies between different parts of the system.
				  We propose to group entities that change together
				  according to a logical expression that specifies the
				  change condition. Furthermore, we can group entities
				  at different levels of abstraction (i.e., method,
				  class, package). Our approach is based on an
				  explicit history meta model that centers around the
				  notion of history and which enables the definition
				  of historical measurements which summarize the
				  changes. We apply our approach on two large case
				  studies and show how we can identify groups of
				  related entities and detect bad smells.},
	Annote = {internationalworkshop},
	Author = {Tudor G\^irba and St\'ephane Ducasse and Radu Marinescu and Daniel Ra\c{t}iu},
	Booktitle = {Ninth IEEE Workshop on Empirical Studies of Software Maintenance},
	Keywords = {scg-pub skip-doi evolution van metrics smell hismo stefPub recast05 girba scg-none jb05 moose-pub},
	Title = {Identifying Entities That Change Together},
	Url = {http://scg.unibe.ch/archive/papers/Girb04dEntitiesChangeTogether.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Girb04dEntitiesChangeTogether.pdf}}

@inproceedings{Girb05a,
	Abstract = {Analyzing historical information can show how a
				  software system evolved into its current state,
				  which parts of the system are stable and which have
				  changed more. However, historical analysis implies
				  processing a vast amount of information making the
				  interpretation of the results difficult. To address
				  this issue, we introduce the notion of the history
				  of source code artifacts as a first class entity and
				  define measurements which summarize the evolution of
				  such entities. We use these measurements to define
				  rules by which to detect different characteristics
				  of the evolution of class hierarchies. Furthermore,
				  we discuss the results we obtained by visualizing
				  them using a polymetric view. We apply our approach
				  on two large open source case studies and classify
				  their class hierarchies based on their history.},
	Acceptnum = {33},
	Accepttotal = {81},
	Address = {Los Alamitos CA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Tudor G\^irba and Michele Lanza and St\'ephane Ducasse},
	Booktitle = {Proceedings of 9th European Conference on Software Maintenance and Reengineering (CSMR'05)},
	Doi = {10.1109/CSMR.2005.15},
	Inria = {hors},
	Keywords = {scg-pub evolution visualization metrics van recast05 girba stefPub scg-none jb05 moose-pub},
	Misc = {acceptance rate: 33/81 = 41 \%},
	Pages = {2--11},
	Publisher = {IEEE Computer Society},
	Rate = {41%},
	Selectif = {non},
	Title = {Characterizing the Evolution of Class Hierarchies},
	Url = {http://scg.unibe.ch/archive/papers/Girb05aHierarchiesEvolution.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Girb05aHierarchiesEvolution.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/CSMR.2005.15}}

@inproceedings{Girb05c,
	Abstract = {As systems evolve their structure change in ways not
				  expected upfront. As time goes by, the knowledge of
				  the developers becomes more and more critical for
				  the process of understanding the system. That is,
				  when we want to understand a certain issue of the
				  system we ask the knowledgeable developers. Yet, in
				  large systems, not every developer is knowledgeable
				  in all the details of the system. Thus, we would
				  want to know which developer is knowledgeable in the
				  issue at hand. In this paper we make use of the
				  mapping between the changes and the author
				  identifiers (e.g., user names) provided by
				  versioning repositories. We first define a
				  measurement for the notion of code ownership. We use
				  this measurement to define the Ownership Map
				  visualization to understand when and how different
				  developers interacted in which way and in which part
				  of the system. We report the results we obtained on
				  several large systems.},
	Acceptnum = {13},
	Accepttotal = {54},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalworkshop},
	Author = {Tudor G\^irba and Adrian Kuhn and Mauricio Seeberger and St\'ephane Ducasse},
	Booktitle = {Proceedings of International Workshop on Principles of Software Evolution (IWPSE 2005)},
	Cvs = {ChroniaIWPSE2005},
	Doi = {10.1109/IWPSE.2005.21},
	Inria = {hors},
	Keywords = {scg-pub evolution visualization authors stefPub girba recast06 scg-none jb06 moose-pub chronia akuhn},
	Location = {Lisbon, Portugal},
	Misc = {acceptance rate: 13/54 = 24\%},
	Pages = {113--122},
	Publisher = {IEEE Computer Society Press},
	Rate = {24%},
	Selectif = {oui},
	Title = {How Developers Drive Software Evolution},
	Url = {http://scg.unibe.ch/archive/papers/Girb05cOwnershipMap.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Girb05cOwnershipMap.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/IWPSE.2005.21}}

@article{Girb06a,
	Abstract = {The histories of software systems hold useful
				  information when reasoning about the systems at hand
				  or when reasoning about general laws of software
				  evolution. Over the past 30 years more and more
				  research has been spent on understanding software
				  evolution. However, the approaches developed so far
				  do not rely on an explicit meta-model, and thus,
				  they make it difficult to reuse or compare their
				  results. We argue that there is a need for an
				  explicit meta-model for software evolution analysis.
				  We present a survey of the evolution analyses and
				  deduce a set of requirements that an evolution
				  meta-model should have. We define, Hismo, a
				  meta-model in which history is modeled as an
				  explicit entity. Hismo adds a time layer on top of
				  structural information, and provides a common
				  infrastructure for expressing and combining
				  evolution analyses and structural analyses. We
				  validate the usefulness of our a meta-model by
				  presenting how different analyses are expressed on
				  it.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Tudor G\^irba and St\'ephane Ducasse},
	Impactfactor = {0.457 (SCI 2005)},
	Inria = {hors},
	Journal = {Journal of Software Maintenance: Research and Practice (JSME)},
	Keywords = {hasler07 scg-pub skip-doi recast06 scg-none jb06 stefPub mooseCincom moose-pub van girba snf-actsc norex06 meta-modeling hismo evolution},
	Misc = {SCI impact factor 0.457 (2005)},
	Pages = {207--236},
	Publisher = {John Wiley and Sons, Ltd.},
	Selectif = {non},
	Title = {Modeling History to Analyze Software Evolution},
	Url = {http://scg.unibe.ch/archive/papers/Girb06aHismo.pdf},
	Volume = {18},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Girb06aHismo.pdf}}

@inproceedings{Girb07a,
	Abstract = {Software systems need to change over time to cope
				  with new requirements, and due to design decisions,
				  the changes happen to crosscut the system's
				  structure. Understanding how changes appear in the
				  system can reveal hidden dependencies between
				  different entities of the system. We propose the
				  usage of concept analysis to identify groups of
				  entities that change in the same way and in the same
				  time. We apply our approach at different levels of
				  abstraction (i.e., method, class, package) and we
				  detect fine grained changes (i.e., statements were
				  added in a class, but no method was added there).
				  Concept analysis is a technique that identifies
				  entities that have the same properties, but it
				  requires manual inspection due to the large number
				  of candidates it detects. We propose a heuristic
				  that dramatically eliminate the false positives. We
				  apply our approach on two case studies and we show
				  how we can identify hidden dependencies and detect
				  bad smells.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalworkshop},
	Author = {Tudor G\^irba and St\'ephane Ducasse and Adrian Kuhn and Radu Marinescu and Daniel Ra\c{t}iu},
	Booktitle = {Proceedings of International Workshop on Principles of Software Evolution (IWPSE 2007)},
	Doi = {10.1145/1294948.1294970},
	Inria = {hors},
	Isbn = {978-1-59593-722-3},
	Keywords = {scg07 scg-pub snf-none evolution fca girba jb08 metrics moose-pub norex07 stefPub akuhn},
	Medium = {2},
	Pages = {83--89},
	Peerreview = {yes},
	Publisher = {ACM Press},
	Selectif = {non},
	Title = {Using Concept Analysis to Detect Co-Change Patterns},
	Url = {http://scg.unibe.ch/archive/papers/Girb07aCoChangePatterns.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Girb07aCoChangePatterns.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1294948.1294970}}

@inproceedings{Girb15b,
	Abstract = {A picture tells a thousand words. We all know that. Then why are our development tools showing mainly text with so much obstinacy? Even when visualizations do make it into our tools, they typically do not make it past the periphery. Something is deeply wrong. We argue that visualizations must become pervasive in software development, and to accommodate this goal, the integrated development environments must change significantly.},
	Author = {G\^irba, Tudor and Chi\c{s}, Andrei},
	Booktitle = {Proceedings of 3rd IEEE Working Conference on Software Visualization},
	pages = {1--5},
	Publisher = {{IEEE}},
	Series = {VISSOFT'15},
	Title = {{Pervasive Software Visualizations}},
	Doi={10.1109/VISSOFT.2015.7332409},
	peerReview = {yes},
	medium = {2},
	month=sep,
	Year = {2015},
	keywords = {scg-pub scg15 jb16 snf-asa1, Andrei Chis, Tudor Girba, girba},
	url = {http://scg.unibe.ch/archive/papers/Girb15b-PervasiveSoftwareVisualizations.pdf}}

@article{Gobl16a,
  author =	{Carole Goble and James Howison and Claude Kirchner and Oscar Nierstrasz and Jurgen J. Vinju},
  title =	{{Engineering Academic Software (Dagstuhl Perspectives Workshop 16252)}},
  abstract = {This report documents the program and the outcomes of Dagstuhl Perspectives Workshop 16252 ``Engineering Academic Software''.},
  pages =	{62--87},
  journal =	{Dagstuhl Reports},
  ISSN =	{2192-5283},
  year =	{2016},
  volume =	{6},
  number =	{6},
  editor =	{},
  publisher =	{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{http://drops.dagstuhl.de/opus/volltexte/2016/6755},
  URN =		{urn:nbn:de:0030-drops-67557},
  doi =		{10.4230/DagRep.6.6.62},
  annote =	{Keywords: Scientific Software, Data Science, Software Engineering},
  PeerReview = {no},
  Medium = {1},
  Url = {http://scg.unibe.ch/archive/papers/Gobl16a.pdf},
  keywords = {scg-pub snf-none scg16 jb17}
}

@misc{Gonz04a,
	Abstract = {This report covers the activities of the 2nd
				  workshop on "Object-Oriented Language Engineering
				  for the Post-Java Era". We describe the motivation
				  that led to the organisation of a second edition of
				  the workshop. Relevant organisational aspects are
				  mentioned. The main part of the report consists of a
				  summary of Dave Thomas's invited talk, and a recount
				  of the presentations by the authors of position
				  papers. Comments given along the way by the
				  participants are included. Finally, some pointers to
				  related work and events are given.},
	Annote = {workshopproceedings},
	Author = {Sebastian Gonzales and Wolgang Demeuter and Pascal Costanza and St\'ephane Ducasse and Richard Gabriel and Theo D'hondt},
	Booktitle = {Object-Oriented Technology (ECOOP'04 Workshop Reader)},
	Keywords = {scg-pub skip-doi scg-none jb04 stefPub recast04},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Report of the {ECOOP}'03 Workshop on Object-Oriented Language Engineering in Post-Java Era},
	Url = {http://scg.unibe.ch/archive/papers/Gonz04aoolepje04-report.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gonz04aoolepje04-report.pdf}}

@inproceedings{Gree05a,
	Abstract = {Software developers are constantly required to
				  modify and adapt features of an application in
				  response to changing requirements. The problem is
				  that just by reading the source code, it is
				  difficult to determine how classes and methods
				  contribute to the runtime behavior of features.
				  Moreover, dependencies between system features are
				  not obvious, consequently software maintenance
				  operations often result in unintended side effects.
				  To tackle these problems, we propose a compact
				  feature-driven approach (\ie summarized trace
				  information) based on dynamic analysis to
				  characterize features and computational units of an
				  application. We extract execution traces to achieve
				  an explicit mapping between features and classes
				  using two complementary perspectives. We apply our
				  approach to two case studies and we report our
				  findings.},
	Acceptnum = {33},
	Accepttotal = {81},
	Address = {Los Alamitos CA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Orla Greevy and St\'ephane Ducasse},
	Booktitle = {Proceedings of 9th European Conference on Software Maintenance and Reengineering (CSMR'05)},
	Cvs = {TraceScraperRevEng},
	Doi = {10.1109/CSMR.2005.21},
	Inria = {hors},
	Keywords = {scg-pub greevy scg-none jb05 recast05 stefPub Feature Feature-Traces Dynamic Analysis Evolution moose-pub},
	Location = {Manchester, United Kingdom},
	Misc = {acceptance rate: 33/81 = 41\%},
	Pages = {314--323},
	Publisher = {IEEE Computer Society},
	Rate = {41%},
	Selectif = {non},
	Title = {Correlating Features and Code Using A Compact Two-Sided Trace Analysis Approach},
	Url = {http://scg.unibe.ch/archive/papers/Gree05aTraceScraperCSMR2005Features.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gree05aTraceScraperCSMR2005Features.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/CSMR.2005.21}}

@inproceedings{Gree05b,
	Abstract = {Software developers are often faced with the task of
				  maintaining or extending large and complex
				  applications, with which they are unfamiliar.
				  Typically change requests and bug reports are
				  expressed in terms of system features. Much of the
				  maintenance effort is spent trying to identify which
				  classes and methods provide functionality to
				  individual features. To tackle this problem, we
				  propose an approach based on dynamic analysis that
				  exploits the relationship between features and
				  software entities. Our definition of a feature is a
				  unit of observable behavior of a software system. We
				  apply our approach to a large open source
				  application and identify key classes and methods
				  which provide functionality to individual features.},
	Annote = {internationalworkshop},
	Author = {Orla Greevy and St\'ephane Ducasse},
	Booktitle = {Proceedings of WOOR 2005 (6th International Workshop on Object-Oriented Reengineering)},
	Cvs = {TraceScraperWOOR2005},
	Keywords = {scg-pub skip-doi greevy scg-none jb06 stefPub Feature Feature-Traces Dynamic Analysis Evolution moose-pub recast05},
	Month = jul,
	Title = {Characterizing the Functional Roles of Classes and Methods by Analyzing Feature Traces},
	Url = {http://scg.unibe.ch/archive/papers/Gree05bTraceScraperWOOR2005.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gree05bTraceScraperWOOR2005.pdf}}

@inproceedings{Gree05c,
	Abstract = {Many of the approaches that analyze software
				  evolution consider a static perspective of a system.
				  Static analysis approaches focus on the evolution of
				  static software entities such as packages, classes
				  and methods. Without knowledge of the roles software
				  entities play in system features, it is difficult to
				  interpret the motivation behind changes and
				  extensions in the code. To tackle this problem, we
				  propose an approach to software evolution analysis
				  that exploits the relationships between features and
				  software entities. Our definition of a feature is a
				  unit of observable behavior of a software system. We
				  define history measurements that summarize the
				  evolution of software entities from a feature
				  perspective. We show how we use our feature
				  perspective of software evolution to interpret
				  modifications and extensions to the code. We apply
				  our approach on two case studies and discuss our
				  findings.},
	Acceptnum = {55},
	Accepttotal = {180},
	Address = {Los Alamitos},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Orla Greevy and St\'ephane Ducasse and Tudor G\^irba},
	Booktitle = {Proceedings of 21st IEEE International Conference on Software Maintenance (ICSM'05)},
	Cvs = {TraceScraperICSM2005Evolution},
	Doi = {10.1109/ICSM.2005.22},
	Inria = {hors},
	Keywords = {scg-pub girba greevy scg-none jb06 stefPub Features Feature-Traces Dynamic-Analysis Evolution history moose-pub recast06 listic},
	Misc = {acceptance rate: 55/180 = 31\%},
	Month = sep,
	Pages = {347--356},
	Publisher = {IEEE Computer Society},
	Rate = {31%},
	Selectif = {oui},
	Title = {Analyzing Feature Traces to Incorporate the Semantics of Change in Software Evolution Analysis},
	Url = {http://scg.unibe.ch/archive/papers/Gree05cTraceScraperICSM2005.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gree05cTraceScraperICSM2005.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICSM.2005.22}}

@inproceedings{Gree05d,
	Abstract = {Without a clear understanding of how features of a
				  software system are implemented, a maintenance
				  change in one part of the code may risk adversely
				  affecting other features. Feature implementation and
				  relationships between features are not explicit in
				  the code. To address this problem, we propose an
				  interactive 3D visualization technique based on a
				  combination of static and dynamic analysis which
				  enables the software developer to step through
				  visual representations of execution traces. We
				  visualize dynamic behaviors of execution traces in
				  terms of object creations and interactions and
				  represent this in the context of a static
				  class-hierarchy view of a system. We describe how we
				  apply our approach to a case study to visualize and
				  identify common parts of the code that are active
				  during feature execution.},
	Annote = {internationalworkshop},
	Author = {Orla Greevy and Michele Lanza and Christoph Wysseier},
	Booktitle = {Proceedings of {VISSOFT} 2005 (3th IEEE International Workshop on Visualizing Software for Understanding)},
	Cvs = {TraceCrawlerVissoft2005},
	Keywords = {scg-pub skip-doi greevy scg-none jb06 Feature Feature-Traces Dynamic Analysis Evolution moose-pub recast06},
	Month = sep,
	Pages = {114--119},
	Title = {Visualizing Feature Interaction in {3-D}},
	Url = {http://scg.unibe.ch/archive/papers/Gree05dTraceCrawlerVissoft2005.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gree05dTraceCrawlerVissoft2005.pdf}}

@inproceedings{Gree05e,
	Annote = {internationalconference},
	Author = {Orla Greevy and Abdelwahab Hamou-Lhadj and Andy Zaidman},
	Booktitle = {12th Working Conference on Software Maintenance and Reengineering (WCRE 2005)},
	Doi = {10.1109/WCRE.2005.35},
	Keywords = {scg-pub skip-abstract greevy scg-none jb06 Dynamic Analysis moose-pub recast07},
	Month = sep,
	Pages = {232--232},
	Title = {Workshop on Program Comprehension through Dynamic Analysis ({PCODA})},
	Url = {http://www.lore.ua.ac.be/Events/PCODA2005/index.html http://www.lore.ua.ac.be/Events/PCODA2005/PCODA2005proceedings.pdf http://scg.unibe.ch/archive/papers/Gree05e-pcoda2005proceedings.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://www.lore.ua.ac.be/Events/PCODA2005/index.html%20http://www.lore.ua.ac.be/Events/PCODA2005/PCODA2005proceedings.pdf%20http://scg.unibe.ch/archive/papers/Gree05e-pcoda2005proceedings.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.2005.35}}

@inproceedings{Gree06a,
	Abstract = {The analysis of the runtime behavior of a software
				  system yields vast amounts of information, making
				  accurate interpretations difficult. Filtering or
				  compression techniques are often applied to reduce
				  the volume of data without loss of key information
				  vital for a specific analysis goal. Alternatively,
				  visualization is generally accepted as a means of
				  effectively representing large amounts of data. The
				  challenge lies in creating effective and expressive
				  visual representations that not only allows for a
				  global picture, but also enables us to inspect the
				  details of the large data sets. We define the focus
				  of our analysis to be the runtime behavior of
				  features. Static structural visualizations of a
				  system are typically represented in two dimensions.
				  We exploit a third dimension to visually represent
				  the dynamic information, namely object
				  instantiations and message sends. We introduce a
				  novel 3D visualization technique that supports
				  animation of feature behavior and integrates
				  zooming, panning, rotating and on-demand details. As
				  proof of concept, we apply our visualization
				  technique to feature execution traces of an example
				  system.},
	Annote = {internationalconference},
	Author = {Orla Greevy and Michele Lanza and Christoph Wysseier},
	Booktitle = {Proceedings of SoftVis 2006 (ACM Symposium on Software Visualization)},
	Cvs = {TraceCrawlerSoftVis2006},
	Doi = {10.1145/1148493.1148501},
	Keywords = {scg-pub greevy scg-none jb07 fb06 Feature Feature-Traces Dynamic Analysis 3D moose-pub recast07},
	Medium = {2},
	Month = sep,
	Peerreview = {yes},
	Title = {Visualizing live Software Systems in 3{D}},
	Url = {http://scg.unibe.ch/archive/papers/Gree06aTraceCrawlerSoftVis2006.pdf},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gree06aTraceCrawlerSoftVis2006.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1148493.1148501}}

@article{Gree06b,
	Abstract = {Features encapsulate the domain knowledge of a
				  software system and thus are valuable sources of
				  information for a reverse engineer. When analyzing
				  the evolution of a system, we need to know how and
				  which features were modified to recover both the
				  change intention and its extent, namely which source
				  artifacts are affected. Typically, the
				  implementation of a feature crosscuts a number of
				  source artifacts. To obtain a mapping between
				  features to the source artifacts, we exercise the
				  features and capture their execution traces. However
				  this results in large traces that are difficult to
				  interpret. To tackle this issue we compact the
				  traces into simple sets of source artifacts that
				  participate in a feature's runtime behavior. We
				  refer to these compacted traces as feature views.
				  Within a feature view, we partition the source
				  artifacts into disjoint sets of characterized
				  software entities. The characterization defines the
				  level of participation of a source entity in the
				  features. We then analyze the features over several
				  versions of a system and we plot their evolution to
				  reveal how and hich features were affected by
				  changes in the code. We show the usefulness of our
				  approach by applying it to a case study where we
				  address the problem of merging parallel development
				  tracks of the same system.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Orla Greevy and St\'ephane Ducasse and Tudor G\^irba},
	Doi = {10.1002/smr.340},
	Impactfactor = {0.606, SCI 2002-2004},
	Inria = {hors},
	Journal = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
	Keywords = {scg-pub recast07 snf07 scg-none jb07 fb06 stefPub girba mooseCincom dynamic-analysis feature evolution moose-pub},
	Medium = {2},
	Misc = {SCI impact factor 0.606 (2002-2004)},
	Number = {6},
	Pages = {425--456},
	Peerreview = {yes},
	Selectif = {non},
	Title = {Analyzing Software Evolution through Feature Views},
	Url = {http://scg.unibe.ch/archive/papers/Gree06bTraceScraperJSME-SCG.pdf},
	Volume = {18},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gree06bTraceScraperJSME-SCG.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1002/smr.340}}

@inproceedings{Gree07a,
	Abstract = {Software systems are typically developed by teams of
				  developers, with responsibilities for different
				  parts of the code. Knowledge of how the developers
				  collaborate, and how their responsibilities are
				  distributed over the software artifacts is a
				  valuable source of information when reverse
				  engineering a system. Determining which developers
				  are responsible for which software artifacts (\eg
				  packages or classes) is just one perspective. In
				  this paper we complement the static perspective with
				  the dynamic perspective of a system in terms of its
				  features. We want to extract information about which
				  developers are responsible for which features. To
				  achieve these two perspectives, we correlate
				  developer responsibilities both with a structural
				  view of the system and with a feature view. We
				  identify which developers are responsible for which
				  features, and whether the responsibilities
				  correspond with structural source code artifacts or
				  with features. We apply our technique to two
				  software projects developed by two teams of students
				  as part of their course work, and to one large open
				  source project.},
	Acceptnum = {38},
	Accepttotal = {132},
	Address = {Los Alamitos CA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Orla Greevy and Tudor G\^irba and St\'ephane Ducasse},
	Booktitle = {Proceedings of 11th European Conference on Software Maintenance and Reengineering (CSMR 2007)},
	Cvs = {TraceScraperCSMR2007},
	Doi = {10.1109/CSMR.2007.27},
	Inria = {hors},
	Isbn = {0-7695-2802-3},
	Issn = {1534-5351},
	Keywords = {scg07 scg-pub greevy jb07 stefPub snf07 moose-pub authors features evolution dynamic-analysis girba},
	Medium = {2},
	Misc = {Acceptance rate: 38/132=29\%},
	Pages = {256--274},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Rate = {29%},
	Selectif = {oui},
	Title = {How Developers Develop Features},
	Url = {http://scg.unibe.ch/archive/papers/Gree07aDevelopersDevelopFeatures.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gree07aDevelopersDevelopFeatures.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/CSMR.2007.27}}

@inproceedings{Gree07c,
	Abstract = {Many researchers have identified the potential of
				  exploiting domain knowledge in a reverse engineering
				  context. Features are abstractions that encapsulate
				  knowledge of a problem domain and denote units of
				  system behavior. As such, they represent a valuable
				  resource for reverse engineering a system. The main
				  body of feature-related reverse engineering research
				  is concerned with feature identification, a
				  technique to map features to source code. To fully
				  exploit features in reverse engineering, however, we
				  need to extend the focus beyond feature
				  identification and exploit features as primary units
				  of analysis. To incorporate features into reverse
				  engineering analyses, we need to explicitly model
				  features, their relationships to source artefacts,
				  and their relationships to each other. To address
				  this we propose Dynamix, am meta--model that
				  expresses feature entities in the context of a
				  structural meta-model of source code entities. Our
				  meta-model supports feature-centric reverse
				  engineering techniques that establish traceability
				  between the problem and solution domains throughout
				  the life-cycle of a system.},
	Annote = {internationalworkshop},
	Author = {Orla Greevy},
	Booktitle = {Proceedings of FAMOOSr 2007 (Ist International Workshop on FAMIX and Moose in Reengineering)},
	Keywords = {scg07 scg-pub snf07 skip-doi greevy jb07 Feature Feature-Traces Dynamic Analysis Evolution moose-pub},
	Medium = {2},
	Month = jun,
	Peerreview = {yes},
	Title = {Dynamix --- a Meta-Model to Support Feature-Centric Analysis},
	Url = {http://scg.unibe.ch/archive/papers/Gree07cDynamixFAMOOSr2007.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gree07cDynamixFAMOOSr2007.pdf}}

@inproceedings{Gysi10a,
	Abstract = {Search is a fundamental activity in software
				  development. However, to search source code
				  efficiently, it is not sufficient to implement a
				  traditional full text search over a base of source
				  code, human factors have to be taken into account as
				  well. We looked into ways of increasing the search
				  results code trustability by providing and analysing
				  a range of meta data alongside the actual search
				  results.},
	Annote = {internationalconference},
	Author = {Florian S. Gysin},
	Booktitle = {Proceedings International Conference on Software Engineering, ICSE '10, Student Research Competition},
	Doi = {10.1145/1810295.1810457},
	Keywords = {codesearch scg-pub scg10 jb10 snf10},
	Medium = {2},
	Peerreview = {yes},
	Title = {Improved Social Trustability of Code Search Results},
	Url = {http://scg.unibe.ch/archive/papers/Gysi10a.pdf},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gysi10a.pdf}}

@inproceedings{Gysi10b,
	Abstract = {The promise of search-driven development is that
				  developers will save time and resources by reusing
				  external code in their local projects. To
				  efficiently integrate this code, users must be able
				  to trust it, thus trustability of code search
				  results is just as important as their relevance. In
				  this paper, we introduce a trustability metric to
				  help users assess the quality of code search results
				  and therefore ease the cost-benefit analysis they
				  undertake trying to find suitable integration
				  candidates. The proposed trustability metric
				  incorporates both user votes and cross-project
				  activity of developers to calculate a "karma" value
				  for each developer. Through the karma value of all
				  its developers a project is ranked on a trustability
				  scale. We present JBENDER, a proof-of-concept code
				  search engine which implements our trustability
				  metric and we discuss preliminary results from an
				  evaluation of the prototype.},
	Annote = {internationalworkshop},
	Author = {Florian S. Gysin and Adrian Kuhn},
	Booktitle = {ICSE Workshop on Search-Driven Development-Users, Infrastructure, Tools and Evaluation, 2010. SUITE '10.},
	Doi = {10.1145/1809175.1809186},
	Keywords = {codesearch, scg-pub scg10, akuhn-pub, suite2010 jb10 snf10},
	Medium = {2},
	Peerreview = {yes},
	Title = {A Trustability Metric for Code Search based on Developer Karma},
	Url = {http://scg.unibe.ch/archive/papers/Gysi10b.pdf},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Gysi10b.pdf}}

@inproceedings{Haen08b,
	Abstract = {When changing the API of a framework, we need to
				  migrate its clients. This is best done
				  automatically. In this paper, we focus on API
				  migration where the mechanism for inversion of
				  control changes. We propose to use dynamic analysis
				  for such API migration since structural refactorings
				  alone are often not sufficient. We consider JExample
				  as a case-study. JExample extends JUnit with
				  first-class dependencies and fixture injection. We
				  investigate how dynamically collected information
				  about test coverage and about instances under test
				  can be used to detect dependency injection
				  candidates.},
	Annote = {internationalworkshop},
	Author = {Lea H\"ansenberger and Adrian Kuhn and Oscar Nierstrasz},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Haen08bAPImigration.pdf http://swerl.tudelft.nl/bin/view/PCODA/PCODA2008#Proceedings},
	Booktitle = {Proceedings IEEE Workshop on Program Comprehension through Dynamic Analysis (PCODA 2008)},
	Keywords = {scg08 scg-pub skip-doi snf09 jb09 fb08 akuhn haensenberger},
	Medium = {2},
	Month = oct,
	Pages = {32--36},
	Peerreview = {yes},
	Title = {Using Dynamic Analysis for {API} Migration},
	url = {http://scg.unibe.ch/archive/papers/Haen08bAPImigration.pdf},
	url2 = {http://swerl.tudelft.nl/bin/view/PCODA/PCODA2008#Proceedings},
	Year = {2008},
	Bdsk-Url-2 = {http://scg.unibe.ch/archive/papers/Haen08bAPImigration.pdf%20http://swerl.tudelft.nl/bin/view/PCODA/PCODA2008#Proceedings}}

@inproceedings{Haen13a,
	Annote = {internationalworkshop},
	Abstract = {We present the results of an investigation into the nature of the information needs of software developers who work in projects that are part of larger ecosystems. In an open-question survey we asked framework and library developers about their information needs with respect to both their upstream and downstream projects. We investigated what kind of information is required, why is it necessary, and how the developers obtain this information.
	The results show that the downstream needs are grouped into three categories roughly corresponding to the different stages in their relation with an upstream: selection, adoption, and co-evolution. The less numerous upstream needs are grouped into two categories: project statistics and code usage.
	The current practices part of the study shows that to satisfy many of these needs developers use non-specific tools and ad hoc methods. We believe that this is a largely unexplored area of research.},
	Author = {Haenni, Nicole and Lungu, Mircea and Schwarz, Niko and Nierstrasz, Oscar},
	Booktitle = {Proceedings of the 1st Workshop on Ecosystem Architectures},
	Keywords = {ecosystems scg-pub snf-asa1 scg13 skip-doi jb14 dev-questions},
	Medium = {2},
	Pages = {1--5},
	Peerreview = {yes},
	Title = {Categorizing Developer Information Needs in Software Ecosystems},
	Url = {http://scg.unibe.ch/archive/papers/Haen13a-EcosystemInformationNeeds.pdf},
	Year = {2013},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Haen13a-EcosystemInformationNeeds.pdf}}

@inproceedings{Haen14a,
	Annote = {internationalworkshop},
	Abstract = {We present the results of an investigation into the nature of information needs of software developers who work in projects that are part of larger ecosystems. This work is based on a quantitative survey of 75 professional software developers. We corroborate the results identified in the sur- vey with needs and motivations proposed in a previous sur- vey and discover that tool support for developers working in an ecosystem context is even more meager than we thought: mailing lists and internet search are the most popular tools developers use to satisfy their ecosystem-related information needs.},
	Author = {Haenni, Nicole and Lungu, Mircea and Schwarz, Niko and Nierstrasz, Oscar},
	Booktitle = {Proceedings of the 2nd Workshop on Ecosystem Architectures (WEA'14)},
	Keywords = {ecosystems scg-pub snf-asa1 scg14 jb14 dev-questions},
	Medium = {2},
	Pages = {1--6},
	Peerreview = {yes},
	Title = {A Quantitative Analysis of Developer Information Needs in Software Ecosystems},
	Url = {http://scg.unibe.ch/archive/papers/Haen14a-QuantitativeEcosystemInformationNeeds.pdf},
	Doi = {10.1145/2642803.2642815},
	Year = {2014},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Haen14a-QuantitativeEcosystemInformationNeeds.pdf}}

@inproceedings{Hald07b,
	Abstract = {Most languages fall into one of two camps: either
				  they adopt a unique, static type system, or they
				  abandon static type-checks for run-time checks.
				  Pluggable types blur this division by (i) making
				  static type systems optional, and (ii) supporting a
				  choice of type systems for reasoning about different
				  kinds of static properties. Dynamic languages can
				  then benefit from static-checking without
				  sacrificing dynamic features or committing to a
				  unique, static type system. But the overhead of
				  adopting pluggable types can be very high,
				  especially if all existing code must be decorated
				  with type annotations before any type-checking can
				  be performed. We propose a practical and pragmatic
				  approach to introduce pluggable type systems to
				  dynamic languages. First of all, only annotated code
				  is type-checked. Second, limited type inference is
				  performed on unannotated code to reduce the number
				  of reported errors. Finally, external annotations
				  can be used to type third-party code. We present
				  Typeplug, a Smalltalk implementation of our
				  framework, and report on experience applying the
				  framework to three different pluggable type
				  systems.},
	Annote = {internationalconference},
	Author = {Niklaus Haldimann and Marcus Denker and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 2007 International Conference on Dynamic Languages (ICDL 2007)},
	Doi = {10.1145/1352678.1352690},
	Isbn = {978-1-60558-084-5},
	Keywords = {scg07 scg-pub jb08 snf07 reflectivity},
	Medium = {2},
	Pages = {183--204},
	Peerreview = {yes},
	Publisher = {ACM Digital Library},
	Title = {Practical, Pluggable Types},
	Url = {http://scg.unibe.ch/archive/papers/Hald07b-Typeplug.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Hald07b-Typeplug.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1352678.1352690}}

@article{Hald09a,
	Abstract = {Most languages fall into one of two camps: either
				  they adopt a unique, static type system, or they
				  abandon static type-checks for run-time checks.
				  Pluggable types blur this division by (i) making
				  static type systems optional, and (ii) supporting a
				  choice of type systems for reasoning about different
				  kinds of static properties. Dynamic languages can
				  then benefit from static-checking without
				  sacrificing dynamic features or committing to a
				  unique, static type system. But the overhead of
				  adopting pluggable types can be very high,
				  especially if all existing code must be decorated
				  with type annotations before any type-checking can
				  be performed. We propose a practical and pragmatic
				  approach to introduce pluggable type systems to
				  dynamic languages. First of all, only annotated code
				  is type-checked. Second, limited type inference is
				  performed on unannotated code to reduce the number
				  of reported errors. Finally, external annotations
				  can be used to type third-party code. We present
				  Typeplug, a Smalltalk implementation of our
				  framework, and report on experience applying the
				  framework to three different pluggable type
				  systems.},
	Annote = {internationaljournal},
	Author = {Niklaus Haldimann and Marcus Denker and Oscar Nierstrasz},
	Doi = {10.1016/j.cl.2008.06.003},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {scg09 scg-pub jb08 snf08 reflectivity},
	Medium = {2},
	Misc = {was: Hald08a},
	Month = apr,
	Number = {1},
	Pages = {48--64},
	Peerreview = {yes},
	Publisher = {Elsevier},
	Title = {Practical, Pluggable Types for a Dynamic Language},
	Url = {http://scg.unibe.ch/archive/papers/Hald08aTypeplug.pdf},
	Volume = {35},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Hald08aTypeplug.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.cl.2008.06.003}}

@inproceedings{Hamo07a,
	Annote = {internationalconference},
	Author = {Abdelwahab Hamou-Lhadj and Andy Zaidman and Orla Greevy},
	Booktitle = {Proceedings of IEEE 14th Working Conference on Software Maintenance and Reengineering (WCRE)},
	Doi = {10.1109/WCRE.2007.53},
	Keywords = {scg07 scg-pub skip-abstract greevy jb08 snf07},
	Medium = {2},
	Month = oct,
	Pages = {298--298},
	Peerreview = {yes},
	Title = {Workshop on Program Comprehension through Dynamic Analysis ({PCODA})},
	Url = {http://scg.unibe.ch/archive/papers/Hamo07a-pcoda2007proceedings.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Hamo07a-pcoda2007proceedings.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.2007.53}}

@inproceedings{Hamo10a,
	Annote = {internationalconference},
	Author = {Abdelwahab Hamou-Lhadj and David R\"othlisberger and Andy Zaidman and Orla Greevy},
	Booktitle = {Proceedings of IEEE 17th Working Conference on Software Maintenance and Reengineering (WCRE)},
	Doi = {10.1109/WCRE.2010.40},
	Keywords = {scg-pub scg10 skip-abstract greevy roethlisberger jb10 snf10 Dynamic Analysis},
	Medium = {2},
	Month = oct,
	Peerreview = {yes},
	Title = {Workshop on Program Comprehension through Dynamic Analysis ({PCODA})},
	Url = {http://scg.unibe.ch/archive/papers/Hamo10aPCODA2010.pdf},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Hamo10aPCODA2010.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.2010.40}}

@inproceedings{Hatt10a,
	Abstract = {What was I working on before the weekend? and What
				  were the members of my team working on during the
				  last week? are common questions that are frequently
				  asked by a developer. They can be answered if one
				  keeps track of who changes what in the source code.
				  In this work, we present Replay, a tool that allows
				  one to replay past changes as they happened at a
				  fine-grained level, where a developer can watch what
				  she has done or understand what her colleagues have
				  done in past development sessions. With this tool,
				  developers are able to not only understand what
				  sequence of changes brought the system to a certain
				  state (e.g., the introduction of a defect), but also
				  deduce reasons for why her colleagues performed
				  those changes. One of the applications of such a
				  tool is also discovering the changes that broke the
				  code of a developer.},
	Annote = {internationalworkshop},
	Author = {Lile Hattori and Mircea Lungu and Michele Lanza},
	Booktitle = {Proceedings of the Joint ERCIM Workshop on Software Evolution (EVOL) and International Workshop on Principles of Software Evolution (IWPSE)},
	Doi = {10.1145/1862372.1862379},
	Keywords = {lungu scg-pub snf-no jb11 scg10},
	Medium = {2},
	Month = oct,
	Pages = {13--22},
	Peerreview = {yes},
	Title = {Replaying past changes in multi-developer projects},
	Url = {http://www.inf.usi.ch/faculty/lanza/Downloads/Hatt2010c.pdf},
	Year = {2010},
	Bdsk-Url-1 = {http://www.inf.usi.ch/faculty/lanza/Downloads/Hatt2010c.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1862372.1862379}}

@inproceedings{Hatt11a,
	Abstract = {Developers often need to find answers to questions regarding the evolution of a system when working on its
  code base. While their information needs require data analysis spanning over different repository types, the source code
  repository has a pivotal role for program comprehension tasks. However, the coarse-grained nature of the data stored by
  commit-based software configuration management systems often makes it challenging for a developer to search for an answer.
  We present Replay, an Eclipse plug-in that allows one to explore the change history of a system by capturing the changes
  at a finer granularity level than commits, and by replaying the past changes chronologically inside the integrated
  development environment with the source code at hand. We conducted a controlled experiment to empirically assess whether
  Replay outperforms a baseline (SVN client in Eclipse) on helping developers to answer common questions related to software
  evolution. The experiment shows that Replay leads to a decrease in completion time with respect to a set of software
  evolution comprehension tasks.},
	Author = {Lile Hattori and Marco D'Ambros and Michele Lanza and Mircea Lungu},
	Booktitle = {Proceedings of the 19th International Conference on Program Comprehension},
	Doi = {10.1109/ICPC.2011.39},
	Keywords = {scg11 scg-pub jb12 snf11 ercim11},
	Medium = {2},
	Pages = {161-170},
	Peerreview = {Yes},
	Publisher = {IEEE Computer Society Press},
	Title = {Software Evolution Comprehension: Replay to the Rescue},
	Url = {http://inf.unisi.ch/faculty/lanza/Downloads/Hatt2011a.pdf},
	Year = {2011},
	Bdsk-Url-1 = {http://inf.unisi.ch/faculty/lanza/Downloads/Hatt2011a.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICPC.2011.39}}

@article{Hatt13a,
	Abstract = {Developers often need to find answers to questions regarding the evolution of a system when working on its code	 base. While their information needs require data analysis pertaining to different repository types, the source code repository	has a pivotal role for program comprehension tasks. However, the coarse-grained nature of the data stored by commit-based software configuration management systems often makes it challenging for a developer to search for an answer.We present Replay, an Eclipse plug-in that allows developers to explore the change history of a system by capturing the changes at a finer granularity level than commits, and by replaying the past changes chronologically inside the integrated development environment, with the source code at hand.},
	Author = {Lile Hattori and Marco D'Ambros and Michele Lanza and Mircea Lungu},
	Doi = {10.1016/j.infsof.2012.09.001},
	Issn = {0950-5849},
	Journal = {Information and Software Technology},
	Keywords = {scg-pub snf12 jb13 scg13 Software evolution Empirical evaluation Controlled experiment},
	Medium = {2},
	Month = {jan},
	Number = {4},
	Pages = {755 - 775},
	Peerreview = {yes},
	Title = {Answering software evolution questions: {An} empirical evaluation},
	Url = {http://www.sciencedirect.com/science/article/pii/S095058491200184X},
	Volume = {55},
	Year = {2013},
	Bdsk-Url-1 = {http://www.sciencedirect.com/science/article/pii/S095058491200184X},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.infsof.2012.09.001}}

@inproceedings{Haup07a,
	Abstract = {This position paper proposes the exploitation of
				  type feedback mechanisms, or more precisely,
				  polymorphic inline caches, for purely interpreting
				  implementations of object-oriented programming
				  languages. Using Squeak's virtual machine as an
				  example, polymorphic inline caches are discussed as
				  an alternative to global caching. An implementation
				  proposal for polymorphic inline caches in the Squeak
				  virtual machine is presented, and possible future
				  applications for online optimization are outlined.},
	Annote = {internationalworkshop},
	Author = {Michael Haupt and Robert Hirschfeld and Marcus Denker},
	Booktitle = {Proceedings of the Second Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS'2007), ECOOP Workshop},
	Issn = {1436-9915},
	Keywords = {scg07 scg-pub skip-doi jb08 snf07},
	Medium = {2},
	Month = jul,
	Pages = {17--22},
	Peerreview = {yes},
	Publisher = {TU Berlin},
	Title = {Type feedback for bytecode interpreters},
	Url = {http://scg.unibe.ch/archive/papers/Haup07aPIC.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Haup07aPIC.pdf}}

@inproceedings{Hazh18a,
	Author    = {Mohammadreza Hazhirpasand and Mohammad Ghafari},
	abstract = {WebRTC provides browsers and mobile apps with rich realtime
communications capabilities, without the need for further software
components. Recently, however, it has been shown that WebRTC can
be triggered to fingerprint a web visitor, which may compromise the
user's privacy. We evaluate the feasibility of exploiting a WebRTC IP
leak to scan a user's private network ports and IP addresses from outside
their local network. We propose a web-based network scanner that
is both browser- and network-independent, and performs nearly as well
as system-based scanners. We experiment with various popular mobile
and desktop browsers on several platforms and show that adversaries
not only can exploit WebRTC to identify the real user identity behind a
web request, but also can retrieve sensitive information about the user's
network infrastructure. We discuss the potential security and privacy
consequences of this issue and present a browser extension that we developed
to inform the user about the prospect of suspicious activities. },
	location = {Paris, France},
	Keywords = {scg-pub security snf-asa2 scg18 jb18},
	DOI = {10.1007/978-3-319-94496-8_5},
	Peerreview = {yes},
	Medium = {2},
	Booktitle = {International Symposium on Engineering Secure Software and Systems (ESSoS 2018)},
    Annote    = {internationalconference},
	Url = {http://scg.unibe.ch/archive/papers/Hazh18a.pdf},
	Title = {One Leak is Enough to Expose Them All --- From a {WebRTC} {IP} Leak to Web-based Network Scanning},
	Pages = {61--76},
	Year = {2018}
}

@inproceedings{Hazh18b,
 author = {Mohammadreza Hazhirpasand},
 title = {MHEye: A Hybrid Android Security Assessment Tool for Ordinary Users},
 abstract = {Android users are often overwhelmed by security
    issues arising in the apps they use. Although malware
    analysis tools exist, they are challenging to
    adopt for average users. To avoid burdening mobile
    devices with complex and computationally
    expensive malware tools, we propose a hybrid approach
    that combines static and dynamic analyses,
    and distributes the analysis mainly on another device
    than the phone. We first review the Android
    architecture and several of the key security issues
    it faces, and we summarize existing approaches to
    malware detection. We conclude with a research
    plan to explore and develop a more user-friendly
    approach to malware detection for ordinary users. },
 booktitle = {SATTOSE},
 Annote = {internationalworkshop},
 PeerReview = {yes},
 Medium = {1},
 Keywords = {scg-pub skip-doi snf-asa2 scg18 jb18},
 series = {SATToSE '18},
 publisher={SATToSE},
 year = {2018},
 Url = {http://scg.unibe.ch/archive/papers/Hazh18b.pdf}
}

@inproceedings{Hazh19a,
	author={M. {Hazhirpasand} and M. {Ghafari} and S. {Kr\"{u}ger} and E. {Bodden} and O. {Nierstrasz}},
	booktitle={2019 ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)},
	title={The Impact of Developer Experience in Using {Java} Cryptography},
	year={2019},
	pages={1-6},
	abstract={Background: Previous research has shown that crypto APIs are
		hard for developers to understand and difficult for them to use. They
		consequently rely on unvalidated boilerplate code from online resources
		where security vulnerabilities are common.Aims and method: We analyzed
		2,324 open-source Java projects that rely on Java Cryptography
		Architecture (JCA) to understand how crypto APIs are used in practice, and
		what factors account for the performance of developers in using these
		APIs.Results: We found that, in general, the experience of developers in
		using JCA does not correlate with their performance. In particular, none
		of the factors such as the number or frequency of committed lines of code,
		the number of JCA APIs developers use, or the number of projects they are
		involved in correlate with developer performance in this
		domain.Conclusions: We call for qualitative studies to shed light on the
		reasons underlying the success of developers who are expert in using
		cryptography. Also, detailed investigation at API level is necessary to
		further clarify a developer obstacles in this domain.},
	doi={10.1109/ESEM.2019.8870184},
	ISSN={1949-3770},
	month={sep},
	Keywords = {scg-pub security snf-asa3 scg19 jb19},
	Peerreview = {yes},
	Medium = {2},
    Annote = {internationalconference},
	Url = {http://scg.unibe.ch/archive/papers/Hazh19aJCA-Impact.pdf}
}

@inproceedings{Hazh20a,
	author={Mohammadreza Hazhirpasand and Mohammad Ghafari and Oscar Nierstrasz},
	booktitle={27th edition of the IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)},
	title={{CryptoExplorer}: An Interactive Web Platform Supporting Secure Use of Cryptography {APIs}},
	year={2020},
	Annote    = {internationalconference},
	PeerReview = {yes},
	Medium = {2},
	abstract={Research has shown that cryptographic APIs are hard to use.
		Consequently, developers resort to using code examples available in
		online information sources that are often not secure. We have
		developed a web platform, named CryptoExplorer, stocked with
		numerous real-world secure and insecure examples that developers
		can explore to learn how to use cryptographic APIs properly. This
		platform currently provides 3 263 secure uses, and 5 897 insecure
		uses of Java Cryptography Architecture mined from 2 324 Java
		projects on GitHub. A preliminary study shows that CryptoExplorer
		provides developers with secure crypto API use examples instantly,
		developers can save time compared to searching on the internet for
		such examples, and they learn to avoid using certain algorithms in
		APIs by studying misused API examples. We have a pipeline to
		regularly mine more projects, and, on request, we offer our dataset
		to researchers.},
	keywords={scg-pub security snf-asa3 scg20 jb20 snf-imad},
	doi = {10.1109/SANER48275.2020.9054799},
	pages={632--636},
	month=mar,
	Url={http://scg.unibe.ch/archive/papers/Hazh20a.pdf}
}

@inproceedings{Hazh20b,
author = {Hazhirpasand, Mohammadreza and Ghafari, Mohammad and Nierstrasz, Oscar},
title = {Tricking {Johnny} into Granting Web Permissions},
PeerReview = {yes},
abstract={We studied the web permission API dialog box in popular mobile and desktop
	browsers, and found that it typically lacks measures to protect users
	from unwittingly granting web permission when clicking too fast. We
	developed a game that exploits this issue, and tricks users into granting
	webcam permission. We conducted three experiments, each with 40 different
	participants, on both desktop and mobile browsers. The results indicate
	that in the absence of a prevention mechanism, we achieve a considerably
	high success rate in tricking 95\% and 72\% of participants on mobile and
	desktop browsers, respectively. Interestingly, we also tricked 47\% of
	participants on a desktop browser where a prevention mechanism exists.},
year = {2020},
isbn = {9781450377317},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/3383219.3383248},
booktitle = {Proceedings of the Evaluation and Assessment in Software Engineering},
pages = {276--281},
numpages = {6},
keywords = {scg-pub security snf-asa3 scg20 jb20 snf-imad},
location = {Trondheim, Norway},
series = {EASE 2020},
Medium = {2},
Url={http://scg.unibe.ch/archive/papers/Hazh20b.pdf}
}

@inproceedings{Hazh20c,
	author={Hazhirpasand, Mohammadreza and Ghafari, Mohammad and Nierstrasz, Oscar},
	booktitle={Proceedings of the 14th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)},
	title={Java Cryptography Uses in the Wild},
	year={2020},
	annote={internationalconference},
	peerreview={yes},
	medium={2},
	doi={10.1145/3382494.3422166},
	abstract={[Background] Previous research has shown that developers commonly misuse cryptography APIs. [Aim] We have conducted an exploratory study to find out how crypto APIs are used in open-source Java projects, what types of misuses exist, and why developers make such mistakes. [Method] We used a static analysis tool to analyze hundreds of open-source Java projects that rely on Java Cryptography Architecture, and manually inspected half of the analysis results to assess the tool results. We also contacted the maintainers of these projects by creating an issue on the GitHub repository of each project, and discussed the misuses with developers. [Results] We learned that 85\% of Cryptography APIs are misused, however, not every misuse has severe consequences. Developer feedback showed that security caveats in the documentation of crypto APIs are rare, developers may overlook misuses that originate in third-party code, and the context where a Crypto API is used should be taken into account. [Conclusion] We conclude that using Crypto APIs is still problematic for developers but blindly blaming them for such misuses may lead to erroneous conclusions.},
	numpages={6},
	keywords={scg-pub security snf-asa3 scg20 jb21 snf-imad},
	Url={http://scg.unibe.ch/archive/papers/Hazh20c.pdf}
}

@inproceedings{Hazh21a,
	author={Hazhirpasand, Mohammadreza and Ale Ebrahim, Arash and Nierstrasz, Oscar},
	booktitle={Proceedings of the 7th International Conference on Information Systems Security and Privacy - ICISSP},
	title={Stopping {DNS} Rebinding Attacks in the Browser},
	year={2021},
	annote={internationalconference},
	peerreview={yes},
	medium={2},
	doi={10.5220/0010310705960603},
	abstract={DNS rebinding attacks circumvent the same-origin policy of browsers and severely jeopardize user privacy. Although recent studies have shown that DNS rebinding attacks pose severe security threats to users, up to now little effort has been spent to assess the effectiveness of known solutions to prevent such attacks. We have carried out such a study to assess the protective measures proposed in prior studies. We found that none of the recommended techniques can entirely halt this attack due to various factors, e.g., network layer encryption renders packet inspection infeasible. Examining the previous problematic factors, we realize that a protective measure must be implemented at the browser-level. Therefore, we propose a defensive measure, a browser plug-in called Fail-rebind, that can detect, inform, and protect users in the event of an attack. Afterwards, we discuss the merits and limitations of our method compared to prior methods. Our findings suggest that Fail-rebind does not nec essitate expert knowledge, works on different OSes and smart devices, and is independent of networks and location.},
	numpages={8},
	keywords={scg-pub security snf-asa3 scg21 jb21 snf-imad},
	Url={http://scg.unibe.ch/archive/papers/Hazh21a.pdf}
}

@inproceedings{Hazh21b,
	author={Hazhirpasand, Mohammadreza and Nierstrasz, Oscar and Ghafari, Mohammad},
	booktitle={2021 18th International Conference on Privacy, Security and Trust (PST)},
	title={Dazed and Confused: What's Wrong with Crypto Libraries?},
	abstract = {Recent studies have shown that developers have difficulties in
		using cryptographic APIs, which often led to security flaws.
		We are interested to tackle this matter by looking into what
		types of problems exist in various crypto libraries. We
		manually studied 500 posts on Stack Overflow associated with
		20 popular crypto libraries. We realized there are 10 themes
		in the discussions. Interestingly, there were only two
		questions related to attacks against cryptography. There were
		63 discussions in which developers had interoperability issues
		when working with more than a crypto library. The majority of
		posts (112) were about encryption/decryption problems and 111
		were about installation/compilation issues of crypto
		libraries. Overall, we realize that the crypto libraries are
		frequently involved in more than five themes of discussions.
		We believe the current initial findings can help team leaders
		and experienced developers to correctly guide the team members
		in the domain of cryptography. Moreover, future research
		should investigate the similarity of problems at the API level
		among popular crypto libraries.},
	year={2021},
	annote={internationalconference},
	peerreview={yes},
	medium={2},
	pages={1-6},
	doi={10.1109/PST52912.2021.9647786},
	keywords={scg-pub security snf-asa3 scg21 jb22},
  url = {http://scg.unibe.ch/archive/papers/Hazh21b.pdf}
}

@inproceedings{Hazh21c,
  author={Hazhirpasand, Mohammadreza and Nierstrasz, Oscar and Shabani, Mohammadhossein and Ghafari, Mohammad},
  booktitle={2021 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
  title={Hurdles for Developers in Cryptography},
	abstract = {Prior research has shown that cryptography is hard to use for
		developers. We aim to understand what cryptography issues
		developers face in practice. We clustered 91 954
		cryptography-related questions on the Stack Overflow website,
		and manually analyzed a significant sample (i.e., 383) of the
		questions to comprehend the crypto challenges developers
		commonly face in this domain. We found that either developers
		have a distinct lack of knowledge in understanding the
		fundamental concepts, e.g., OpenSSL, public-key cryptography
		or password hashing, or the usability of crypto libraries
		undermined developer performance to correctly realize a crypto
		scenario. This is alarming and indicates the need for
		dedicated research to improve the design of crypto APIs.},
  year={2021},
	annote={internationalconference},
	peerreview={yes},
	medium={2},
  pages={659-663},
  doi={10.1109/ICSME52107.2021.00076},
	keywords={scg-pub security snf-asa3 scg21 jb22},
  url = {http://scg.unibe.ch/archive/papers/Hazh21c.pdf}
}

@inproceedings{Hazh21d,
  author={Hazhirpasand, Mohammadreza and Ghafari, Mohammad and Nierstrasz, Oscar},
  booktitle={2021 36th IEEE/ACM International Conference on Automated Software Engineering Workshops (ASEW)},
  title={Worrisome Patterns in Developers: A Survey in Cryptography},
	abstract = {We surveyed 97 developers who had used cryptography in
		open-source projects, in the hope of identifying developer
		security and cryptography practices. We asked them about
		individual and company-level practices, and divided
		respondents into three groups (i.e., high, medium, and low)
		based on their level of knowledge. We found differences
		between the high-profile developers and the other two groups.
		For instance, high-profile developers have more years of
		experience in programming, have attended more security and
		cryptography courses, have more background in security, are
		highly concerned about security, and tend to use security
		tools more than the other two groups. Nevertheless, we
		observed worrisome patterns among all participants such as the
		high usage of unreliable sources like Stack Overflow, and the
		low rate of security tool usage.},
  year={2021},
	annote={internationalconference},
	peerreview={yes},
	medium={2},
  pages={185-190},
  doi={10.1109/ASEW52652.2021.00045},
  keywords={scg-pub security snf-asa3 scg21 jb22},
  url = {http://scg.unibe.ch/archive/papers/Hazh21d.pdf}
}

@inproceedings{Hazh21e,
  author={Hazhirpasand, Mohammadreza and Ghafari, Mohammad and Nierstrasz, Oscar},
  booktitle={2021 36th IEEE/ACM International Conference on Automated Software Engineering Workshops (ASEW)},
  title={Crypto Experts Advise What They Adopt},
	abstract = {Previous studies have shown that developers regularly seek
		advice on online forums to resolve their cryptography issues.
		We investigated whether users who are active in cryptography
		discussions also use cryptography in practice. We collected
		the top 1% of responders who have participated in crypto
		discussions on Stack Overflow, and we manually analyzed their
		crypto contributions to open source projects on GitHub. We
		could identify 319 GitHub profiles that belonged to such
		crypto responders and found that 189 of them used cryptography
		in their projects. Further investigation revealed that the
		majority of analyzed users (i.e., 85%) use the same
		programming languages for crypto activity on Stack Overflow
		and crypto contributions on GitHub. Moreover, 90% of the
		analyzed users employed the same concept of cryptography in
		their projects as they advised about on Stack Overflow.},
  year={2021},
	annote={internationalconference},
	peerreview={yes},
	medium={2},
  pages={179-184},
  doi={10.1109/ASEW52652.2021.00044},
  keywords={scg-pub security snf-asa3 scg21 jb22},
  url = {http://scg.unibe.ch/archive/papers/Hazh21e.pdf}
}

@inproceedings{Hazh21f,
  author={Hazhirpasand, Mohammadreza and Ghafari, Mohammad},
	booktitle={21st IEEE International Conference on Software Quality, Reliability, and Security (QRS)},
	title={Cryptography Vulnerabilities on {HackerOne}},
	year={2021},
  pages={18-27},
	Annote = {internationalconference},
	PeerReview = {yes},
	Medium = {2},
	abstract={Previous studies have shown that cryptography is hard for developers to use and misusing cryptography leads to severe security vulnerabilities. We studied relevant vulnerability reports on the HackerOne bug bounty platform to understand what types of cryptography vulnerabilities exist in the wild. We extracted eight themes of vulnerabilities from the vulnerability reports and discussed their real-world implications and mitigation strategies. We hope that our findings alert developers, familiarize them with the dire consequences of cryptography misuses, and support them in avoiding such mistakes.},
	keywords={scg-pub security snf-asa3 scg21 jb22},
	month=dec,
	Url={http://scg.unibe.ch/archive/papers/Hazh21f.pdf},
  Doi={10.1109/QRS54544.2021.00013}
}

@article{Hirs08a,
	Abstract = {Context-dependent behavior is becoming increasingly
				  important for a wide range of application domains,
				  from pervasive computing to common business
				  applications. Unfortunately, mainstream programming
				  languages do not provide mechanisms that enable
				  software entities to adapt their behavior
				  dynamically to the current execution context. This
				  leads developers to adopt convoluted designs to
				  achieve the necessary runtime flexibility. We
				  propose a new programming technique called
				  Context-oriented Programming (COP) which addresses
				  this problem. COP treats context explicitly, and
				  provides mechanisms to dynamically adapt behavior in
				  reaction to changes in context, even after system
				  deployment at runtime. In this paper we lay the
				  foundations of COP, show how dynamic layer
				  activation enables multi-dimensional dispatch,
				  illustrate the application of COP by examples in
				  several language extensions, and demonstrate that
				  COP is largely independent of other commitments to
				  programming style.},
	Annote = {internationaljournal},
	Author = {Hirschfeld, Robert and Costanza, Pascal and Nierstrasz, Oscar},
	Bdsk-Url-1 = {http://www.jot.fm/issues/issue_2008_03/article4/index.html http://www.jot.fm/issues/issue_2008_03/article4.pdf},
	Cached = {http://scg.unibe.ch/archive/papers/Hirs08aCOP-JOT.pdf},
	Doi = {10.5381/jot.2008.7.3.a4},
	Journal = {Journal of Object Technology},
	Keywords = {cop-lit cop layer jot scg08 scg-pub skip-doi jb08 snf08 onhindex(104)},
	Medium = {2},
	Misc = {March-April},
	Month = mar,
	Number = {3},
	Peerreview = {yes},
	Title = {Context-Oriented Programming},
	url = {http://www.jot.fm/issues/issue_2008_03/article4.pdf},
	url2 = {http://www.jot.fm/contents/issue_2008_03/article4.html},
	Volume = {7},
	Year = {2008},
	Bdsk-Url-2 = {http://www.jot.fm/issues/issue_2008_03/article4/index.html%20http://www.jot.fm/issues/issue_2008_03/article4.pdf}}

@inproceedings{Hofe06a,
	Abstract = {Traditional debugging and stepping execution trace
				  are well-accepted techniques to understand deep
				  internals about a program. However in many cases
				  navigating the stack trace is not enough to find
				  bugs, since the cause of a bug is often not in the
				  stack trace anymore and old state is lost, so out of
				  reach from the debugger. In this paper, we present
				  the design and implementation of a backward-in-time
				  debugger for a dynamic language, i.e, a debugger
				  that allows one to navigate back the history of the
				  application. We present the design and
				  implementation of a backward-in-time debugger called
				  Unstuck and show our solution to key implementation
				  challenges.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Christoph Hofer and Marcus Denker and St\'ephane Ducasse},
	Booktitle = {Proceedings of NODE'06},
	Inria = {hors},
	Keywords = {skip-doi scg-pub stefPub scg-none jb07 fb06 snf06},
	Medium = {2},
	Month = sep,
	Organization = {Gesellschaft f{\"u}r Informatik (GI)},
	Pages = {17--32},
	Peerreview = {yes},
	Selectif = {non},
	Series = {Lecture Notes in Informatics},
	Title = {Design and Implementation of a Backward-In-Time Debugger},
	Url = {http://scg.unibe.ch/archive/papers/Hofe06aUnstuckNode.pdf},
	Volume = {P-88},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Hofe06aUnstuckNode.pdf}}

@inproceedings{Kim06a,
	Abstract = {Software repositories have been getting a lot of
				  attention from researchers in recent years. In order
				  to analyze software repositories, it is necessary to
				  first extract raw data from the version control and
				  problem tracking systems. This poses two challenges:
				  (1) extraction requires a non-trivial effort, and
				  (2) the results depend on the heuristics used during
				  extraction. These challenges burden researchers that
				  are new to the community and make it difficult to
				  benchmark software repository mining since it is
				  almost impossible to reproduce experiments done by
				  another team. In this paper we present the TA-RE
				  corpus. TA-RE collects extracted data from software
				  repositories in order to build a collection of
				  projects that will simplify extraction process.
				  Additionally the collection can be used for
				  benchmarking. As the first step we propose an
				  exchange language capable of making sharing and
				  reusing data as simple as possible.},
	Annote = {internationalworkshop},
	Author = {Sunghun Kim and Thomas Zimmermann and Miryung Kim and Ahmed Hassan and Audris Mockus and Tudor G\^irba and Martin Pinzger and James Whitehead and Andreas Zeller},
	Booktitle = {Proceedings Workshop on Mining Software Repositories (MSR 2006)},
	Keywords = {evolution girba scg-pub skip-doi scg-none jb06 fb06 recast06},
	Medium = {2},
	Pages = {22--25},
	Peerreview = {yes},
	Title = {{TA-RE}: An Exchange Language for Mining Software Repositories},
	Url = {http://scg.unibe.ch/archive/papers/Kim06aTARE.pdf},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kim06aTARE.pdf}}

@inproceedings{Kreb11a,
	Abstract = {Java Enterprise Applications (JEAs) are complex systems composed of various technologies and programming
				languages other than Java, such as XML or SQL.
				In this heterogenous context, information is spread across various components and languages and the
				interactions between different application elements could be hidden.
				On the other hand, existing reverse engineering and quality assurance techniques are unable to
				analyze JEAs since they are focused on specific components or languages.
				In this paper we present our approach to enhance the Eclipse IDE to analyze these complex systems.
				We extended a meta-model for Object-Oriented systems to accommodate the heterogeneous nature of JEAs.
				By modeling JEAs we can support different kinds of analysis based on software visualizations and software metrics.
				We implemented an Eclipse plug-in to analyze JEAs called Vera to make this solution available in one of
				the most largely used IDE. The integration with the development environment makes the developers keep focused
				on a single tool instead of relying on several once. We demonstrate Vera by implementing a well known
				polymetric visualization, the System Complexity view, and an improved version of the Transaction Flow
				visualization. The latter shows what can be done by integrating information spread across different sources.
				We also present a browser that provides an analytical view of the code.},
	Author = {Raffael Krebs and Fabrizio Perin},
	Booktitle = {Proc. of the Sixth Workshop of the Italian Eclipse Community (Eclipse-IT)},
	Isbn = {9788890438820},
	Keywords = {scg12 scg-pub jb12 scg11 moose-pub skip-doi snf-none},
	Location = {Milano, Italy},
	Medium = {1},
	Month = sep,
	Pages = {28--39},
	Peerreview = {yes},
	Title = {Reverse engineering Java Enterprise Applications in Eclipse},
	Url = {http://scg.unibe.ch/archive/papers/Kreb11aVera.pdf},
	Year = {2011},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kreb11aVera.pdf}}

@inproceedings{Kube15a,
	 Abstract = {Analyzing how software engineers use the Integrated Development Environment (IDE) is essential to better understanding how engineers carry out their daily tasks. Spotter is a code search engine for the Pharo programming language. Since its inception, Spotter has been rapidly and broadly adopted within the Pharo community. However, little is known about how practitioners employ Spotter to search and navigate within the Pharo code base. This paper evaluates how software engineers use Spotter in practice. To achieve this, we remotely gather user actions called events. These events are then visually rendered using an adequate navigation tool chain. Sequences of events are represented using a visual alphabet. We found a number of usage patterns and identified underused Spotter features. Such findings are essential for improving Spotter.},
	 Author = {Kubelka, Juraj and Bergel, Alexandre and Chi\c{s}, Andrei and G\^irba, Tudor and Reichhart, Stefan and Robbes, Romain and Syrel, Aliaksei},
	 Booktitle = {Proceedings of 3rd IEEE Working Conference on Software Visualization - New Ideas and Emerging Results},
	 Pages = {145--149},
	 Publisher = {{IEEE}},
	 Series = {VISSOFT-NIER'15},
	 Doi={10.1109/VISSOFT.2015.7332426},
	 Title = {On Understanding How Developers Use the {Spotter} Search Tool},
	 Year = {2015},
	 month=sep,
 	 Peerreview = {yes},
	 Medium = {2},
	 Keywords = {scg-pub scg15 jb16 snf-asa1, Andrei Chis, Tudor Girba, girba feenk-pub},
	 Url = {http://scg.unibe.ch/archive/papers/Kube15a-OnUnderstandingHowDevelopersUseTheSpotterSearchTool.pdf}}

@inproceedings{Kuhn05a,
	Abstract = {Understanding a software system by just analyzing
				  the structure of the system reveals only half of the
				  picture, since the structure tells us only how the
				  code is working but not what the code is about. What
				  the code is about can be found in the semantics of
				  the source code: names of identifiers, comments etc.
				  In this paper, we analyze how these terms are spread
				  over the source artifacts using Latent Semantic
				  Indexing, an information retrieval technique. We use
				  the assumption that parts of the system that use
				  similar terms are related. We cluster artifacts that
				  use similar terms, and we reveal the most relevant
				  terms for the computed clusters. Our approach works
				  at the level of the source code which makes it
				  language independent. Nevertheless, we correlated
				  the semantics with structural information and we
				  applied it at different levels of abstraction (e.g.
				  classes, methods). We applied our approach on three
				  large case studies and we report the results we
				  obtained.},
	Acceptnum = {21},
	Accepttotal = {58},
	Address = {Los Alamitos CA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Adrian Kuhn and St\'ephane Ducasse and Tudor G\^irba},
	Booktitle = {Proceedings of 12th Working Conference on Reverse Engineering (WCRE'05)},
	Doi = {10.1109/WCRE.2005.16},
	Inria = {hors},
	Keywords = {scg-pub semantic clustering lsi stefPub girba scg-none jb06 recast06 hapax moose-pub listic akuhn},
	Location = {Pittsburgh, PA},
	Misc = {acceptance rate: 21/58 = 36 \%},
	Month = nov,
	Pages = {113--122},
	Publisher = {IEEE Computer Society Press},
	Rate = {36%},
	Selectif = {non},
	Title = {Enriching Reverse Engineering with Semantic Clustering},
	Url = {http://scg.unibe.ch/archive/papers/Kuhn05aSemanticClustering.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kuhn05aSemanticClustering.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.2005.16}}

@inproceedings{Kuhn05b,
	Abstract = {Recently there has been a revival of interest in
				  feature analysis of software systems. Approaches to
				  feature location have used a wide range of
				  techniques such as dynamic analysis, static
				  analysis, information retrieval and formal concept
				  analysis. In this paper we introduce a novel
				  approach to analyze the execution traces of features
				  using Latent Semantic Indexing (LSI). Our goal is
				  twofold. On the one hand we detect similarities
				  between features based on the content of their
				  traces, and on the other hand we categorize classes
				  based on the frequency of the outgoing invocations
				  involved in the traces. We apply our approach on two
				  case studies and we discuss its benefits and
				  drawbacks.},
	Address = {Los Alamitos CA},
	Annote = {internationalworkshop},
	Author = {Adrian Kuhn and Orla Greevy and Tudor G\^irba},
	Booktitle = {Proceedings IEEE Workshop on Program Comprehension through Dynamic Analysis (PCODA 2005)},
	Keywords = {scg-pub skip-doi semantic clustering lsi stefPub girba scg-none jb06 recast06 hapax moose-pub akuhn},
	Location = {Pittsburgh, PA},
	Month = nov,
	Pages = {48--53},
	Publisher = {IEEE Computer Society Press},
	Title = {Applying Semantic Analysis to Feature Execution Traces},
	Url = {http://scg.unibe.ch/archive/papers/Kuhn05bHapaxPCODA2005.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kuhn05bHapaxPCODA2005.pdf}}

@inproceedings{Kuhn06c,
	Abstract = {The main challenge of dynamic analysis is the huge
				  volume of data, making it difficult to extract high
				  level views. Most techniques developed so far adopt
				  a fine-grained approach to address this issue. In
				  this paper we introduce a novel approach
				  representing entire traces as signals in time.
				  Drawing this analogy between dynamic analysis and
				  signal processing, we are able to access a rich
				  toolkit of well-established and ready-to-use
				  analysis techniques. As an application of this
				  analogy, we show how to fit a visualization of the
				  complete feature space of a system on one page only:
				  our approach visualizes feature traces as time
				  plots, summarizes the trace signals and uses dynamic
				  time warping to group them by similar features. We
				  apply the approach on a case study, and discuss both
				  common and unique patterns as observed on the
				  visualization.},
	Address = {Los Alamitos CA},
	Annote = {internationalconference},
	Author = {Adrian Kuhn and Orla Greevy},
	Booktitle = {Proceedings IEEE International Conference on Software Maintainance (ICSM 2006)},
	Doi = {10.1109/ICSM.2006.29},
	Keywords = {scg-pub kuhn greevy scg-none jb07 fb06 Feature Feature-Traces Dynamic Analysis moose-pub recast07 snf06 akuhn},
	Medium = {2},
	Month = sep,
	Pages = {320--329},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society Press},
	Title = {Exploiting the Analogy Between Traces and Signal Processing},
	Url = {http://scg.unibe.ch/archive/papers/Kuhn06cTraceSignalICSM2006.pdf},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kuhn06cTraceSignalICSM2006.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICSM.2006.29}}

@inproceedings{Kuhn06d,
	Abstract = {One of the key challenges of dynamic analysis
				  approaches is that they imply a huge volume of data,
				  thus making it difficult to extract high level
				  views. In this paper we describe a novel approach to
				  trace summarization by visually representing entire
				  traces as signals in time. Our technique produces a
				  visualization of the complete feature space of a
				  system that fits on one page. The focus of our work
				  is to visually represent individual traces feature
				  behavior. We assume a one-to-one mapping between
				  features and traces. We apply the approach on a case
				  study, and discuss how our visualization supports
				  the reverse engineer to identify patterns in traces
				  of features. Moreover, we show how the visual
				  analysis of our trace signals reveals that assumed
				  one-to-one mappings between features and traces may
				  be flawed.},
	Address = {Los Alamitos CA},
	Annote = {internationalworkshop},
	Author = {Adrian Kuhn and Orla Greevy},
	Booktitle = {Proceedings IEEE Workshop on Program Comprehension through Dynamic Analysis (PCODA 2006)},
	Keywords = {scg-pub skip-doi snf06 scg-none jb07 fb06 moose-pub akuhn},
	Location = {Benevento, Italy},
	Medium = {2},
	Month = oct,
	Pages = {01--06},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society Press},
	Title = {Summarizing Traces as Signals in Time},
	Url = {http://scg.unibe.ch/archive/papers/Kuhn06dTimePlot.pdf http://www.lore.ua.ac.be/Events/PCODA2006/index.html},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kuhn06dTimePlot.pdf%20http://www.lore.ua.ac.be/Events/PCODA2006/index.html}}

@article{Kuhn07a,
	Abstract = {Many of the existing approaches in Software
				  Comprehension focus on program program structure or
				  external documentation. However, by analyzing formal
				  information the informal semantics contained in the
				  vocabulary of source code are overlooked. To
				  understand software as a whole, we need to enrich
				  software analysis with the developer knowledge
				  hidden in the code naming. This paper proposes the
				  use of information retrieval to exploit linguistic
				  information found in source code, such as identifier
				  names and comments. We introduce Semantic
				  Clustering, a technique based on Latent Semantic
				  Indexing and clustering to group source artifacts
				  that use similar vocabulary. We call these groups
				  semantic clusters and we interpret them as
				  linguistic topics that reveal the intention of the
				  code. We compare the topics to each other, identify
				  links between them, provide automatically retrieved
				  labels, and use a visualization to illustrate how
				  they are distributed over the system. Our approach
				  is language independent as it works at the level of
				  identifier names. To validate our approach we
				  applied it on several case studies, two of which we
				  present in this paper.},
	Address = {Newton, MA, USA},
	Aeres = {ACL},
	Aereststatus = {2008},
	Annote = {internationaljournal},
	Author = {Adrian Kuhn and St\'ephane Ducasse and Tudor G\^irba},
	Doi = {10.1016/j.infsof.2006.10.017},
	Impactfactor = {0.435, SCI 2005},
	Inria = {hors},
	Issn = {0950-5849},
	Journal = {Information and Software Technology},
	Keywords = {scg07 moose-pub scg-pub snf07 jb07 recast07 girba stefPub akuhn},
	Medium = {2},
	Misc = {SCI impact factor 0.435 (2005)},
	Month = mar,
	Number = {3},
	Pages = {230--243},
	Peerreview = {yes},
	Publisher = {Butterworth-Heinemann},
	Title = {Semantic Clustering: Identifying Topics in Source Code},
	Url = {http://scg.unibe.ch/archive/drafts/Kuhn06bSemanticClustering.pdf},
	Volume = {49},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/drafts/Kuhn06bSemanticClustering.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.infsof.2006.10.017}}

@inproceedings{Kuhn07b,
	Abstract = {When modelling a system, often there are properties
				  and operations related to a group of objects rather
				  than to a single object only. For example, given a
				  person object with an income property, the average
				  income applies to a group of persons as a whole
				  rather than to a single person. In this paper we
				  propose to extend programming languages with the
				  notion of collective behavior. Collective behavior
				  associates custom behavior with collection
				  instances, based on the type of its elements.
				  However, collective behavior is modeled as part of
				  the element's rather than the collection's class. We
				  present a proof-of-concept implementation of
				  collective behavior using Smalltalk, and validate
				  the usefulness of collective behavior considering a
				  real-life case study: 20% of the case-study's domain
				  logic is subject to collective behavior.},
	Annote = {internationalworkshop},
	Author = {Adrian Kuhn},
	Booktitle = {Proceedings of 3rd ECOOP Workshop on Dynamic Languages and Applications (DYLA 2007)},
	Keywords = {scg07 scg-pub skip-doi snf07 jb08 akuhn},
	Location = {Berlin, Germany},
	Medium = {2},
	Month = aug,
	Peerreview = {yes},
	Title = {Collective Behavior},
	Url = {http://scg.unibe.ch/archive/papers/Kuhn07bCollectiveBehavior.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kuhn07bCollectiveBehavior.pdf}}

@inproceedings{Kuhn08a,
	Abstract = {To quickly localize defects, we want our attention
				  to be focussed on relevant failing tests. We propose
				  to improve defect localization by exploiting
				  dependencies between tests, using a JUnit extension
				  called JExample. In a case study, a monolithic
				  white-box test suite for a complex algorithm is
				  refactored into two traditional JUnit style tests
				  and to JExample. Of the three refactorings, JExample
				  reports five times fewer defect locations and
				  slightly better performance (-8-12\%), while having
				  similar maintenance characteristics. Compared to the
				  original implementation, JExample greatly improves
				  maintainability due the improved factorization
				  following the accepted test quality guidelines. As
				  such, JExample combines the benefits of test chains
				  with test quality aspects of JUnit style testing.},
	Annote = {internationalconference},
	Author = {Adrian Kuhn and Bart Van Rompaey and Lea H\"ansenberger and Oscar Nierstrasz and Serge Demeyer and Markus Gaelli and Koenraad Van Leemput},
	Booktitle = {Extreme Programming and Agile Processes in Software Engineering, 9th International Conference, XP 2008},
	Doi = {10.1007/978-3-540-68255-4_8},
	Editor = {P. Abrahamsson},
	Isbn = {978-3-540-68254-7},
	Keywords = {scg08 scg-pub snf08 jb08 JExample akuhn gaelli haensenberger},
	Medium = {2},
	Pages = {73--82},
	Peerreview = {yes},
	Publisher = {Springer},
	Series = {Lecture Notes in Computer Science},
	Title = {{JExample}: Exploiting Dependencies Between Tests to Improve Defect Localization},
	Url = {http://scg.unibe.ch/archive/papers/Kuhn08aJExample.pdf},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kuhn08aJExample.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-540-68255-4_8}}

@inproceedings{Kuhn08b,
	Abstract = {Software visualizations can provide a concise
				  overview of a complex software system.
				  Unfortunately, since software has no physical shape,
				  there is no ``natural'' mapping of software to a
				  two-dimensional space. As a consequence most
				  visualizations tend to use a layout in which
				  position and distance have no meaning, and
				  consequently layout typical diverges from one
				  visualization to another. We propose a consistent
				  layout for software maps in which the position of a
				  software artifact reflects its \emph{vocabulary},
				  and distance corresponds to similarity of
				  vocabulary. We use Latent Semantic Indexing (LSI) to
				  map software artifacts to a vector space, and then
				  use Multidimensional Scaling (MDS) to map this
				  vector space down to two dimensions. The resulting
				  consistent layout allows us to develop a variety of
				  thematic software maps that express very different
				  aspects of software while making it easy to compare
				  them. The approach is especially suitable for
				  comparing views of evolving software, since the
				  vocabulary of software artifacts tends to be stable
				  over time.},
	Address = {Los Alamitos CA},
	Annote = {internationalconference},
	Author = {Adrian Kuhn and Peter Loretan and Oscar Nierstrasz},
	Booktitle = {Proceedings of 15th Working Conference on Reverse Engineering (WCRE'08)},
	Doi = {10.1109/WCRE.2008.45},
	Isbn = {978-0-7695-3429-9},
	Keywords = {scg08 scg-pub semantic codemap-pub clustering lsi jb09 snf09 hasler08 akuhn},
	Location = {Pittsburgh, PA},
	Medium = {2},
	Month = oct,
	Pages = {209--218},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society Press},
	Title = {Consistent Layout for Thematic Software Maps},
	Url = {http://scg.unibe.ch/archive/papers/Kuhn08bSoftwareMap.pdf},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kuhn08bSoftwareMap.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.2008.45}}

@inproceedings{Kuhn08c,
	Abstract = {Tomorrow's eternal software system will co-evolve
				  with their context: their metamodels must adapt at
				  runtime to ever-changing external requirements. In
				  this paper we present FAME, a polyglot library that
				  keeps metamodels accessible and adaptable at
				  runtime. Special care is taken to establish causal
				  connection between fame-classes and host-classes. As
				  some host-languages offer limited reflection
				  features only, not all implementations feature the
				  same degree of causal connection. We present and
				  discuss three scenarios: 1) full causal connection,
				  2) no causal connection, and 3) emulated causal
				  connection. Of which, both Scenario 1 and 3 are
				  suitable to deploy fully metamodel-driven
				  applications.},
	Annote = {internationalworkshop},
	Author = {Adrian Kuhn and Toon Verwaest},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kuhn08cFame.pdf% http://www.comp.lancs.ac.uk/~bencomo/MRT/MRT2008Proceedings.pdf},
	Booktitle = {Workshop on Models at Runtime},
	Keywords = {scg08 scg-pub skip-doi jb09 akuhn hasler08 tverwaes},
	Medium = {2},
	Pages = {57--66},
	Peerreview = {yes},
	Title = {{FAME}, A Polyglot Library for Metamodeling at Runtime},
	Url = {http://scg.unibe.ch/archive/papers/Kuhn08cFame.pdf http://www.comp.lancs.ac.uk/~bencomo/MRT/MRT2008Proceedings.pdf},
	Year = {2008},
	Bdsk-Url-2 = {http://scg.unibe.ch/archive/papers/Kuhn08cFame.pdf%20http://www.comp.lancs.ac.uk/~bencomo/MRT/MRT2008Proceedings.pdf}}

@inproceedings{Kuhn08d,
	Abstract = {As object-oriented languages are extended with novel
				  modularization mechanisms, better underlying models
				  are required to implement these high-level features.
				  This paper describes CELL, a language model that
				  builds on delegation-based chains of object
				  fragments. Composition of groups of cells is used:
				  1) to represent objects, 2) to realize various forms
				  of method lookup, and 3) to keep track of method
				  references. A running prototype of CELL is provided
				  and used to realize the basic kernel of a Smalltalk
				  system. The paper shows, using several examples, how
				  higher-level features such as traits can be
				  supported by the lower-level model.},
	Annote = {internationalworkshop},
	Author = {Adrian Kuhn and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 2nd Workshop on Virtual Machines and Intermediate Languages for Emerging Modularization Mechanisms (VMIL 2008), Nashville, Tennessee, Oct. 19, 2008},
	Doi = {10.1145/1507504.1507505},
	Editor = {Hridesh Rajan},
	Isbn = {978-1-60558-384-6},
	Keywords = {cell scg08 scg-pub snf09 jb09 akuhn},
	Medium = {2},
	Pages = {1--12},
	Peerreview = {yes},
	Title = {Composing New Abstractions From Object Fragments},
	Url = {http://scg.unibe.ch/archive/papers/Kuhn08dCells.pdf},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kuhn08dCells.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1507504.1507505}}

@inproceedings{Kuhn09a,
	Abstract = {As more and more open-source software components
				  become available on the internet we need automatic
				  ways to label and compare them. For example, a
				  developer who searches for reusable software must be
				  able to quickly gain an understanding of retrieved
				  components. This understanding cannot be gained at
				  the level of source code due to the semantic gap
				  between source code and the domain model. In this
				  paper we present a lexical approach that uses the
				  log-likelihood ratios of word frequencies to
				  automatically provide labels for software
				  components. We present a prototype implementation of
				  our labeling/comparison algorithm and provide
				  examples of its application. In particular, we apply
				  the approach to detect trends in the evolution of a
				  software system.},
	Annote = {internationalconference},
	Author = {Adrian Kuhn},
	Booktitle = {MSR '09: Proceedings of the 2009 6th IEEE International Working Conference on Mining Software Repositories},
	Doi = {10.1109/MSR.2009.5069499},
	Keywords = {scg09 scg-pub jb09 snf09 akuhn codemap-pub},
	Location = {Vancouver, Canada},
	Medium = {2},
	Pages = {175--178},
	Peerreview = {yes},
	Publisher = {IEEE},
	Title = {Automatic Labeling of Software Components and their Evolution using Log-Likelihood Ratio of Word Frequencies in Source Code},
	Url = {http://scg.unibe.ch/archive/papers/Kuhn09aLogLikelihoodRatio.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kuhn09aLogLikelihoodRatio.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/MSR.2009.5069499}}

@inproceedings{Kuhn10a,
	Abstract = {Search-driven development is mainly concerned with
				  code reuse but also with code navigation and
				  debugging. In this essay we look at search-driven
				  navigation in the IDE. We consider Smalltalk-80 as
				  an example of a programming system with
				  search-driven navigation capabilities and explore
				  its human factors. We present how immediate search
				  results lead to a user experience of code browsing
				  rather than one of waiting for and clicking through
				  search results. We explore the socio-technical
				  congruence of immediate search, ie unification of
				  tasks and breakpoints with method calls, which leads
				  to simpler and more extensible development tools.
				  Eventually we conclude with remarks on the
				  socio-technical congruence of search-driven
				  development.},
	Annote = {internationalworkshop},
	Author = {Adrian Kuhn},
	Booktitle = {ICSE Workshop on Search-Driven Development-Users, Infrastructure, Tools and Evaluation, 2010. SUITE '10.},
	Doi = {10.1145/1809175.1809182},
	Keywords = {codesearch scg-pub scg10 akuhn-pub suite2010 snf10 jb10},
	Medium = {1},
	Peerreview = {yes},
	Title = {Immediate Search in the IDE as an Example of Socio-Technical Congruence in Search-Driven Development},
	Url = {http://scg.unibe.ch/archive/papers/Kuhn10a-codesearch.pdf},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kuhn10a-codesearch.pdf}}

@article{Kuhn10b,
	Abstract = {Software visualizations can provide a concise
				  overview of a complex software system.
				  Unfortunately, as software has no physical shape,
				  there is no `natural' mapping of software to a
				  two-dimensional space. As a consequence most
				  visualizations tend to use a layout in which
				  position and distance have no meaning, and
				  consequently layout typically diverges from one
				  visualization to another. We propose an approach to
				  consistent layout for software visualization, called
				  Software Cartography, in which the position of a
				  software artifact reflects its vocabulary, and
				  distance corresponds to similarity of vocabulary. We
				  use Latent Semantic Indexing (LSI) to map software
				  artifacts to a vector space, and then use
				  Multidimensional Scaling (MDS) to map this vector
				  space down to two dimensions. The resulting
				  consistent layout allows us to develop a variety of
				  thematic software maps that express very different
				  aspects of software while making it easy to compare
				  them. The approach is especially suitable for
				  comparing views of evolving software, as the
				  vocabulary of software artifacts tends to be stable
				  over time. We present a prototype implementation of
				  Software Cartography, and illustrate its use with
				  practical examples from numerous open-source case
				  studies.},
	Annote = {internationaljournal},
	Author = {Adrian Kuhn and David Erni and Peter Loretan and Oscar Nierstrasz},
	Doi = {10.1002/smr.414},
	Journal = {Journal of Software Maintenance and Evolution (JSME)},
	Keywords = {scg-pub scg10 akuhn codemap-pub jb10 snf10},
	Medium = {2},
	Month = apr,
	Number = 3,
	Pages = {191--210},
	Peerreview = {yes},
	Title = {Software Cartography: Thematic Software Visualization with Consistent Layout},
	Url = {http://scg.unibe.ch/archive/papers/Kuhn10bSoftwareMaps.pdf},
	Volume = 22,
	Year = {2010},
	Bdsk-Url-1 = {http://dx.doi.org/10.1002/smr.414}}

@inproceedings{Kuhn10c,
	Abstract = {Software visualization can be of great use for
				  understanding and exploring a software system in an
				  intuitive manner. Spatial representation of software
				  is a promising approach of increasing interest.
				  However, little is known about how developers
				  interact with spatial visualizations that are
				  embedded in the IDE. In this paper, we present a
				  pilot study that explores the use of Software
				  Cartography for program comprehension of an unknown
				  system. We investigated whether developers establish
				  a spatial memory of the system, whether clustering
				  by topic offers a sound base layout, and how
				  developers interact with maps. We report our results
				  in the form of observations, hypotheses, and
				  implications. Key findings are a) that developers
				  made good use of the map to inspect search results
				  and call graphs, and b) that developers found the
				  base layout surprising and often confusing. We
				  conclude with concrete advice for the design of
				  embedded software maps},
	Annote = {internationalconference},
	Author = {Adrian Kuhn and David Erni and Oscar Nierstrasz},
	Booktitle = {SOFTVIS 2010},
	Doi = {10.1145/1879211.1879229},
	Keywords = {scg-pub snf11 scg10 jb11 akuhn codemap-pub},
	Medium = {2},
	Month = oct,
	Pages = {113--122},
	Peerreview = {yes},
	Title = {Embedding Spatial Software Visualization in the {IDE}: an Exploratory Study},
	Url = {http://scg.unibe.ch/archive/papers/Kuhn10c-softvis2010-kuhn-codemap-userstudy.pdf},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kuhn10c-softvis2010-kuhn-codemap-userstudy.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1879211.1879229}}

@inproceedings{Kuhn10d,
	Abstract = {Meaningful method names are crucial for the readability and maintainability of software. Existing naming conventions focus on syntactic details, leaving programmers with little or no support in choosing meaningful (domain) names. In this paper we propose to build a recommendation system that supports software developers and software architects when naming identifiers in source code as well as when naming elements in {UML} diagrams. We discuss related work, outline the design of such a recommendation system and discuss possible evaluation strategies.},
	Address = {New York, NY, USA},
	Annote = {internationalworkshop},
	Author = {Adrian Kuhn},
	Booktitle = {Proceedings of the 2nd International Workshop on Recommendation Systems for Software Engineering},
	Doi = {10.1145/1808920.1808932},
	Isbn = {978-1-60558-974-9},
	Keywords = {scg-pub snf11 scg10 jb11 akuhn},
	Location = {Cape Town, South Africa},
	Medium = {2},
	Pages = {50--51},
	Peerreview = {yes},
	Publisher = {ACM},
	Series = {RSSE '10},
	Title = {On recommending meaningful names in source and {UML}},
	Url = {http://scg.unibe.ch/archive/papers/Kuhn10d.pdf},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kuhn10d.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1808920.1808932}}

@incollection{Kurs13a,
	Author = {Jan Kur\v{s} and Guillaume Larcheveque and Lukas Renggli and Alexandre Bergel and Damien Cassou and St\'ephane Ducasse and Jannik Laval},
	Booktitle = {Deep Into Pharo},
	Isbn = {978-3-9523341-6-4},
	Keywords = {skip-abstract skip-doi scg-pub scg13 snf-asa1 jb14 kursjan},
	Medium = {2},
	Month = sep,
	Pages = 36,
	Peerreview = {no},
	Publisher = {Square Bracket Associates},
	Title = {{PetitParser}: Building Modular Parsers},
	Url = {http://scg.unibe.ch/archive/papers/Kurs13a-PetitParser.pdf},
	Year = {2013},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kurs13a-PetitParser.pdf}}

@inproceedings{Kurs14a,
	Abstract = {The domain of context-free languages has been extensively
                explored and there exist numerous techniques for parsing (all
                or a subset of) context-free languages. Unfortunately, some
                programming languages are not context-free. Using standard
                context-free parsing techniques to parse a context-sensitive
                programming language poses a considerable challenge. Im-
                plementors of programming language parsers have adopted
                various techniques, such as hand-written parsers, special lex-
                ers, or post-processing of an ambiguous parser output to deal
                with that challenge.
                In this paper we suggest a simple extension of a top-down
                parser with contextual information. Contrary to the tradi-
                tional approach that uses only the input stream as an input to
                a parsing function, we use a parsing context that provides ac-
                cess to a stream and possibly to other context-sensitive infor-
                mation. At a same time we keep the context-free formalism
                so a grammar definition stays simple without mind-blowing
                context-sensitive rules. We show that our approach can be
                used for various purposes such as indent-sensitive parsing,
                a high-precision island parsing or XML (with arbitrary el-
                ement names) parsing. We demonstrate our solution with
                PetitParser, a parsing-expression grammar based, top-down,
                parser combinator framework written in Smalltalk.},
	Annote = {internationalworkshop},
	Author = {Jan Kur\v{s} and Mircea Lungu and Oscar Nierstrasz},
	Booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2014)},
	Keywords = {scg14 scg-pub jb14 snf-asa1 skip-doi kursjan},
	Location = {Cambridge, England},
	Medium = {2},
	Peerreview = {yes},
	Title = {Top-Down Parsing with Parsing Contexts},
	Url = {http://scg.unibe.ch/archive/papers/Kurs14a-ParsingContext.pdf},
	Year = {2014}
    }

@inproceedings{Kurs14b,
	Annote = {internationalconference},
	Author = {Jan Kur\v{s} and Mircea Lungu and Oscar Nierstrasz},
	Title={Bounded Seas: Island Parsing Without Shipwrecks},
	Abstract={ Imprecise manipulation of source code (semi-parsing) is useful for tasks such as robust parsing, error recovery, lexical analysis, and rapid development of parsers for data extraction. An island grammar precisely defines only a subset of a language syntax (islands), while the rest of the syntax (water) is defined imprecisely.
    Usually, water is defined as the negation of islands. Albeit simple, such a definition of water is naive and impedes composition of islands. When developing an island grammar, sooner or later a programmer has to create water tailored to each individual island. Such an approach is fragile, however, because water can change with any change of a grammar. It is time-consuming, because water is defined manually by a programmer and not automatically. Finally, an island surrounded by water cannot be reused because water has to be defined for every grammar individually.
    In this paper we propose a new technique of island parsing - bounded seas. Bounded seas are composable, robust, reusable and easy to use because island-specific water is created automatically. We integrated bounded seas into a parser combinator framework as a demonstration of their composability and reusability.},
	Year={2014},
	Isbn={978-3-319-11244-2},
	Booktitle={Software Language Engineering},
	Volume={8706},
	Series={Lecture Notes in Computer Science},
	Editor={Combemale, Beno\^{i}t and Pearce, David J. and Barais, Olivier and Vinju, Jurgen J.},
	Doi={10.1007/978-3-319-11245-9_4},
	PeerReview = {yes},
	Medium = {2},
	Url = {http://scg.unibe.ch/archive/papers/Kurs14b-BoundedSeas.pdf},
	Publisher={Springer International Publishing},
	Pages={62-81},
	Language={English},
	Keywords = {scg-pub, scg14, jb15, snf-asa1, kursjan},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kurs14b-BoundedSeas.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-319-11245-9_4}}

@article{Kurs15a,
    title = {Bounded seas},
    journal = {Computer Languages, Systems \& Structures},
    volume = {44, Part A},
    pages = {114 - 140},
    PeerReview = {yes},
	Medium = {2},
    year = {2015},
	Annote = {internationaljournal},
    note = {Special issue on the 6th and 7th International Conference on Software Language Engineering (SLE 2013 and SLE 2014)},
    issn = {1477-8424},
    doi = {10.1016/j.cl.2015.08.002},
	url = {http://scg.unibe.ch/archive/papers/Kurs15a-BoundedSeas.pdf},
    author = {Jan Kur\v{s} and Mircea Lungu and Rathesan Iyadurai and Oscar Nierstrasz},
    keywords = {Semi-parsing, Island parsing, Parsing expression grammars, scg-pub, scg15, jb16, snf-asa1, kursjan},
    abstract = {Abstract Imprecise manipulation of source code (semi-parsing) is useful for tasks such as robust parsing, error recovery,
        lexical analysis, and rapid development of parsers for data extraction. An island grammar precisely defines only a subset of a
        language syntax (islands), while the rest of the syntax (water) is defined imprecisely. Usually water is defined as the negation of islands.
        Albeit simple, such a definition of water is naive and impedes composition of islands. When developing an island grammar, sooner or later a
        language engineer has to create water tailored to each individual island. Such an approach is fragile, because water can change with any
        change of a grammar. It is time-consuming, because water is defined manually by an engineer and not automatically. Finally, an island surrounded
        by water cannot be reused because water has to be defined for every grammar individually. In this paper we propose a new technique of
        island parsing --- bounded seas. Bounded seas are composable, robust, reusable and easy to use because island-specific water is created
        automatically. Our work focuses on applications of island parsing to data extraction from source code. We have integrated bounded seas
        into a parser combinator framework as a demonstration of their composability and reusability.},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Kurs15a-BoundedSeas.pdf}
}

@inproceedings{Kurs16a,
	Abstract = {Parser combinators are a popular approach to parsing. Parser combinators follow the structure of an underlying grammar, are modular, well-structured, easy to maintain, and can recognize a large variety of languages including context-sensitive ones. However, their universality and flexibility introduces a noticeable performance overhead. Time-wise, parser combinators cannot compete with parsers generated by well-performing parser generators or optimized hand-written code.
Techniques exist to achieve a linear asymptotic performance of parser combinators, yet there is still a significant constant multiplier. This can be further lowered using meta-programming techniques.
In this work we present a more traditional approach to optimization --- a compiler --- applied to the domain of parser combinators. A parser combinator compiler (pc-compiler) analyzes a parser combinator, applies parser combinator-specific optimizations and, generates an equivalent high-performance top-down parser. Such a compiler preserves the advantages of parser combinators while complementing them with better performance.},
	Annote = {internationalworkshop},
	Author = {Jan Kur\v{s} and Jan Vran\'{y} and Mohammad Ghafari and Mircea Lungu and Oscar Nierstrasz},
	Booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2016)},
	Keywords = {scg16 scg-pub jb17 snf-asa2 kursjan petitcompiler},
	Medium = {2},
	Peerreview = {yes},
	Title = {Optimizing Parser Combinators},
	Url = {http://scg.unibe.ch/archive/papers/Kurs16a-Compiler.pdf},
	Year = {2016},
	pages = {1:1--1:13},
	isbn = {978-1-4503-4524-8},
	doi = {10.1145/2991041.2991042}
    }

@misc{Kurs16b,
  author       = {Kur\v{s}, Jan and Lungu, Mircea and Nierstrasz, Oscar and Steinmann, Thomas},
  title        = {Polite Smalltalk --- An Implementation},
  abstract     = {Polite Smalltalk is a programming language
		that allows programmers to use sentence case identifiers -- a
		notation for embedding spaces in identifiers. We hope that a
		syntax like that of Polite will encourage developers to write
		more readable code. Even the smallest increase in code
		readability is to be desired since software developers spend
		the largest part of their time reading code rather than
		writing it.},
  keywords     = {scg16 scg-pub jb17 snf-none kursjan politesmalltalk},
  month        = sep,
  year         = {2016},
  doi          = {10.5281/zenodo.61578},
  Medium       = {1},
  Peerreview   = {no},
  url          = {http://dx.doi.org/10.5281/zenodo.61578}
}

@article{Kurs17a,
	title = {Efficient parsing with parser combinators},
	journal = {Science of Computer Programming},
	Annote = {internationaljournal},
	volume = {161},
	pages = {57.88},
	month = sep,
	year = {2018},
	issn = {0167-6423},
	doi = {10.1016/j.scico.2017.12.001},
    Url = {http://scg.unibe.ch/archive/papers/Kurs17a.pdf},
	author = {Jan Kur\v{s} and Jan Vran\'{y} and Mohammad Ghafari and Mircea Lungu and Oscar Nierstrasz},
	Keywords = {scg-pub, snf-asa2, scg17, jb18, kursjan},
	Medium = {2},
	Peerreview = {yes},
	abstract = {Abstract Parser combinators offer a universal and flexible approach to
	parsing. They follow the structure of an underlying grammar, are modular,
	well-structured, easy to maintain, and can recognize a large variety of languages
	including context-sensitive ones. However, these advantages introduce a noticeable
	performance overhead mainly because the same powerful parsing algorithm is used to
	recognize even simple languages. Time-wise, parser combinators cannot compete with
	parsers generated by well-performing parser generators or optimized hand-written code.
	Techniques exist to achieve a linear asymptotic performance of parser combinators, yet
	there is a significant constant multiplier. The multiplier can be lowered to some
	degree, but this requires advanced meta-programming techniques, such as staging or
	macros, that depend heavily on the underlying language technology. In this work we
	present a language-agnostic solution. We optimize the performance of parsing
	combinators with specializations of parsing strategies. For each combinator, we
	analyze the language parsed by the combinator and choose the most efficient parsing
	strategy. By adapting a parsing strategy for different parser combinators we achieve
	performance comparable to that of hand-written or optimized parsers while preserving
	the advantages of parsers combinators.}
}

@inproceedings{Lang08a,
	Abstract = {Systems must co-evolve with their context. Reverse
				  engineering tools are a great help in this process
				  of required adaption. In order for these tools to be
				  flexible, they work with models, abstract
				  representations of the source code. The extraction
				  of such information from source code can be done
				  using a parser. However, it is fairly tedious to
				  build new parsers. And this is made worse by the
				  fact that it has to be done over and over again for
				  every language we want to analyze. In this paper we
				  propose a novel approach which minimizes the
				  knowledge required of a certain language for the
				  extraction of models implemented in that language by
				  reflecting on the implementation of preparsed ASTs
				  provided by an IDE. In a second phase we use a
				  technique referred to as Model Mapping by Example to
				  map platform dependent models onto domain specific
				  model.},
	Annote = {internationalworkshop},
	Author = {Daniel Langone and Toon Verwaest},
	Booktitle = {2nd Workshop on FAMIX and Moose in Software Reengineering (FAMOOSr 2008)},
	Keywords = {scg08 scg-pub skip-doi jb09 hasler08 moose-pub tverwaes},
	Medium = {2},
	Month = oct,
	Pages = {32--35},
	Peerreview = {yes},
	Title = {Extracting models from {IDEs}},
	Url = {http://scg.unibe.ch/archive/papers/Lang08aModelExtraction.pdf},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lang08aModelExtraction.pdf}}

@inproceedings{Lang11a,
	Abstract = {Subjective behavior is essential for applications that must adapt
				  their behavior to changing circumstances. Many different solutions
				  have been proposed in the past, based, for example, on perspectives,
				  roles, contextual layers, and "force trees". Although these approaches
				  are somehow equally expressive, each imposes a particular world view
				  which may not be appropriate for all applications.
				  We propose a unification of these approaches, called Subjectopia,
				  which makes explicit the underlying abstractions needed to support
				  subjective behavior, namely subjects, contextual elements and decision
				  strategies. We demonstrate how Subjectopia subsumes existing approaches,
				  provides a more general foundation for modeling subjective behavior,
				  and offers a means to alter subjective behavior in a running system.},
	Annote = {internationalconference},
	Author = {Daniel Langone and Jorge Ressia and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 49th International Conference on Objects, Models, Components and Patterns (TOOLS'11)},
	Doi = {10.1007/978-3-642-21952-8_10},
	Keywords = {scg-pub scg11 snf11 jb11 bifrost ercim11},
	Medium = {2},
	Month = jun,
	Pages = {115--130},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Ratex = {28%},
	Series = {LNCS},
	Title = {Unifying Subjectivity},
	Url = {http://scg.unibe.ch/archive/papers/Lang11aSubjectivity.pdf},
	Volume = {6705},
	Year = {2011},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lang11aSubjectivity.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-642-21952-8_10}}

@inproceedings{Lanz01a,
	Abstract = {One of the main problems which arises in the field
				  of software evolution is the sheer amount of
				  information to be dealt with. Compared to reverse
				  engineering where the main goal is the main
				  understanding of one single system. In the field of
				  software evolution this information is multiplied by
				  the number of versions of the system one wants to
				  understand. To counter this problem we have come up
				  with a flexible query engine which can perform
				  queries on the different versions of a system. In
				  this paper we give an outlook on our current work in
				  the field of software evolution and focus
				  particularly on the concepts behind the query engine
				  we have built.},
	Annote = {internationalworkshop},
	Author = {Michele Lanza and St\'ephane Ducasse and Lukas Steiger},
	Booktitle = {Proceedings of the Workshop on Formal Foundations of Software Evolution},
	Keywords = {scg-pub skip-doi snf01 scg-none jb01 stefPub moose-pub},
	Title = {Understanding Software Evolution using a Flexible Query Engine},
	Url = {http://scg.unibe.ch/archive/papers/Lanz01aQueryEngine.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lanz01aQueryEngine.pdf}}

@inproceedings{Lanz01b,
	Abstract = {The reengineering and reverse engineering of
				  software systems is gaining importance in software
				  industry, because the accelerated turnover in
				  software companies creates legacy systems in a
				  shorter period of time. Especially understanding
				  classes is a key activity in object-oriented
				  programming, since classes represent the primary
				  abstractions from which applications are built. The
				  main problem of this task is to quickly grasp the
				  purpose of a class and its inner structure. To help
				  the reverse engineers in their first contact with a
				  foreign system, we propose a categorization of
				  classes based on the visualization of their internal
				  structure. The contributions of this paper are a
				  novel categorization of classes and a visualization
				  of the classes which we call the class blueprint. We
				  have validated the categorization on several case
				  studies, two of which we present here.},
	Acceptnum = {27},
	Accepttotal = {145},
	Annote = {internationalconference topconference},
	Author = {Michele Lanza and St\'ephane Ducasse},
	Booktitle = {Proceedings of 16th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA '01)},
	Doi = {10.1145/504282.504304},
	Keywords = {scg-pub snf01 scg-none jb01 stefPub moose-pub},
	Misc = {acceptance rate: 27/145 = 18\%},
	Pages = {300--311},
	Publisher = {ACM Press},
	Title = {A {Categorization} of {Classes} based on the {Visualization} of their {Internal} {Structure}: the {Class} {Blueprint}},
	Url = {http://scg.unibe.ch/archive/papers/Lanz01bClassBlueprint.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lanz01bClassBlueprint.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/504282.504304}}

@inproceedings{Lanz01c,
	Abstract = {One of the major problems in software evolution is
				  coping with the complexity which stems from the huge
				  amount of data that must be considered. The current
				  approaches to deal with that problem all aim at a
				  reduction of complexity and a filtering of the
				  relevant information. In this paper we propose an
				  approach based on a com- bination of software
				  visualization and software metrics which we have
				  already successfully applied in the field of
				  software reverse engineering. Using this approach we
				  discuss a simple and effective way to visualize the
				  evolution of software systems which helps to recover
				  the evolution of object oriented software systems.},
	Annote = {internationalworkshop},
	Author = {Michele Lanza},
	Booktitle = {Proceedings of IWPSE 2001 (International Workshop on Principles of Software Evolution)},
	Doi = {10.1145/602461.602467},
	Keywords = {scg-pub snf01 scg-none jb01 moose-pub},
	Pages = {37--42},
	Title = {The Evolution Matrix: Recovering Software Evolution using Software Visualization Techniques},
	Url = {http://scg.unibe.ch/archive/papers/Lanz01cEvolutionMatrix.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lanz01cEvolutionMatrix.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/602461.602467}}

@inproceedings{Lanz01d,
	Abstract = {Understanding classes is a key activity in
				  object-oriented programming, since classes represent
				  the primary abstractions from which applications are
				  built. The main problem of this task is to quickly
				  grasp the purpose and inner structure of a class. In
				  this paper we discuss the class blueprint, a
				  visualization of the inner structure of classes.},
	Annote = {internationalworkshop},
	Author = {Michele Lanza and St\'ephane Ducasse},
	Booktitle = {Workshop Proceedings of OOPSLA 2001},
	Keywords = {scg-pub skip-doi snf01 scg-none jb01 stefPub moose-pub},
	Title = {The Class Blueprint: A Visualization of the Internal Structure of Classes},
	Url = {http://scg.unibe.ch/archive/papers/Lanz01dClassBlueprint.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lanz01dClassBlueprint.pdf}}

@inproceedings{Lanz02a,
	Abstract = {Coping with huge amounts of data is one of the major
				  problems in the context of software evolution.
				  Current approaches reduce this complexity by
				  filtering out irrelevant information. In this paper
				  we propose an approach based on a combination of
				  software visualization and software metrics, as
				  software visualization is apt for complexity
				  reduction and metrics introduce the possibility to
				  qualify evolution. We discuss a simple and effective
				  way to visualize the evolution of software systems
				  which helps to recover the evolution of object
				  oriented software systems. In addition we define a
				  vocabulary that qualifies some specific situations
				  that occurs when considering system evolution.},
	Address = {Paris},
	Annote = {nationalconference},
	Author = {Michele Lanza and St\'ephane Ducasse},
	Booktitle = {Proceedings of Langages et Mod\`eles \`a Objets (LMO'02)},
	Keywords = {scg-pub skip-doi scg-none jb02 snf02 stefPub moose-pub},
	Pages = {135--149},
	Publisher = {Lavoisier},
	Title = {Understanding Software Evolution Using a Combination of Software Visualization and Software Metrics},
	Url = {http://scg.unibe.ch/archive/papers/Lanz02aEvolutionMatrix.pdf},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lanz02aEvolutionMatrix.pdf}}

@inproceedings{Lanz02b,
	Abstract = {Software Metrics have become essential in software
				  engineering for several reasons, among which quality
				  assessment and reengineering. In the context of the
				  European Esprit Pro ject FAMOOS, whose main goal was
				  to provide methodologies for the reengineering of
				  large industrial software systems, we have developed
				  the Moose Reengineering Environment, based on the
				  language independent FAMIX metamodel. Moose includes
				  a metrics engine which supports language independent
				  metrics, since coping with software written in
				  different implementation languages was one of the
				  project's main constraints. Our current research is
				  pushing us towards the development and
				  implementation of a metametamodel, which would
				  include our metamodel and allow for several
				  extension in different research directions, among
				  which concept analysis, knowledge management and
				  software evolution. In this article we want to
				  present our current and future work for the
				  transition from language independent to domain
				  independent metrics.},
	Annote = {internationalworkshop},
	Author = {Michele Lanza and St\'ephane Ducasse},
	Booktitle = {Proceedings of the 6th International Workshop on Quantitative Approaches in Object-Oriented Software Engineering},
	Editor = {Fernando Brito e Abreu and Mario Piattini and Geert Poels and Houari A. Sahraoui},
	Isbn = {84-699-8696-1},
	Keywords = {scg-pub skip-doi scg-none jb02 snf02 stefPub moose-pub},
	Pages = {77--84},
	Title = {Beyond Language Independent Object-Oriented Metrics: Model Independent Metrics},
	Url = {http://scg.unibe.ch/archive/papers/Lanz02bModelIndependentMetrics.pdf},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lanz02bModelIndependentMetrics.pdf}}

@inproceedings{Lanz03a,
	Abstract = {Software visualization tools face many challenges in
				  terms of their implementation, including
				  scalability, usability, adaptability, and
				  durability. Such tools, like many other research
				  tools, tend to have a short life cycle and are
				  vulnerble to software evolution processes because of
				  the complex problem domain and the constantly
				  changing requirements which are dictated by research
				  goals. In this paper we discuss the implementation
				  of the software visualization tool CodeCrawler
				  according to five criteria, namely the overall
				  architecture, the internal architecture, the
				  visualization engine, the metamodel and the
				  interactive facilities. This discussion generates
				  implementation recommendations and design guidelines
				  that hold for our tool and the class of tools its
				  stands for. We then also extract common design
				  guidelines and recommendations that apply for other
				  software visualization and general reverse
				  engineering tools as well, and hope that these
				  insights can be used fruitfully by other researchers
				  in this field.},
	Acceptnum = {40},
	Accepttotal = {118},
	Annote = {internationalconference},
	Author = {Michele Lanza},
	Booktitle = {Proceedings of CSMR 2003},
	Doi = {10.1109/CSMR.2003.1192450},
	Keywords = {recast03 scg-pub scg-none jb03 moose-pub},
	Misc = {acceptance rate: 40/118 = 34\%},
	Pages = {409--418},
	Publisher = {IEEE Press},
	Title = {{CodeCrawler} --- Lessons Learned in Building a Software Visualization Tool},
	Url = {http://scg.unibe.ch/archive/papers/Lanz03aLessonsLearned.pdf},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lanz03aLessonsLearned.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/CSMR.2003.1192450}}

@inproceedings{Lanz03c,
	Abstract = {Software Visualization is, despite the many
				  publications and advances in this research field,
				  still not being considered by mainstream software
				  industry: currently very few integrated development
				  environments offer (if at all) only limited
				  visualization support, and in general it can be said
				  that software visualization is being ignored at a
				  professional level by the average software
				  developer. Moreover, even relatively successful
				  software visualization tools (such as Rigi, Shrimp,
				  JInsight, etc.) are seldom being used except by
				  their developers themselves. In this position paper,
				  based on our own experience and an analysis of the
				  current state and possible future trends of
				  integrated development environments, we put up a
				  non-exhaustive list of features that software
				  visualization tools should possess in the future to
				  have more consideration by mainstream development.},
	Author = {Michele Lanza},
	Booktitle = {Proceedings of VisSoft 2003 (2nd International Workshop on Visualizing Software for Understanding and Analysis)},
	Keywords = {recast04 scg-pub skip-doi scg-none jb04 moose-pub},
	Pages = {62--67},
	Publisher = {IEEE CS Press},
	Title = {Program Visualization Support for Highly Iterative Development Environments},
	Url = {http://scg.unibe.ch/archive/papers/Lanz03cVisSoft.pdf},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lanz03cVisSoft.pdf}}

@article{Lanz03d,
	Abstract = {Reverse engineering software systems has become a
				  major concern in software industry because of their
				  sheer size and complexity. This problem needs to be
				  tackled, since the systems in question are of
				  considerable worth to their owners an d maintainers.
				  In this article we present the concept of a
				  polymetric view, a lightweight software
				  visualization technique enriched with software
				  metrics information. Polymetric views help to
				  understand the structure and detect problems of a
				  software syst em in the initial phases of a reverse
				  engineering process. We discuss the benefits and
				  limits of several predefined polymetric views we
				  have implemented in our tool CodeCrawler. Moreover,
				  based on clusters of different polymetric views we
				  have developed a methodology which supports and
				  guides a software engineer in the first phases of a
				  reverse engineering of a large software system. We
				  have refined this methodology by repeatedly applying
				  it on industrial systems, and illustrate it by
				  applying a selection of polymetric views to a case
				  study.},
	Annote = {internationaljournal},
	Author = {Michele Lanza and St\'ephane Ducasse},
	Doi = {10.1109/TSE.2003.1232284},
	Journal = {Transactions on Software Engineering (TSE)},
	Keywords = {scg-pub scg-none jb04 recast04 stefPub moose-pub},
	Misc = {SCI impact factor 1.73},
	Month = sep,
	Number = {9},
	Pages = {782--795},
	Publisher = {IEEE Computer Society},
	Title = {Polymetric Views---A Lightweight Visual Approach to Reverse Engineering},
	Url = {http://scg.unibe.ch/archive/papers/Lanz03dTSEPolymetric.pdf},
	Volume = {29},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lanz03dTSEPolymetric.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/TSE.2003.1232284}}

@inproceedings{Lanz03e,
	Abstract = {CodeCrawler is a language independent software visu-
				  alization tool. It is mainly targeted at visualizing
				  object- oriented software, and in its newest
				  implementation it has become a general information
				  visualization tool. It has been validated in several
				  industrial case studies over the past few years. It
				  strongly adheres to lightweight princi- ples:
				  CodeCrawler implements and visualizes polymetric
				  views, lightweight visualizations of software
				  enriched with semantic information such as software
				  metrics and source code information.},
	Annote = {tooldemo},
	Author = {Michele Lanza},
	Booktitle = {Proceedings of VisSoft 2003 (2nd International Workshop on Visualizing Software for Understanding and Analysis)},
	Keywords = {recast04 scg-pub skip-doi scg-none jb04 moose-pub lanza},
	Pages = {51--52},
	Publisher = {IEEE CS Press},
	Title = {{CodeCrawler} --- A Lightweight Software Visualization Tool},
	Url = {http://scg.unibe.ch/archive/papers/Lanz03eVisSoft.pdf},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lanz03eVisSoft.pdf}}

@incollection{Lanz05b,
	Abstract = {CodeCrawler is an extensible and language
				  independent software visualization tool. It has been
				  validated in several industrial case studies over
				  the past years. CodeCrawler enables the fast
				  exploration of new visualization ideas. It
				  implements and visualizes polymetric views,
				  visualizations of software enriched with information
				  such as software metrics and other source code
				  semantics. It provides a rich set of views that can
				  be customized using a large set of metrics. While
				  CodeCrawler is mainly targeted at visualizing
				  object-oriented software, in its latest
				  implementation it has become a general information
				  visualization tool.},
	Address = {Milano},
	Aeres = {OS},
	Aeresstatus = {aeres08},
	Annote = {articlebook},
	Author = {Michele Lanza and St\'ephane Ducasse},
	Booktitle = {Tools for Software Maintenance and Reengineering},
	Inria = {hors},
	Isbn = {88-464-6396-X},
	Keywords = {scg-pub skip-doi stefPub recast05 scg-none jb05 moose-pub},
	Pages = {74--94},
	Publisher = {Franco Angeli},
	Selectif = {non},
	Series = {RCOST / Software Technology Series},
	Title = {{CodeCrawler} --- An Extensible and Language Independent 2D and 3D Software Visualization Tool},
	Url = {http://scg.unibe.ch/archive/papers/Lanz05bCCBookChapter.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lanz05bCCBookChapter.pdf}}

@incollection{Lemo13a,
	Abstract = {The goal of this roadmap paper is to summarize the state-of-the-art and identify research
		challenges when developing, deploying and managing self-adaptive software systems. Instead of dealing
		with a wide range of topics associated with the field, we focus on four essential topics of
		self-adaptation: design space for self-adaptive solutions, software engineering processes for
		self-adaptive systems, from centralized to decentralized control, and practical run-time verification
		& validation for self-adaptive systems. For each topic, we present an overview, suggest future
		directions, and focus on selected challenges. This paper complements and extends a previous roadmap on
		software engineering for self-adaptive systems published in 2009 covering a different set of topics,
		and reflecting in part on the previous paper. This roadmap is one of the many results of the Dagstuhl
		Seminar 10431 on Software Engineering for Self-Adaptive Systems, which took place in October 2010.},
	Author = {Lemos, Rog\'{e}rio and Giese, Holger and M\"{u}ller, Hausi and Shaw, Mary and Andersson, Jesper and Litoiu, Marin and Schmerl, Bradley and Tamura, Gabriel and Villegas, Norha and Vogel, Thomas and Weyns, Danny and Baresi, Luciano and Becker, Basil and Bencomo, Nelly and Brun, Yuriy and Cukic, Bojan and Desmarais, Ron and Dustdar, Schahram and Engels, Gregor and Geihs, Kurt and G\"{o}schka, Karl and Gorla, Alessandra and Grassi, Vincenzo and Inverardi, Paola and Karsai, Gabor and Kramer, Jeff and Lopes, Ant\'{o}nia and Magee, Jeff and Malek, Sam and Mankovskii, Serge and Mirandola, Raffaela and Mylopoulos, John and Nierstrasz, Oscar and Pezz\`{e}, Mauro and Prehofer, Christian and Sch\"{a}fer, Wilhelm and Schlichting, Rick and Smith, Dennis and Sousa, Jo\~{a}o Pedro and Tahvildari, Ladan and Wong, Kenny and Wuttke, Jochen},
	Booktitle = {Software Engineering for Self-Adaptive Systems II},
	Doi = {10.1007/978-3-642-35813-5_1},
	Editor = {Lemos, Rog\'{e}rio and Giese, Holger and M\"{u}ller, Hausi and Shaw, Mary},
	Isbn = {978-3-642-35812-8},
	Keywords = {scg-pub scg13 snf-none jb13},
	Medium = {2},
	Pages = {1-32},
	Peerreview = {yes},
	Publisher = {Springer Berlin Heidelberg},
	Series = {Lecture Notes in Computer Science},
	Title = {Software Engineering for Self-Adaptive Systems: A Second Research Roadmap},
	Url = {http://dx.doi.org/10.1007/978-3-642-35813-5_1},
	Volume = {7475},
	Year = {2013},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/978-3-642-35813-5_1}}

@inproceedings{Lesk16b,
	Abstract = {Promises are synchronization constructs that hide the complexity of process synchronisation from the developer by providing a placeholder for the result of a potentially incomplete computation performed in a concurrent process. Promises evaluated by remote processes pose challenges for debugging when the remote computation raises an exception. Current debuggers are either unaware that there is a problem in the remote computation or give developers access only to the context of the remote process. This does not allow developers to interact at the same time with the process that launched the promise and the remote process that executed the promise's computation. To improve debugging of remote promises, in this paper we propose a debugger interface that presents a unified view of both the original and the remote process, by merging the call chains of the two processes at the point where the promise was created. We exemplify our approach, discuss challenges for making it practical, and illustrate through an initial prototype that it can improve debugging of exceptions in remote promises.},
	Annote = {internationalworkshop},
	Author = {Max Leske and Andrei Chi\c{s} and Oscar Nierstrasz},
	Booktitle = {Proceedings of the International Workshop on Smalltalk Technologies},
	Series = {IWST' 16},
	Title = {A promising approach for debugging remote promises},
    Pages = {18:1--18:9},
	Year = {2016},
	Keywords = {scg-pub, snf-asa2, scg16, jb16, debugging, concurrency, threads, Andrei Chis, internationalworkshop},
	Url = {http://scg.unibe.ch/archive/papers/Lesk16b.pdf},
	doi = {10.1145/2991041.2991059},
	Peerreview = {yes},
	Language={English},
	Medium = {2},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lesk16b.pdf}
}

@article{Lesk17a,
  Abstract={Concurrency issues are inherently harder to identify and fix than issues in sequential programs, due to aspects like indeterminate order of access to shared resources and thread synchronisation. Live debuggers are often used by developers to gain insights into the behaviour of concurrent programs by exploring the call stacks of threads. Nevertheless, contemporary live debuggers for concurrent programs are usually sequential debuggers augmented with the ability to display different threads in isolation. To these debuggers every thread call stack begins with a designated start routine and the calls that led to the creation of the thread are not visible, as they are part of a different thread. This requires developers to manually link stack traces belonging to related but distinct threads, adding another burden to the already difficult act of debugging concurrent programs. To improve debugging of concurrent programs we address the problem of incomplete call stacks in debuggers through a thread and debugger model that enables live debugging of child threads within the context of their parent threads. The proposed debugger operates on a virtual thread that merges together multiple relevant threads. To better understand the features of debuggers for concurrent programs we present an in-depth discussion of the concurrency related features in current live debuggers. We test the applicability of the proposed model by instantiating it for simple threads, local and remote promises, and a remote object-oriented database. Starting from these use cases we further discuss implementation details ensuring a practical approach.},
  Title = {Improving live debugging of concurrent threads through thread histories},
  Journal = {Science of Computer Programming},
  Year = {2018},
  Volume = {161},
  Pages = {122-148},
  Issn = {0167-6423},
  Doi = {10.1016/j.scico.2017.10.005},
  Url = {http://scg.unibe.ch/archive/papers/Lesk17a.pdf},
  Author = {Max Leske and Andrei Chi\c{s} and Oscar Nierstrasz},
  Keywords = {scg-pub scg17 snf-asa2 jb18, Concurrency, Debugging, Promises, Smalltalk, Domain-specific tools, Andrei Chis},
  Peerreview = {yes},
  Language={English},
  Medium = {2},
  Annote = {internationaljournal},
  Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lesk17a.pdf},
  Bdsk-Url-2 = {http://www.sciencedirect.com/science/article/pii/S0167642317302174}
}

@inproceedings{Leue17b,
title={Harvesting the Wisdom of the Crowd to Infer Method Nullness in {Java}},
	author={Leuenberger, Manuel and Osman, Haidar and Ghafari, Mohammad and Nierstrasz, Oscar},
	booktitle={Proceedings of the 17th International Working Conference on Source Code Analysis and Manipulation},
    Annote    = {internationalconference},
	series = {SCAM 2017},
	year={2017},
	PeerReview = {yes},
	Medium = {2},
	location = {Shanghai, China},
	organization={IEEE},
	url = {http://scg.unibe.ch/archive/papers/Leue17b-InferMethodNullness.pdf},
	doi = {10.1109/SCAM.2017.22},
	keywords = {scg-pub snf-asa2 scg17 jb18},
	abstract = {Null pointer exceptions are common bugs in Java projects. Previous
research has shown that dereferencing the results of method calls is the main
source of these bugs, as developers do not anticipate that some methods return
null. To make matters worse, we find that whether a method returns null or not
(nullness), is rarely documented. We argue that method nullness is a vital piece of
information that can help developers avoid this category of bugs. This is
especially important for external APIs where developers may not even have access to
the code.
	In this paper, we study the method nullness of Apache Lucene, the de facto
standard library for text processing in Java. Particularly, we investigate how
often the result of each Lucene method is checked against null in Lucene clients.
We call this measure method nullability, which can serve as a proxy for method
nullness. Analyzing Lucene internal and external usage, we find that most methods
are never checked for null. External clients check more methods than Lucene checks
internally. Manually inspecting our dataset reveals that some null checks are
unnecessary. We present an IDE plugin that complements existing documentation and
makes up for missing documentation regard- ing method nullness and generates
nullness annotations, so that static analysis can pinpoint potentially missing or
unnecessary null checks.}
}

@inproceedings{Leue17c,
	title={{KOWALSKI}: Collecting {API} Clients in Easy Mode},
	author={Leuenberger, Manuel and Osman, Haidar and Ghafari, Mohammad and Nierstrasz, Oscar},
	booktitle={Proceedings of the 33rd International Conference on Software Maintenance and Evolution},
    Annote    = {internationalconference},
	series = {ICSME 2017},
	year={2017},
	PeerReview = {yes},
	Medium = {2},
	location = {Shanghai, China},
	organization={IEEE},
	url = {http://scg.unibe.ch/archive/papers/Leue17c-KowalskiCollectingApi.pdf},
	doi = {10.1109/ICSME.2017.78},
	keywords = {scg-pub snf-asa2 scg17 jb18},
	abstract = {Understanding API usage is important for upstream and downstream developers. However, compiling a dataset of API clients is often a tedious task, especially since one needs many clients to draw a representative picture of the API usage.
	In this paper, we present KOWALSKI, a tool that takes the name of an API, then finds and downloads client binaries by exploiting the Maven dependency management system. As a case study, we collect clients of Apache Lucene, the de facto standard for full-text search, analyze the binaries, and create a typed call graph that allows developers to identify hotspots in the API.
	A video demonstrating how KOWALSKI is used for this experiment can be found at https://youtu.be/zdx28GnoSRQ.}
}

@inproceedings{Leue19a,
 author = {Manuel Leuenberger},
 title = {Exploring Example-driven Migration},
 booktitle = {Proceedings of the Conference Companion of the 3rd International Conference on Art, Science, and Engineering of Programming},
 series = {Programming '19},
 PeerReview = {yes},
 Medium = {2},
 month = apr,
 year = {2019},
 isbn = {978-1-4503-6257-3},
 location = {Genova, Italy},
 pages = {29:1--29:3},
 articleno = {29},
 numpages = {3},
 url = {http://scg.unibe.ch/archive/papers/Leue19a.pdf},
 doi = {10.1145/3328433.3328463},
 acmid = {3328463},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {scg-pub snf-asa3 scg19 jb20},
 abstract = {Despite many research efforts to automate API usage migration, it remains often a manual task for developers. We aim to reduce the developer's pain by exploring ways to integrate the migration process into the IDE. Our migration workbench leverages API usage examples and interactive refactorings to migrate code from one API version to the other.}
}

@unpublished{Leue19b,
	Author = {Manuel Leuenberger},
	Title = {Can {I} Remove This Method? {How} Live Feedback from the Ecosystem Supports Co-Evolution},
	Note = {Presented at International Workshop on Smalltalk Technologies 2019},
	url = {http://scg.unibe.ch/archive/papers/Leue19b.pdf},
	PeerReview = {yes},
	Medium = {1},
	month = aug,
	year ={2019},
	keywords = {skip-doi scg-pub snf-asa3 scg19 jb20},
	abstract = {Albeit open-source projects have been co-evolving since years, upgrading a library can still be a tedious task for developers. APIs change over time, and breaking changes require precious developer time to adapt a dependent project's code. We present our vision on how embracing co-evolution in general, and library upgrades in specific, as a first-class citizen in our IDE, can support both API authors and API users. In a tiny self-experiment we show how API authors can profit from live feedback on the compatibility of their changes. API users can profit by being provided migrations to be applied on the dependent's code.}
}

@inproceedings{Lian02a,
	Abstract = {PECOS is a collaborative project between industrial
				  and research partners that seeks to enable
				  component-based technology for a class of embedded
				  systems known as "field devices". Results so far
				  include a component model for field devices and a
				  composition language for specifying connections
				  between software components. Here we investigate the
				  application of Rate Monotonic Analysis (RMA) to the
				  problem of generating real-time schedules for
				  compositions of field device components.},
	Annote = {internationalworkshop},
	Author = {Peng Liang and Gabriela Ar{\'e}valo and St\'ephane Ducasse and Michele Lanza and Nathanael Sch{\"a}rli and Roel Wuyts and Oscar Nierstrasz},
	Booktitle = {ECOOP 2002 Workshop Reader},
	Keywords = {scg-pub skip-doi scg-none jb02 pecos stefPub arevalo schaerli},
	Title = {Applying RMA for Scheduling Field Device Components},
	Url = {http://scg.unibe.ch/archive/papers/Lian02aPecosRMA.pdf},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lian02aPecosRMA.pdf}}

@inproceedings{Lien05a,
	Abstract = {Traits are basically mixins or interfaces but with
				  method bodies. In languages that support traits,
				  classes are composed out of traits. There are two
				  main advantages with traits. Firstly, decomposing
				  existing classes into traits from which they can be
				  recomposed improves the factoring of hierarchies.
				  Secondly it increases the library reuse potential by
				  providing more reusable traits. Identifying traits
				  and decomposing class hierarchies into traits is
				  therefore an important and challenging task to
				  facilitate maintainability and evolution. In this
				  paper we present how we use Formal Concept Analysis
				  to identify traits in inheritance hierarchies. Our
				  approach is two-staged: first we identify within a
				  hierarchy maximal groups of methods that have a set
				  of classes in common, second we cluster cohesive
				  groups of methods based on method invocations as
				  potential traits. We applied our approach on two
				  significant hierarchies and compare our results with
				  the manual refactorization of the same code which
				  was done by the authors of traits.},
	Acceptnum = {28},
	Accepttotal = {291},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference topconference},
	Author = {Adrian Lienhard and St\'ephane Ducasse and Gabriela Ar\'evalo},
	Booktitle = {ASE'05: Proceedings of the 20th International Conference on Automated Software Engineering},
	Cvs = {ConAnASE05Traits},
	Doi = {10.1145/1101908.1101921},
	Inria = {hors},
	Keywords = {scg-pub snf05 recast06 stefPub moose-pub arevalo scg-none jb06 listic},
	Medium = {2},
	Misc = {acceptance rate: 28/291 = 9\%},
	Month = nov,
	Pages = {66--75},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Rate = {9%},
	Selectif = {oui},
	Title = {Identifying Traits with Formal Concept Analysis},
	Url = {http://scg.unibe.ch/archive/papers/Lien05aIdentifyingTraits.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lien05aIdentifyingTraits.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1101908.1101921}}

@inproceedings{Lien06a,
	Abstract = {Most of today's dynamic analysis approaches are
				  based on method traces. However, in the case of
				  object-orientation understanding program execution
				  by analyzing method traces is complicated because
				  the behavior of a program depends on the sharing and
				  the transfer of object references (aliasing). We
				  argue that trace-based dynamic analysis is at a too
				  low level of abstraction for object-oriented
				  systems. We propose a new approach that captures the
				  life cycle of objects by explicitly taking into
				  account object aliasing and how aliases propagate
				  during the execution of the program. In this paper,
				  we present in detail our new meta-model and discuss
				  future tracks opened by it.},
	Annote = {internationalworkshop},
	Author = {Adrian Lienhard and St\'ephane Ducasse and Tudor G\^irba and Oscar Nierstrasz},
	Booktitle = {Proceedings International Workshop on Program Comprehension through Dynamic Analysis (PCODA'06)},
	Keywords = {scg-pub skip-doi stefPub girba scg-none jb07 fb06 snf07 object-flow dynamic-analysis},
	Medium = {2},
	Pages = {39--43},
	Peerreview = {yes},
	Title = {Capturing How Objects Flow At Runtime},
	Url = {http://scg.unibe.ch/archive/papers/Lien06aCapturingHowObjectsFlowPCODA06.pdf},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lien06aCapturingHowObjectsFlowPCODA06.pdf}}

@inproceedings{Lien07a,
	Abstract = {The domain-specific ontology of a software system
				  includes a set of features and their relationships.
				  While the problem of locating features in
				  object-oriented programs has been widely studied,
				  runtime dependencies between features are less well
				  understood. Features cannot be understood in
				  isolation, since their behavior often depends on
				  objects created and referenced in previously
				  exercised features. It is difficult to spot runtime
				  dependencies between features just by browsing
				  source code. Hence, code modifications intended for
				  one feature, often inadvertently affect other
				  features. In this paper, we propose an approach to
				  precisely identify dependencies between features
				  based on a fine-grained dynamic analysis which
				  captures details about how objects are referenced at
				  runtime. The results of two case studies indicate
				  that our approach helps software maintainers in
				  understanding critical feature dependencies.},
	Address = {Washington, DC, USA},
	Annote = {internationalconference},
	Author = {Adrian Lienhard and Orla Greevy and Oscar Nierstrasz},
	Booktitle = {Proceedings of the International Conference on Program Comprehension (ICPC'07)},
	Doi = {10.1109/ICPC.2007.38},
	Isbn = {0-7695-2860-0},
	Issn = {1063-6897},
	Keywords = {scg07 scg-pub jb07 snf07 moose-pub features object-flow dynamic-analysis},
	Medium = {2},
	Month = jun,
	Pages = {59--68},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Title = {Tracking Objects to detect Feature Dependencies},
	Url = {http://scg.unibe.ch/archive/papers/Lien07aFeatureDependencies.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lien07aFeatureDependencies.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICPC.2007.38}}

@inproceedings{Lien07b,
	Abstract = {Science requires tools, and computer science is no
				  different. In a typical research context however, it
				  is not known upfront how a tool should work.
				  Researching the tool's design is part of the
				  investigation process. Various designs have to be
				  prototyped and experimented with. This paper focuses
				  on the research process of interactive visualization
				  tools. We present how to improve development, so
				  that a novel tool can be tested and modified at
				  (almost) the same time. We present the Mondrian
				  framework, which supports on-the-fly prototyping of
				  interactive visualizations. As an example, we
				  present the research process of the Feature
				  Dependency Browser, a visualization tool which we
				  developed to allow software engineers inspect
				  runtime dependencies between features.},
	Address = {Los Alamitos, CA, USA},
	Annote = {internationalworkshop},
	Author = {Adrian Lienhard and Adrian Kuhn and Orla Greevy},
	Booktitle = {Proceedings IEEE International Workshop on Visualizing Software for Understanding (Vissoft'07)},
	Doi = {10.1109/VISSOF.2007.4290702},
	Isbn = {1-4244-0600-5},
	Keywords = {scg07 scg-pub snf07 jb07 moose-pub object-flow dynamic-analysis},
	Medium = {2},
	Month = jun,
	Pages = {67--70},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Title = {Rapid Prototyping of Visualizations using Mondrian},
	Url = {http://scg.unibe.ch/archive/papers/Lien07bMondrian.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lien07bMondrian.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/VISSOF.2007.4290702}}

@inproceedings{Lien07c,
	Abstract = {To extract abstract views of the behavior of an
				  object-oriented system for reverse engineering, a
				  body of research exists that analyzes a system's
				  runtime execution. Those approaches primarily
				  analyze the control flow by tracing method execution
				  events. However, they do not capture information
				  flows. We address this problem by proposing a novel
				  dynamic analysis technique named Object Flow
				  Analysis, which complements method execution tracing
				  with an accurate analysis of the runtime flow of
				  objects. To exemplify the usefulness of our analysis
				  we present a visual approach that allows a system
				  engineer to study classes and components in terms of
				  how they exchange objects at runtime. We illustrate
				  and validate our approach on two case studies.},
	Address = {New York, NY, USA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Adrian Lienhard and St\'ephane Ducasse and Tudor G\^irba},
	Booktitle = {Proceedings of the 2007 International Conference on Dynamic Languages (ICDL'07)},
	Doi = {10.1145/1352678.1352686},
	Inria = {hors},
	Isbn = {978-1-60558-084-5},
	Keywords = {scg07 scg-pub jb08 snf08 girba moose-pub object-flow dynamic-analysis},
	Location = {Lugano, Switzerland},
	Medium = {2},
	Pages = {121--140},
	Peerreview = {yes},
	Publisher = {ACM Digital Library},
	Selectif = {non},
	Title = {Object Flow Analysis --- Taking an Object-Centric View on Dynamic Analysis},
	Url = {http://scg.unibe.ch/archive/papers/Lien07c-ObjectFlowAnalysis.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lien07c-ObjectFlowAnalysis.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1352678.1352686}}

@inproceedings{Lien07d,
	Abstract = {We need to understand the impact of side effects
				  whenever changing complex object-oriented software
				  systems. This can be difficult as side effects are
				  at best implicit in static views of the software,
				  and typically execution traces do not capture data
				  flow between parts of the system. To solve this
				  problem, we complement execution traces with dynamic
				  object flow information. In our previous work we
				  analyzed object flows between features and classes.
				  In this paper, we use object flow information to
				  analyze side effects in execution traces and to
				  detect how future behavior in the trace is affected
				  by it. Using a visualization, the developer can
				  study how a selected part of the program accessed
				  program state and what side effect its execution
				  produced. Like this, the developer can investigate
				  how a particular part of the program works without
				  needing to understand the source code in detail. To
				  illustrate our approach, we use a running example of
				  writing unit tests for a legacy system.},
	Annote = {internationalworkshop},
	Author = {Adrian Lienhard and Tudor G\^irba and Orla Greevy and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 3rd International Workshop on Program Comprehension through Dynamic Analysis (PCODA'07)},
	Editor = {Andy Zaidman and Abdelwahab Hamou-Lhadj and Orla Greevy},
	Isbn = {978-0-7695-3034-5},
	Issn = {1872-5392},
	Keywords = {scg07 scg-pub snf08 skip-doi jb08 girba moose-pub object-flow dynamic-analysis},
	Medium = {2},
	Pages = {11--17},
	Peerreview = {yes},
	Publisher = {Technische Universiteit Delft},
	Title = {Exposing Side Effects in Execution Traces},
	Url = {http://scg.unibe.ch/archive/papers/Lien07dSideEffectsPCODA.pdf},
	url2 = {http://swerl.tudelft.nl/twiki/pub/Main/PCODA2007/PCODA2007proceedings.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lien07dSideEffectsPCODA.pdf%20http://swerl.tudelft.nl/twiki/pub/Main/PCODA2007/PCODA2007proceedings.pdf}}

@inproceedings{Lien08a,
	Abstract = {Writing unit tests for legacy systems is a key
				  maintenance task. When writing tests for
				  object-oriented programs, objects need to be set up
				  and the expected effects of executing the unit under
				  test need to be verified. If developers lack
				  internal knowledge of a system, the task of writing
				  tests is non-trivial. To address this problem, we
				  propose an approach that exposes side effects
				  detected in example runs of the system and uses
				  these side effects to guide the developer when
				  writing tests. We introduce a visualization called
				  Test Blueprint, through which we identify what the
				  required fixture is and what assertions are needed
				  to verify the correct behavior of a unit under test.
				  The dynamic analysis technique that underlies our
				  approach is based on both tracing method executions
				  and on tracking the flow of objects at runtime. To
				  demonstrate the usefulness of our approach we
				  present results from two case studies.},
	Annote = {internationalconference},
	Author = {Adrian Lienhard and Tudor G\^irba and Orla Greevy and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 12th European Conference on Software Maintenance and Reengineering (CSMR'08)},
	Doi = {10.1109/CSMR.2008.4493303},
	Keywords = {girba scg08 scg-pub visualization object-flow dynamic-analysis snf08 jb08},
	Medium = {2},
	Pages = {83--92},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society Press},
	Title = {Test Blueprints --- Exposing Side Effects in Execution Traces to Support Writing Unit Tests},
	Url = {http://scg.unibe.ch/archive/papers/Lien08a-TestBlueprint.pdf},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lien08a-TestBlueprint.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/CSMR.2008.4493303}}

@inproceedings{Lien08b,
	Abstract = {Back-in-time debuggers are extremely useful tools
				  for identifying the causes of bugs, as they allow us
				  to inspect the past states of objects no longer
				  present in the current execution stack.
				  Unfortunately the "omniscient" approaches that try
				  to remember all previous states are impractical
				  because they either consume too much space or they
				  are far too slow. Several approaches rely on
				  heuristics to limit these penalties, but they
				  ultimately end up throwing out too much relevant
				  information. In this paper we propose a practical
				  approach to back-in-time debugging that attempts to
				  keep track of only the relevant past data. In
				  contrast to other approaches, we keep object history
				  information together with the regular objects in the
				  application memory. Although seemingly
				  counter-intuitive, this approach has the effect that
				  past data that is not reachable from current
				  application objects (and hence, no longer relevant)
				  is automatically garbage collected. In this paper we
				  describe the technical details of our approach, and
				  we present benchmarks that demonstrate that memory
				  consumption stays within practical bounds.
				  Furthermore since our approach works at the virtual
				  machine level, the performance penalty is
				  significantly better than with other approaches.},
	Annote = {internationalconference},
	Author = {Adrian Lienhard and Tudor G\^irba and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 22nd European Conference on Object-Oriented Programming (ECOOP'08)},
	Doi = {10.1007/978-3-540-70592-5_25},
	Isbn = {978-3-540-70591-8},
	Keywords = {scg08 scg-pub object-flow snf08 jb08 girba},
	Medium = {2},
	Note = {{ECOOP} distinguished paper award},
	Pages = {592--615},
	Peerreview = {yes},
	Publisher = {Springer},
	Series = {LNCS},
	Title = {Practical Object-Oriented Back-in-Time Debugging},
	Url = {http://scg.unibe.ch/archive/papers/Lien08bBackInTimeDebugging.pdf},
	Volume = {5142},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lien08bBackInTimeDebugging.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-540-70592-5_25}}

@inproceedings{Lien09a,
	Abstract = {Conventional debugging tools present developers with
				  means to explore the run-time context in which an
				  error has occurred. In many cases this is enough to
				  help the developer discover the faulty source code
				  and correct it. However, rather often errors occur
				  due to code that has executed in the past, leaving
				  certain objects in an inconsistent state. The actual
				  run-time error only occurs when these inconsistent
				  objects are used later in the program. So-called
				  back-in-time debuggers help developers step back
				  through earlier states of the program and explore
				  execution contexts not available to conventional
				  debuggers. Nevertheless, even back-in-time debuggers
				  do not help answer the question, ``Where did this
				  object come from?'' The Object-Flow Virtual Machine,
				  which we have proposed in previous work, tracks the
				  flow of objects to answer precisely such questions,
				  but this VM does not provide dedicated debugging
				  support to explore faulty programs. In this paper we
				  present a novel debugger, called Compass, to
				  navigate between conventional run-time
				  stack-oriented control flow views and object flows.
				  Compass enables a developer to effectively navigate
				  from an object contributing to an error back-in-time
				  through all the code that has touched the object. We
				  present the design and implementation of Compass,
				  and we demonstrate how flow-centric, back-in-time
				  debugging can be used to effectively locate the
				  source of hard-to-find bugs.},
	Annote = {internationalconference},
	Author = {Adrian Lienhard and Julien Fierz and Oscar Nierstrasz},
	Booktitle = {Objects, Components, Models and Patterns, Proceedings of TOOLS Europe 2009},
	Doi = {10.1007/978-3-642-02571-6_16},
	Keywords = {scg09 scg-pub jb09 snf09},
	Medium = {2},
	Pages = {272--288},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Series = {LNBIP},
	Title = {Flow-Centric, Back-In-Time Debugging},
	Url = {http://scg.unibe.ch/archive/papers/Lien09aCompass.pdf},
	Volume = {33},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lien09aCompass.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-642-02571-6_16}}

@article{Lien08c,
	Abstract = {A large body of research analyzes the runtime
				  execution of a system to extract abstract behavioral
				  views. Those approaches primarily analyze control
				  flow by tracing method execution events or they
				  analyze object graphs of heap snapshots. However,
				  they do not capture how objects are passed through
				  the system at runtime. We refer to the exchange of
				  objects as the object flow, and we claim that object
				  flow is necessary to analyze if we are to understand
				  the runtime of an object-oriented application. We
				  propose and detail Object Flow Analysis, a novel
				  dynamic analysis technique that takes this new
				  information into account. To evaluate its
				  usefulness, we present a visual approach that allows
				  a developer to study classes and components in terms
				  of how they exchange objects at runtime. We
				  illustrate our approach on three case studies.},
	Aeres = {ACL},
	Aeresstatus = {aeres10},
	Annote = {internationaljournal},
	Author = {Adrian Lienhard and St\'ephane Ducasse and Tudor G\^irba},
	Doi = {10.1016/j.cl.2008.05.006},
	Inria = {hors},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {scg09 scg-pub girba moose-pub object-flow dynamic-analysis remoose jb09 snf09},
	Medium = {2},
	Number = {1},
	Pages = {63--79},
	Peerreview = {yes},
	Publisher = {Elsevier},
	Selectif = {non},
	Title = {Taking an Object-Centric View on Dynamic Information with Object Flow Analysis},
	Url = {http://scg.unibe.ch/archive/papers/Lien08cObjectFlowAnalysis.pdf},
	Volume = {35},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lien08cObjectFlowAnalysis.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.cl.2008.05.006}}

@article{Lien12a,
	Abstract = {Dynamic analysis is increasingly attracting
				  attention for debugging, profiling, and program
				  comprehension. Ten to twenty years ago, many dynamic
				  analyses investigated only simple method execution
				  traces. Today, in contrast, many sophisticated
				  dynamic analyses exist, for instance for detecting
				  memory leaks, analyzing ownership properties,
				  measuring garbage collector performance, or
				  supporting debugging tasks. These analyses depend on
				  complex program instrumentations and analysis
				  models, making it challenging to understand,
				  compare, and reproduce the proposed approaches.
				  While formal specifications and proofs are common in
				  the field of static analysis, most dynamic analyses
				  are specified using informal, textual descriptions.
				  In this article we propose a formal framework using
				  operational semantics that allows researchers to
				  precisely specify their dynamic analysis. Our goal
				  is to provide an accessible and reusable basis on
				  which researchers that may not be familiar with
				  rigorous specifications of dynamic analyses can
				  build. By extending the provided semantics, one can
				  concisely specify how runtime events are captured
				  and how this data is transformed to populate the
				  analysis model. Furthermore, our approach provides
				  the foundations to reason about properties of a
				  dynamic analysis.},
	Address = {Piscataway, NJ, USA},
	Annote = {internationaljournal},
	Author = {Adrian Lienhard and Tudor G\^irba and Oscar Nierstrasz},
	Doi = {10.1109/TSE.2011.38},
	Journal = {Transactions on Software Engineering},
	Keywords = {scg-pub scg12 jb11 snf10 girba ercim11},
	Medium = {2},
	Nb = {was Lien11a},
	Number = {3},
	Pages = {694--706},
	Peerreview = {yes},
	Publisher = {IEEE Press},
	Title = {Specifying Dynamic Analyses by Extending Language Semantics},
	Url = {http://scg.unibe.ch/archive/papers/Lien11aDynamicAnalysis.pdf},
	Volume = {38},
	Year = {2012},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lien11aDynamicAnalysis.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/TSE.2011.38}}

@inproceedings{Loew07a,
	Abstract = {While many software systems today have to be aware
				  of the context in which they are executing, there is
				  still little support for structuring a program with
				  respect to context. A first step towards better
				  context-orientation was the introduction of method
				  layers. This paper proposes two additional language
				  concepts, namely the implicit activation of method
				  layers, and the introduction of dynamic variables},
	Annote = {internationalconference},
	Author = {Martin von L\"owis and Marcus Denker and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 2007 International Conference on Dynamic Languages (ICDL 2007)},
	Doi = {10.1145/1352678.1352688},
	Isbn = {978-1-60558-084-5},
	Keywords = {scg07 scg-pub jb08 snf08},
	Medium = {2},
	Pages = {143--156},
	Peerreview = {yes},
	Publisher = {ACM Digital Library},
	Title = {Context-Oriented Programming: Beyond Layers},
	Url = {http://scg.unibe.ch/archive/papers/Loew07aPyContext.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Loew07aPyContext.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1352678.1352688}}

@inproceedings{Lump96a,
	Abstract = {We seek to support the development of open,
				  distributed applications from plug-compatible
				  software abstractions. In order to rigorously
				  specify these abstractions, we are elaborating a
				  formal object model for software composition in
				  which objects and related software abstractions are
				  viewed as patterns of communicating processes. The
				  semantic foundation is Milner's pi calculus, and the
				  starting point for our object model is Pierce and
				  Turner's encoding of objects as processes in the
				  experimental Pict programming language. Our
				  experience shows that common object-oriented
				  programming abstractions such as dynamic binding,
				  inheritance, genericity, and class variables are
				  most easily modelled when metaobjects are explicitly
				  reified as first class entities (i.e., processes).
				  Furthermore, various roles that are typically merged
				  (or confused) in object-oriented languages such as
				  classes, implementations, and metaobjects, each show
				  up as strongly-typed, first class processes},
	Address = {Leysin},
	Annote = {internationalconference},
	Author = {Markus Lumpe and Jean-Guy Schneider and Oscar Nierstrasz},
	Booktitle = {Proceedings of Languages et Mod\`eles \`a Objects},
	Keywords = {scg-pub skip-doi snf96 lmo96 pict pi olit scg-none jb96 scg-coord-old},
	Month = oct,
	Pages = {1--12},
	Title = {Using Metaobjects to Model Concurrent Objects with {PICT}},
	Url = {http://scg.unibe.ch/archive/papers/Lump96aMetaobjectsWithPict.pdf},
	Year = {1996},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lump96aMetaobjectsWithPict.pdf}}

@inproceedings{Lump97a,
	Abstract = {When do we call a software development environment a
				  composition environment? A composition environment
				  must be built of three parts: i) a reusable
				  component library, ii) a component framework
				  determining the software architecture, and iii) an
				  open and flexible composition language. Most of the
				  effort in component technology was spent on the
				  first two parts. Now it is crucial to address the
				  last part and find an appropriate model to glue
				  existing components together. In this work, we
				  investigate existing component and glue models,
				  define a set of requirements a composition language
				  must fulfill, and report our first results using a
				  prototype implementation of a general-purpose
				  composition language based on the Pi-calculus.},
	Address = {Zurich},
	Annote = {internationalworkshop},
	Author = {Markus Lumpe and Jean-Guy Schneider and Oscar Nierstrasz and Franz Achermann},
	Booktitle = {Proceedings of ESEC '97 Workshop on Foundations of Component-Based Systems},
	Editor = {Gary T. Leavens and Murali Sitaraman},
	Keywords = {scg-pub skip-doi glue scripting jpict composition onhindex(38) focbs97 snf97 scg-none jb97 scg-coord-98},
	Month = sep,
	Pages = {178--187},
	Title = {Towards a formal composition language},
	Url = {http://scg.unibe.ch/archive/papers/Lump97aAFormalCompLang.pdf},
	Year = {1997},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lump97aAFormalCompLang.pdf}}

@incollection{Lump00a,
	Abstract = {A composition language based on a formal semantic
				  foundation will facilitate precise specification of
				  glue abstractions and compositions, and will support
				  reasoning about their behaviour. The semantic
				  foundation, however, must address a set of
				  requirements like encapsulation, objects as
				  processes, components as abstractions, plug
				  compatibility, a formal object model, and
				  scalability. In this work, we propose the
				  piL-calculus, an extension of the pi-calculus, as a
				  formal foundation for software composition, define a
				  language in terms of it, and illustrate how this
				  language can be used to plug components together.},
	Author = {Markus Lumpe and Franz Achermann and Oscar Nierstrasz},
	Booktitle = {Foundations of Component Based Systems},
	Editor = {Gary Leavens and Murali Sitaraman},
	Keywords = {snf99 skip-doi pict pi scg-coord-99 scg-none jb00 scg-pub onhindex(55) piccola scg-coord-00},
	Pages = {69--90},
	Publisher = {Cambridge University Press},
	Title = {{A Formal Language for Composition}},
	Url = {http://scg.unibe.ch/archive/papers/Lump00aFormalLanguage.pdf},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lump00aFormalLanguage.pdf}}

@inproceedings{Lung05a,
	Abstract = {Using visualization and exploration tools can be of
				  great use for the understanding of a software system
				  when only its source code is available. However,
				  understanding a large software system by visualizing
				  only its lower level artifacts (e.g., classes,
				  methods) and the relations between them does not
				  scale for industrial-size systems. To address the
				  scalability issue, higher level hierarchical
				  abstractions (e.g., package structure, clustered
				  decompositions of the system) should be used
				  together with relations between them that are
				  usually aggregated from the lower level relations.
				  In this paper, we present the concepts behind
				  Softwarenaut, a tool aimed at exploring any kind of
				  hierarchical decompositions of a system, and then we
				  look at a specific exploration of a system. In the
				  experiment, the hierarchical decomposition of the
				  system is the result of applying a semantical
				  clustering to group classes that use similar terms.},
	Annote = {internationalworkshop},
	Author = {Mircea Lungu and Adrian Kuhn and Tudor G\^irba and Michele Lanza},
	Booktitle = {3rd International Workshop on Visualizing Software for Understanding and Analysis (VISSOFT 2005)},
	Doi = {10.1109/VISSOF.2005.1684313},
	Keywords = {scg-pub visualization girba moose-pub scg-none jb06 recast06 akuhn},
	Pages = {95--100},
	Title = {Interactive Exploration of Semantic Clusters},
	Url = {http://scg.unibe.ch/archive/papers/Lung05aExploreSemanticClusters.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lung05aExploreSemanticClusters.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/VISSOF.2005.1684313}}

@inproceedings{Lung06a,
	Abstract = {Recovering the architecture is the first step
				  towards reengineering a software system. Many
				  reverse engineering tools use top-down exploration
				  as a way of providing a visual and interactive
				  process for architecture recovery. During the
				  exploration process, the user navigates through
				  various views on the system by choosing from several
				  exploration operations. Although some sequences of
				  these operations lead to views which, from the
				  architectural point of view, are mode relevant than
				  others, current tools do not provide a way of
				  predicting which exploration paths are worth taking
				  and which are not. In this article we propose a set
				  of package patterns which are used for augmenting
				  the exploration process with in formation about the
				  worthiness of the various exploration paths. The
				  patterns are defined based on the internal package
				  structure and on the relationships between the
				  package and the other packages in the system. To
				  validate our approach, we verify the relevance of
				  the proposed patterns for real-world systems by
				  analyzing their frequency of occurrence in six
				  open-source software projects.},
	Address = {Los Alamitos CA},
	Annote = {internationalconference},
	Author = {Mircea Lungu and Michele Lanza and Tudor G\^irba},
	Booktitle = {Proceedings of CSMR 2006 (10th European Conference on Software Maintenance and Reengineering)},
	Doi = {10.1109/CSMR.2006.39},
	Keywords = {scg-pub visualization scg-none jb06 fb06 recast06 girba moose-pub norex06},
	Medium = {2},
	Pages = {185--196},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society Press},
	Title = {Package Patterns for Visual Architecture Recovery},
	Url = {http://scg.unibe.ch/archive/papers/Lung06aPackagePatterns.pdf},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lung06aPackagePatterns.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/CSMR.2006.39}}

@inproceedings{Lung07b,
	Abstract = {Software evolution research has been focused mostly
				  on analyzing the evolution of single software
				  systems. However, it is rarely the case that a
				  project exists as standalone, independent of others.
				  Rather, projects exist in parallel within larger
				  contexts in companies, research groups or even the
				  open-source communities, contexts that we call
				  super-repositories. In this paper, we argue that
				  visualization of super-repositories is useful in a
				  range of situations, and we describe Small Project
				  Observatory, a prototype tool which aims to
				  visualize super-repositories.},
	Annote = {internationalworkshop},
	Author = {Mircea Lungu and Tudor G\^irba},
	Booktitle = {Proceedings of International Workshop on Principles of Software Evolution (IWPSE 2007)},
	Doi = {10.1145/1294948.1294974},
	Isbn = {978-1-59593-722-3},
	Keywords = {scg07 scg-pub snf-none evolution visualization girba jb08 moose-pub norex07},
	Medium = {2},
	Pages = {106--109},
	Peerreview = {yes},
	Publisher = {ACM Press},
	Title = {A Small Observatory for Super-Repositories},
	Url = {http://scg.unibe.ch/archive/papers/Lung07bSmallProjectObservatory.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lung07bSmallProjectObservatory.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1294948.1294974}}

@inproceedings{Lung07c,
	Abstract = {Reverse engineering and software evolution research
				  has been focused mostly on analyzing single software
				  systems. However, rarely a project exists in
				  isolation; instead, projects exist in parallel
				  within a larger context given by a company, a
				  research group or the open-source community.
				  Technically, such a context manifests itself in the
				  form of super-repositories, containers of several
				  projects developed in parallel. Well-known examples
				  of such super-repositories include SourceForge and
				  CodeHaus. We present an easily accessible platform
				  which supports the analysis of such
				  super-repositories. The platform can be valuable for
				  reverse engineering both the projects and the
				  structure of the organization as reflected in the
				  interactions and collaborations between developers.
				  Throughout the paper we present various types of
				  analysis applied to three open-source and one
				  industrial Smalltalk super-repositories, containing
				  hundreds of projects developed by dozens of people.},
	Address = {Los Alamitos CA},
	Annote = {internationalconference},
	Author = {Mircea Lungu and Michele Lanza and Tudor G\^irba and Reinout Heeck},
	Booktitle = {Proceedings of WCRE 2007 (14th Working Conference on Reverse Engineering)},
	Doi = {10.1109/WCRE.2007.46},
	Isbn = {0-7695-3034-6},
	Issn = {1095-1350},
	Keywords = {snf-none scg-pub evolution visualization girba scg-none jb08 moose-pub},
	Medium = {2},
	Pages = {120--129},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society Press},
	Title = {Reverse Engineering Super-Repositories},
	Url = {http://scg.unibe.ch/archive/papers/Lung07cSuperRepositories.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lung07cSuperRepositories.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.2007.46}}

@inproceedings{Lung10a,
	Abstract = {In large software systems, knowing the dependencies
				  between modules or components is critical to
				  assess the impact of changes. To recover the
				  dependencies, fact extractors analyze the system
				  as a whole and build the dependency graph, parsing
				  the system down to the statement level. At the level
				  of software ecosystems, which are collections of
				  software projects, the dependencies that need to
				  be recovered reside not only within the individual
				  systems, but also between the libraries,
				  frameworks, and entire software systems that make up
				  the complete ecosystem; scaling issues arise. In
				  this paper we present and evaluate several variants
				  of a lightweight and scalable approach to recover
				  dependencies between the software projects of an
				  ecosystem. We evaluate our recovery algorithms on
				  the Squeak 3.10 Universe, an ecosystem containing
				  more than 200 software projects.},
	Annote = {internationalconference},
	Author = {Mircea Lungu and Romain Robbes and Michele Lanza},
	Booktitle = {ASE'10: Proceedings of the 25th IEEE/ACM International Conference on Automated Software Engineering},
	Doi = {10.1145/1858996.1859058},
	Keywords = {scg-bigdata scg-pub scg10 jb12 snf-none ecosystems lungu sde-ecosystems},
	PeerReview = {yes},
	Medium = {2},
	Publisher = {ACM Press},
	Title = {Recovering Inter-Project Dependencies in Software Ecosystems},
	Url = {http://scg.unibe.ch/archive/papers/Lung10a.pdf},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lung10a.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1858996.1859058}}

@article{Lung10b,
	Abstract = {Software evolution research has focused mostly on
				  analyzing the evolution of single software systems.
				  However, it is rarely the case that a project exists
				  as standalone, independent of others. Rather,
				  projects exist in parallel within larger contexts in
				  companies, research groups or even the open-source
				  communities. We call these contexts software
				  ecosystems, and on this paper we present The Small
				  Project Observatory, a prototype tool which aims to
				  support the analysis of project ecosystems through
				  interactive visualization and exploration. We
				  present a case-study of exploring an ecosystem using
				  our tool, we describe about the architecture of the
				  tool, and we distill the lessons learned during the
				  tool-building experience.},
	Annote = {internationaljournal},
	Author = {Mircea Lungu and Michele Lanza and Tudor G\^irba and Romain Robbes},
	Doi = {10.1016/j.scico.2009.09.004},
	Journal = {Science of Computer Programming, Elsevier},
	Keywords = {scg-pub scg10 jb10 hasler09 girba evol11 moose-pub},
	Medium = {2},
	Month = apr,
	Number = {4},
	Pages = {264--275},
	Peerreview = {yes},
	Title = {The {Small Project Observatory}: Visualizing Software Ecosystems},
	Url = {http://scg.unibe.ch/archive/papers/Lung09aSPO.pdf},
	Volume = {75},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lung09aSPO.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.scico.2009.09.004}}

@article{Lung12a,
	Abstract = {As a complex software system evolves, its architecture typically
		degrades, and thus it becomes progressively harder to understand and
		maintain. Softwarenaut is an interactive and collaborative tool that helps
		developers recover and consequently improve the architecture of such
		systems by offering mechanisms to represent, filter, query and manipulate
		architectural views of the system under analysis. Softwarenaut is an open
		and extensible tool that is part of the Moose software analysis platform,
		which is used for numerous academic and industrial projects related to
		software evolution.},
	Annote = {notrefereed},
	Author = {Mircea Lungu and Oscar Nierstrasz},
	Journal = {ERCIM News},
	Keywords = {scg-pub skip-doi jb12 snf12 scg12},
	Medium = {2},
	Month = jan,
	Peerreview = {no},
	Title = {Recovering Software Architecture with {Softwarenaut}},
	Url = {http://ercim-news.ercim.eu/en88/special/recovering-software-architecture-with-softwarenaut},
	Volume = 88,
	Year = {2012},
	Bdsk-Url-1 = {http://ercim-news.ercim.eu/en88/special/recovering-software-architecture-with-softwarenaut}}

@article{Lung12c,
	Abstract = {Research has been empowered by increased network bandwidth and raw computation power to analyze all of these artifacts at possibly massive scales. Therefore it shouldn't surprise us that current software engineering research uses the new wealth of information to improve the lives of software developers. Analysis of software ecosystems and super-repositories enters the realm of big software data. },
	Annote = {notrefereed},
	Author = {Mircea Lungu and Oscar Nierstrasz and Niko Schwarz},
	Journal = {ERCIM News},
	Keywords = {scg-pub skip-doi jb12 snf12 scg-bigdata scg12},
	Medium = {2},
	Month = apr,
	Peerreview = {no},
	Title = {Big Software Data Analysis},
	Url = {http://ercim-news.ercim.eu/en89/special/big-software-data-analysis},
	Volume = 89,
	Year = {2012},
	Bdsk-Url-1 = {http://ercim-news.ercim.eu/en89/special/big-software-data-analysis}}

@inproceedings{Lung13a,
	Annote = {internationalconference},
	Author = {Mircea Lungu and Jan Kur\v{s}},
	Abstract = {One of the long running debates between
	programmers is whether camelCaseldentifiers are better than
	underscore_identifiers. This is ultimately a matter of
	programming language culture and personal taste, and to our
	best knowledge none of the camps has won the argument yet. It
	is our intuition that a solution exists which is superior to
	both the previous ones from the point of view of usability:
	the solution we name sentence case identifiers allows phrases
	as nams for program entities such as classes or methods. In
	this paper we propose a study in which to evaluate the impact
	of sentence case identifiers in practice.},
	Booktitle = {{USER}'13: Proceedings of the 2nd Workshop on User evaluations for Software Engineering Researchers},
	Keywords = {scg-pub snf-asa1 scg13 jb14 lungu internationalworkshop, kursjan},
	Medium = {4},
	Pages = {13 - 15},
	Peerreview = {yes},
	Title = {On Planning an Evaluation of the Impact of Identifier Names on the Readability and Maintainability of Programs},
	Url = {http://scg.unibe.ch/archive/papers/Lung13a-Planning.pdf},
	doi = {10.1109/USER.2013.6603079},
	Year = {2013},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lung13a-Planning.pdf}}

@article{Lung14a,
	Abstract = {Architecture recovery is an activity applied to a system whose initial architecture has eroded. When the system is large, the user must use dedicated tools to support the recovery process. We present Softwarenaut -- a tool which supports architecture recovery through interactive exploration and visualization. Classical architecture recovery features, such as filtering and details on demand, are enhanced with evolutionary capabilities when multi-version information about a subject system is available. The tool allows sharing and discovering the results of previous analysis sessions through a global repository of architectural views indexed by systems. We present the features of the tool together with the architecture recovery process that it supports using as a case-study ArgoUML, a well-known open source Java system.},
	Annote = {internationaljournal},
	Author = {Mircea Lungu and Michele Lanza and Oscar Nierstrasz},
	Doi = {10.1016/j.scico.2012.04.007},
	Journal = {Science of Computer Programming},
	Keywords = {softwarenaut mircpub jb14 snf-asa1 scg-pub scg14},
	Medium = {2},
	Number = {0},
	Pages = {204 - 223},
	Peerreview = {yes},
	Publisher = {Elsevier},
	Title = {Evolutionary and Collaborative Software Architecture Recovery with {Softwarenaut}},
	Url = {http://scg.unibe.ch/archive/papers/Lung14a.pdf},
	Volume = {79},
	Year = {2014},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Lung14a.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.scico.2012.04.007}}

@inproceedings{Mari05a,
	Abstract = {To automatically analyze the code, the analyses must
				  be implemented as software programs. As analyses
				  become increasingly complex, implementing them using
				  imperative and interrogative programming is
				  oftentimes cumbersome. Consequently, the
				  understanding, testing and reuse of analyses is
				  severely hampered. In this paper we identify a set
				  of key mechanisms that are involved in the
				  implementation of any static analysis: navigation,
				  selection, set arithmetics, filtering and property
				  aggregation. We show that neither of the
				  aforementioned approaches offers a simple support
				  for these mechanisms and, as a result, an
				  undesirable overhead of complexity is added to the
				  implementation of most analyses. The paper
				  introduces SAIL, a language designed to offer a
				  proper support to a simplify writing of analyses. In
				  order to validate the expressiveness of SAIL the
				  paper provides a comprehensive comparison with the
				  other two approaches.},
	Annote = {internationalconference},
	Author = {Cristina Marinescu and Radu Marinescu and Tudor G\^irba},
	Booktitle = {METRICS 2005},
	Keywords = {scg-none jb06 scg-pub skip-doi girba recast06},
	Pages = {110--119},
	Title = {Towards a Simplified Implementation of Object-Oriented Design Metrics},
	Url = {http://scg.unibe.ch/archive/papers/Mari05aSAIL.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Mari05aSAIL.pdf}}

@inproceedings{Matt09a,
	Abstract = {For popular software systems, the number of daily
				  submitted bug reports is high. Triaging these
				  incoming reports is a time consuming task. Part of
				  the bug triage is the assignment of a report to a
				  developer with the appropriate expertise. In this
				  paper, we present an approach to automatically
				  suggest developers who have the appropriate
				  expertise for handling a bug report. We model
				  developer expertise using the vocabulary found in
				  their source code contributions and compare this
				  vocabulary to the vocabulary of bug reports. We
				  evaluate our approach by comparing the suggested
				  experts to the persons who eventually worked on the
				  bug. Using eight years of Eclipse development as a
				  case study, we achieve 33.6\% top-1 precision and
				  71.0\% top-10 recall.},
	Annote = {internationalconference},
	Author = {Dominique Matter and Adrian Kuhn and Oscar Nierstrasz},
	Booktitle = {MSR '09: Proceedings of the 2009 6th IEEE International Working Conference on Mining Software Repositories},
	Doi = {10.1109/MSR.2009.5069491},
	Keywords = {scg09 scg-pub jb09 snf09 akuhn},
	Location = {Vancouver, Canada},
	Medium = {2},
	Pages = {131--140},
	Peerreview = {yes},
	Publisher = {IEEE},
	Title = {Assigning Bug Reports using a Vocabulary-Based Expertise Model of Developers},
	Url = {http://scg.unibe.ch/archive/papers/Matt09aAssigningBugreports.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Matt09aAssigningBugreports.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/MSR.2009.5069491}}

@inproceedings{Meij96a,
	Abstract = {Creating applications using object-oriented
				  frameworks is done at a rela- tively low abstraction
				  level, leaving a large gap with the high abstraction
				  level of a de- sign. This makes the use of a
				  framework difficult, and allows design and
				  realization to diverge. Design patterns are more
				  specific elements of design, and thus reduce this
				  gap. We even bridge this gap by making design
				  patterns and the classes that play a role within
				  them into special purpose software components.
				  System realization becomes a matter of composing
				  special purpose class-components. We also introduce
				  a system, FACE, which supports the visual
				  composition of such specifications.},
	Author = {Theo Dirk Meijler and Robert Engel},
	Booktitle = {EuroPLoP preliminary Conference Proceedings},
	Keywords = {olit scg-pub skip-doi toBeChecked snf96 scg-none jb96},
	Month = jul,
	Title = {Making Design Patterns Explicit in {FACE}, a Framework Adaptive Composition Environment},
	Url = {http://scg.unibe.ch/archive/papers/Meij96aFACE.pdf},
	Year = {1996},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Meij96aFACE.pdf}}

@inproceedings{Meij96m,
	Abstract = {An object-oriented framework represents variations
				  in the application do-main via so-called hot spots.
				  Maturing the right set of hot spots requires an
				  iterative de-velopment process which gives rise to
				  incomplete framework documentation. This paper shows
				  that by measuring the changes between different
				  releases of the framework, it is possible to detect
				  undocumented hot spots. We expect that our work will
				  result in better documented and consequently more
				  reusable frameworks.},
	Author = {Theo Dirk Meijler and Serge Demeyer and Robert Engel},
	Booktitle = {Special Issues in Object-Oriented Programming (ECOOP '96 Workshop Reader)},
	Editor = {Max M{\"u}hlh{\"a}user},
	Isbn = {3-920993-67-51},
	Keywords = {olit famoos-papunr scg-pub skip-doi toBeChecked snf97 scg-none jb96 sergedem-papunr},
	Month = jul,
	Publisher = {dpunkt.verlag},
	Title = {Class Composition in {FACE}, a Framework Adaptive Composition Environment},
	Url = {http://scg.unibe.ch/archive/papers/Meij96mClassComposition.pdf},
	Year = {1996},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Meij96mClassComposition.pdf}}

@inproceedings{Meij97a,
	Abstract = {Tools incorporating design patterns combine the
				  advantage of having a high-abstraction level of
				  describing a system and the possibility of coupling
				  these abstractions to some underlying
				  implementation. Still, all cur-rent tools are based
				  on generating source code in which the design
				  patterns become implicit. After that, further
				  extension and adaptation of the software is needed
				  but this can no longer be supported at the same
				  level of abstraction. This paper presents FACE, an
				  environment based on an explicit representa-tion of
				  design patterns, sustaining an incremental
				  development style without abandoning the
				  higher-level design pattern abstraction. A visual
				  composition tool for FACE has been developed in the
				  Self programming language.},
	Author = {Theo Dirk Meijler and Serge Demeyer and Robert Engel},
	Booktitle = {Proceedings ESEC/FSE '97},
	Doi = {10.1007/3-540-63531-9_9},
	Editor = {M. Jazayeri and H. Schauer},
	Isbn = {978-3-540-63531-4},
	Keywords = {olit famoos-papref scg-pub toBeChecked snf97 scg-none jb97 sergedem-papref},
	Month = sep,
	Pages = {94--110},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Making Design Patterns Explicit in {FACE}, a Framework Adaptive Composition Environment},
	Url = {http://scg.unibe.ch/archive/papers/Meij97aExplicitDesignPatterns.pdf},
	Volume = {1301},
	Year = {1997},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Meij97aExplicitDesignPatterns.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/3-540-63531-9_9}}

@incollection{Meij97b,
	Abstract = {Traditional software development approaches do not
				  cope well with the evolving requirements of open
				  systems. We argue that such systems are best viewed
				  as flexible compositions of "software components"
				  designed to work together as part of a component
				  framework that formalizes a class of applications
				  with a common software architecture. To enable such
				  a view of software systems, we need appropriate
				  support from programming language technology,
				  software tools, and methods. We will briefly review
				  the current state of object-oriented technology,
				  insofar as it supports component-oriented
				  development, and propose a research agenda of topics
				  for further investigation.},
	Author = {Theo Dirk Meijler and Oscar Nierstrasz},
	Booktitle = {Cooperative Information Systems: Current Trends and Directions},
	Editor = {M.P. Papazoglou and G. Schlageter},
	Keywords = {olit scg-pub skip-doi scg-none jb-none snf96 omnrep onhindex(60)},
	Month = nov,
	Pages = {49--78},
	Publisher = {Academic Press},
	Title = {Beyond Objects: Components},
	Url = {http://scg.unibe.ch/archive/papers/Meij97bBeyondObjects.pdf},
	Year = {1997},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Meij97bBeyondObjects.pdf}}

@inproceedings{Mens01a,
	Abstract = {In current-day software development, programmers
				  often use programming patterns to clarify their
				  intents and to increase the understandability of
				  their programs. Unfortunately, most software
				  development environments do not adequately support
				  the declaration and use of such patterns. To
				  explicitly codify these patterns, we adopt a
				  declarative meta programming approach. In this
				  approach, we reify the structure of an
				  (object-oriented) program in terms of logic clauses.
				  We declare programming patterns as logic rules on
				  top of these clauses. By querying the logic system,
				  these rules allow us to check, enforce and search
				  for occurrences of certain patterns in the software.
				  As such, the programming patterns become an active
				  part of the software development and maintenance
				  environment.},
	Annote = {internationalconference},
	Author = {Kim Mens and Isabel Michiels and Roel Wuyts},
	Booktitle = {SEKE 2001 Proceedings},
	Doi = {10.1016/S0957-4174(02)00076-3},
	Keywords = {SOUL scg-pub scg-none jb02 snf02},
	Misc = {SCI impact factor 0.321},
	Note = {International conference on Software Engineering and Knowledge Engineering, Buenos Aires, Argentina, June 13-15, 2001},
	Pages = {236--243},
	Publisher = {Knowledge Systems Institute},
	Title = {Supporting Software Development through Declaratively Codified Programming Patterns},
	Url = {http://scg.unibe.ch/archive/papers/Mens01a.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Mens01a.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/S0957-4174(02)00076-3}}

@article{Mens01b,
	Abstract = {In current-day software development, programmers
				  often use programming patterns to clarify their
				  intents and to increase the understandability of
				  their programs. Unfortunately, most software
				  development environments do not adequately support
				  the declaration and use of such patterns. To
				  explicitly codify these patterns, we adopt a
				  declarative meta programming approach. In this
				  approach, we reify the structure of an
				  (object-oriented) program in terms of logic clauses.
				  We declare programming patterns as logic rules on
				  top of these clauses. By querying the logic system,
				  these rules allow us to check, enforce and search
				  for occurrences of certain patterns in the software.
				  As such, the programming patterns become an active
				  part of the software development and maintenance
				  environment.},
	Annote = {internationaljournal},
	Author = {Kim Mens and Isabel Michiels and Roel Wuyts},
	Doi = {10.1016/S0957-4174(02)00076-3},
	Institution = {Programming Technology Lab, Vrije Universiteit Brussel, Belgium},
	Journal = {SEKE 2001 Special Issue of Elsevier Journal on Expert Systems with Applications},
	Keywords = {SOUL scg-pub scg-none jb02 snf02},
	Misc = {Extended version of \cite{Mens01a}},
	Title = {Supporting Software Development through Declaratively Codified Programming Patterns},
	Url = {http://scg.unibe.ch/archive/papers/Mens01b.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Mens01b.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/S0957-4174(02)00076-3}}

@article{Mens02a,
	Abstract = {Metrics are essential in object-oriented software
				  engineering for several reasons, among which quality
				  assessment and improvement of development team
				  productivity. While the mathematical nature of
				  metrics calls for clear definitions, frequently
				  there exist many contradicting definitions of the
				  same metric depending on the implementation
				  language. We suggest to express and define metrics
				  using a language-independent metamodel based on
				  graphs. This graph-based approach allows for an
				  unambiguous definition of generic object-oriented
				  metrics and higher-order metrics. We also report on
				  some prototype tools that implement these ideas.},
	Author = {Tom Mens and Michele Lanza},
	Doi = {10.1016/S1571-0661(05)80529-8},
	Journal = {Electronic Notes in Theoretical Computer Science},
	Keywords = {scg-pub scg-none jb02 snf02},
	Number = {2},
	Publisher = {Elsevier Science},
	Title = {A Graph-Based Metamodel for Object-Oriented Software Metrics},
	Url = {http://scg.unibe.ch/archive/papers/Mens02a.pdf},
	Volume = {72},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Mens02a.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/S1571-0661(05)80529-8}}

@article{Mens03a,
	Abstract = {This paper reports on the results of the workshop on
				  Declarative Meta Programming to Support Software
				  Development in Edinburgh on September 23, 2002. It
				  enumerates the presentations made, classifies the
				  contributions and lists the main results of the
				  discussions held at the workshop. As such it
				  provides the context for future workshops around
				  this topic.},
	Annote = {workshopproceedings},
	Author = {Tom Mens and Roel Wuyts and Kris De Volder and Kim Mens},
	Doi = {10.1145/638750.638770},
	Journal = {ACM SIGSOFT Software Engineering Notes},
	Keywords = {snf03 scg-pub scg-none jb03},
	Month = jan,
	Number = {2},
	Title = {Workshop Proceedings --- Declarative Meta Programming to Support Software Development},
	Url = {http://scg.unibe.ch/archive/papers/Mens03a.pdf},
	Volume = {28},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Mens03a.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/638750.638770}}

@inproceedings{Meri14a,
	Annote = {internationalworkshop},
	Abstract = {Software developers often ask questions about software systems and software ecosystems
				that entail exploration and navigation, such as who uses this component?,
				and where is this feature implemented?. Software visualisation can be a
				great aid to understanding and exploring the answers to such questions,
				but visualisations require expertise to implement effectively, and they
				do not always scale well to large systems. We propose to automatically
				generate software visualisations based on software models derived from open
				source software corpora and from an analysis of the properties of typical
				developers queries and commonly used visualisations. The key challenges we
				see are (1) understanding how to match queries to suitable visualisations,
				and (2) scaling visualisations effectively to very large software systems
				and corpora. In the paper we motivate the idea of automatic software
				visualisation, we enumerate the challenges and our proposals to address them,
				and we describe some very initial results in our attempts to develop scalable
				visualisations of open source software corpora.},
	Author = {Merino, Leonel},
	Booktitle = {SATToSE'14: Pre-Proceedings of the 7th International Seminar Series on Advanced Techniques \& Tools for Software Evolution},
	Keywords = {scg-pub snf-asa1 skip-doi visualisations merino scg14 jb14},
	PeerReview = {yes},
	Medium = {1},
	Month = jul,
	Pages = {71--74},
	Title = {Adaptable Visualisation Based On User Needs},
	Year = {2014},
	Url = {http://scg.unibe.ch/archive/papers/Meri14a.pdf},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Meri14a.pdf}}

@inproceedings{Meri15a,
	Annote = {internationalworkshop},
        Abstract = {Visualisation provides good support for software analysis. It copes with
        the intangible nature of software by providing concrete representations of it. By
        reducing the complexity of software, visualisations are especially useful when
        dealing with large amounts of code. One domain that usually deals with large amounts
        of source code data is empirical analysis. Although there are many tools for
        analysis and visualisation, they do not cope well software corpora. In this paper we
        present Explora, an infrastructure that is specifically targeted at visualising
        corpora. We report on early results when conducting a sample analysis on Smalltalk
        and Java corpora.},
    Author = {Leonel Merino and Mircea Lungu and Oscar Nierstrasz},
    Booktitle = {SATToSE'14: Post-Proceedings of the 7th International Seminar Series on Advanced Techniques \& Tools for Software Evolution},
	Publisher = {{CEUR} Workshop Proceedings (CEUR-WS.org)},
	Volume = {1354},
	PeerReview = {yes},
	Medium = {1},
        Keywords = {scg-pub skip-doi visualisations merino scg15 jb15 snf-asa1},
	Title = {Explora: Infrastructure for Scaling Up Software Visualisation to Corpora},
    Year = {2015},
    Url = {http://scg.unibe.ch/archive/papers/Meri15a.pdf},
	Note = {http://ceur-ws.org/Vol-1354/},
    Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Meri15a.pdf}}

@inproceedings{Meri15b,
	Author    = {Leonel Merino and Mircea Lungu and Oscar Nierstrasz},
	Title     = {Explora: A Visualisation Tool for Metric Analysis of Software Corpora},
	Booktitle = {{VISSOFT}'15: Proceedings of the 3rd IEEE Working Conference on Software Visualization},
	Abstract  = {When analysing software metrics, users find that
			visualisation tools lack support for (1) the detection of patterns
			within metrics; and (2) enabling analysis of software corpora.
			In this paper we present Explora, a visualisation tool designed
			for the simultaneous analysis of multiple metrics of systems
			in software corpora. Explora incorporates a novel lightweight
			visualisation technique called PolyGrid that promotes the detection
			of graphical patterns. We present an example where we
			analyse the relation of subtype polymorphism with inheritance
			and invocation in corpora of Smalltalk and Java systems and
			find that (1) subtype polymorphism is more likely to be found
			in large hierarchies; (2) as class hierarchies grow horizontally,
			they also do so vertically; and (3) in polymorphic hierarchies the
			length of the name of the classes is orthogonal to the cardinality
			of the call sites.},
	Annote 	  = {internationalconference},
	Publisher = {IEEE},
	PeerReview = {yes},
	Medium    = {2},
	Keywords  = {scg-pub snf-asa1 scg15 jb16},
	Pages     = {195--199},
	Doi	  = {10.1109/VISSOFT.2015.7332436},
	Year      = {2015},
	Url       = {http://scg.unibe.ch/archive/papers/Meri15b.pdf}}

@inproceedings{Meri16a,
        Author    = {Leonel Merino and Mohammad Ghafari and Oscar Nierstrasz},
        Title     = {Towards Actionable Visualisation in Software Development},
        Booktitle = {{VISSOFT}'16: Proceedings of the 4th IEEE Working Conference on Software Visualization},
        Abstract  = {Although abundant studies have shown how visualisation can help software developers to perform their daily tasks, visualisation is still not a common practice since developers have little support for adopting a proper visualisation for their needs.
In this paper we review the 346 papers published in SOFTVIS/VISSOFT venues and identify 65 design study papers that describe how visualisation is used to alleviate various difficulties in software development. We classify these studies into several problem domains that we collected from the research on software development community, and highlight the characteristics of each study. On the one hand, we support software developers to put visualisation in action by mapping existing techniques to particular needs in various problem domains. On the other hand, we help researchers in the field by exposing domains with little visualisation support. We found a disconnect between the problem domains on which visualisation have focused and the domains that get the most attention from practitioners.},
        Annote    = {internationalconference},
        Publisher = {IEEE},
        PeerReview = {yes},
        Medium    = {2},
        Keywords  = {scg-pub snf-asa2 scg16 jb17},
        Doi       = {10.1109/VISSOFT.2016.10},
        Year      = {2016},
        Url       = {http://scg.unibe.ch/archive/papers/Meri16a.pdf}}

@inproceedings{Meri16b,
        Annote	= {internationalworkshop},
        Author	= {Leonel Merino and Dominik Seliner and Mohammad Ghafari and Oscar Nierstrasz},
        Booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2016)},
        Abstract = {Understanding the network of collaborations, identifying the key players, potential future collaborators, and trends in the field are very important to carry out a project successfully. In this paper, we present CommunityExplorer, a visualization framework that facilitates presenting, exploring, and understanding the network of collaborations at once. The framework performs data extraction, parsing, and modeling automatically. It is easy to adopt and utilizes a bigraph visualization that scales well. We demonstrate the advantage of CommunityExplorer to identify the collaboration of authors on 346 and 104 research papers published in SOTFVIS/VISSOFT and IWST communities respectively. We found that even though SOFTVIS/VISSOFT has more contributors, IWST exhibits more collaboration. We discovered that contributors in IWST are more resilient than those in SOFTVIS/VISSOFT, which are more volatile. Moreover, collaboration in IWST is concentrated in a single large group, while in SOFTVIS/VISSOFT it is spread among many tiny groups and a few medium-sized ones.},
	Keywords = {scg-pub snf-asa2 scg16 jb16},
        Peerreview = {yes},
        Title	= {{CommunityExplorer}: A Framework for Visualizing Collaboration Networks},
        Pages = {2:1--2:9},
        Year	= {2016},
        Medium	= {4},
	Doi     = {10.1145/2991041.2991043},
	Url	= {http://scg.unibe.ch/archive/papers/Meri16b.pdf}}

@inproceedings{Meri16c,
        Author    = {Leonel Merino and Mohammad Ghafari and Oscar Nierstrasz and Alexandre Bergel and Juraj Kubelka},
        Title     = {{MetaVis}: Exploring Actionable Visualization},
        Booktitle = {{VISSOFT}'16: Proceedings of the 4th IEEE Working Conference on Software Visualization},
        Abstract  = {Software visualization can be very useful for answering complex questions that arise in the software development process. Although modern visualization engines offer expressive APIs for building such visualizations, developers often have difficulties to (1) identify a suitable visualization technique to answer their particular development question, and to (2) implement that visualization using the existing APIs. Examples that illustrate the usage of an engine to build concrete visualizations offer a good starting point, but developers may have to traverse long lists of categories and analyze examples one-by-one to find a suitable one.
We propose MetaVis, a tool that fills the gap between existing visualization techniques and their practical applications during software development. We classify questions frequently formulated by software developers and for each, based on our expertise, identify suitable visualizations. MetaVis uses tags mined from these questions to offer a tag-iconic cloud-based visualization. Each tag links to suitable visualizations that developers can explore, modify and try out. We present initial results of an implementation of MetaVis in the Pharo programming environment. The tool visualizes 76 developers' questions assigned to 49 visualization examples.},
        Annote    = {internationalconference},
        Publisher = {IEEE},
        PeerReview = {yes},
        Medium    = {2},
        Keywords  = {scg-pub snf-asa2 scg16 jb17},
        Doi       = {10.1109/VISSOFT.2016.19},
        Year      = {2016},
        Url       = {http://scg.unibe.ch/archive/papers/Meri16c.pdf}}

@article{Meri17a,
        author = {Leonel Merino and Mohammad Ghafari and Oscar Nierstrasz},
        title = {Towards Actionable Visualization for Software Developers},
	Annote = {internationaljournal},
        journal = {Journal of Software: Evolution and Process},
		volume = {30},
		number = {2},
		issn = {2047-7481},
        PeerReview = {yes},
        Medium = {2},
        url = {http://scg.unibe.ch/archive/papers/Meri17a.pdf},
        doi = {10.1002/smr.1923},
		pages = {e1923--n/a},
        keywords = {scg-pub snf-asa2 scg18 jb18},
        year = {2017},
        abstract = {Abundant studies have shown that visualization is advantageous for software developers, yet adopting visualization during software development is not a common practice due to the large effort involved in finding an appropriate visualization. Developers require support to facilitate that task. Among 368 papers in SOFTVIS/VISSOFT venues, we identify 86 design study papers about the application of visualization to relieve concerns in software development. We extract from these studies the task, need, audience, data source, representation, medium and tool; and we characterize them according to the subject, process and problem domain. On the one hand, we support software developers to put visualization in action by mapping existing visualization techniques to particular needs from different perspectives. On the other hand, we highlight the problem domains that are overlooked in the field and need more support.}}

@inproceedings{Meri17b,
        Author    = {Leonel Merino and Johannes Fuchs and Michael Blumenschein and Craig Anslow and Mohammad Ghafari and Oscar Nierstrasz and Michael Behrisch and Daniel Keim},
        Title     = {On the Impact of the Medium in the Effectiveness of {3D} Software Visualization},
        Booktitle = {{VISSOFT}'17: Proceedings of the 5th IEEE Working Conference on Software Visualization},
        Abstract  = {Many visualizations have proven to be effective in supporting various software related tasks. Although multiple media can be used to display a visualization, the standard computer screen is used the most. We hypothesize that the medium has a role in their effectiveness. We investigate our hypotheses by conducting a controlled user experiment. In the experiment we focus on the 3D city visualization technique used for software comprehension tasks. We deploy 3D city visualizations across a standard computer screen (SCS), an immersive 3D environment (I3D), and a physical 3D printed model (P3D). We asked twenty-seven participants (whom we divided in three groups for each medium) to visualize software systems of various sizes, solve a set of uniform comprehension tasks, and complete a questionnaire. We measured the effectiveness of visualizations in terms of performance, recollection, and user experience. We found that even though developers using P3D required the least time to identify outliers, they perceived the least difficulty when visualizing systems based on SCS. Moreover, developers using I3D obtained the highest recollection.},
	Annote = {internationaljournal},
	Medium = {2},
        Keywords  = {scg-pub snf-asa2 scg17 jb18},
	Pages = {11--21},
        Doi = {10.1109/VISSOFT.2017.17},
        Publisher = {IEEE},
        PeerReview = {yes},
        Year      = {2017},
        Url       = {http://scg.unibe.ch/archive/papers/Meri17b.pdf}}

@inproceedings{Meri17c,
        Author    = {Leonel Merino and Mohammad Ghafari and Craig Anslow and Oscar Nierstrasz},
        Title     = {{CityVR}: Gameful Software Visualization},
        Booktitle = {{ICSME}'17: Proceedings of the 33rd IEEE International Conference on Software Maintenance and Evolution (TD Track)},
    Annote    = {internationalconference},
        Abstract  = {Gamification of software engineering tasks improve developer engagement, but has been limited to mechanisms such as points and badges. We believe that a tool that provides developers an interface analogous to computer games can represent the gamification of software engineering tasks more effectively via software visualization. We introduce CityVR -an interactive software visualization tool that implements the city metaphor technique using virtual reality in an immersive 3D environment medium to boost developer engagement in software comprehension tasks. We evaluated our tool with a case study based on ArgoUML. We measured engagement in terms of feelings, interaction, and time perception. We report on how our design choices relate to developer engagement. We found that developers i) felt curious, immersed, in control, excited, and challenged, ii) spent considerable interaction time navigating and selecting elements, and iii) perceived that time passed faster than in reality, and therefore were willing to spend more time using the tool to solve software engineering tasks.},
        Publisher = {IEEE},
        PeerReview = {yes},
        Medium = {2},
        Keywords  = {scg-pub snf-asa2 scg17 jb18},
	Pages = {633--637},
        Doi = {10.1109/ICSME.2017.70},
        Year      = {2017},
        Url       = {http://scg.unibe.ch/archive/papers/Meri17c.pdf}}

@article{Meri18a,
	title = {A Systematic Literature Review of Software Visualization Evaluation},
	journal = {Journal of Systems and Software},
	volume = {144},
	pages = {165-180},
	year = {2018},
	month = oct,
	issn = {0164-1212},
	doi = {10.1016/j.jss.2018.06.027},
	Annote = {internationaljournal},
	url = {http://scg.unibe.ch/archive/papers/Meri18a.pdf},
	author = {Leonel Merino and Mohammad Ghafari and Craig Anslow and Oscar Nierstrasz},
	keywords = {scg-pub snf-asa2 scg18 jb18},
	abstract = {Abstract Context: Software visualizations can help
		developers to analyze multiple aspects of complex software systems, but
		their effectiveness is often uncertain due to the lack of evaluation
		guidelines. Objective: We identify common problems in the evaluation of
		software visualizations with the goal of formulating guidelines to
		improve future evaluations. Method: We review the complete literature
		body of 387 full papers published in the SOFTVIS/VISSOFT conferences, and
		study 181 of those from which we could extract evaluation strategies,
		data collection methods, and other aspects of the evaluation. Results: Of
		the proposed software visualization approaches, 62% lack a strong
		evaluation. We argue that an effective software visualization should not
		only boost time and correctness but also recollection, usability,
		engagement, and other emotions. Conclusion: We call on researchers
		proposing new software visualizations to provide evidence of their
		effectiveness by conducting thorough (i) case studies for approaches that
		must be studied in situ, and when variables can be controlled, (ii)
		experiments with randomly selected participants of the target audience
		and real-world open source software systems to promote reproducibility
		and replicability. We present guidelines to increase the evidence of the
		effectiveness of software visualization approaches, thus improving their
		adoption rate.}
}

@inproceedings{Meri18c,
    Author    = {Leonel Merino and Alexandre Bergel and Oscar Nierstrasz},
    Title     = {Overcoming Issues of {3D} Software Visualization through Immersive Augmented Reality},
    Booktitle = {{VISSOFT}'18: Proceedings of the 6th IEEE Working Conference on Software Visualization},
    Abstract  = {Several usability issues (i.e., navigation, occlusion, selection, and text readability) affect the few 3D visualizations proposed to support developers on software engineering tasks. We observe that most 3D software visualizations are displayed on a standard computer screen, and hypothesize that displaying them in immersive augmented reality can help to (i) overcome usability issues of 3D visualizations, and (ii) increase their effectiveness to support software concerns. We investigate our hypothesis via a controlled experiment. In it, nine participants use 3D city visualizations displayed on a Microsoft HoloLens device to complete a set of software comprehension tasks. We further investigate our conjectures through an observational user study, in which the same participants of the experiment use a space-time cube visualization to analyze program executions. We collect data to (1) quantitatively analyze the effectiveness of visualizations in terms of user performance (i.e., completion time, correctness, and recollection), and user experience (i.e., difficulty, and emotions); and (2) qualitatively analyze how immersive augmented reality helps to overcome the limitations of 3D visualizations. We found that immersive augmented reality facilitates navigation and reduces occlusion, while performance is adequate, and developers obtain an outstanding experience. Selection and text readability still remain open issues.},
    Annote    = {internationalconference},
    Keywords  = {scg-pub snf-asa2 scg18 jb19},
    Publisher = {IEEE},
    PeerReview = {yes},
	Medium = {2},
    Year      = {2018},
	Doi       = {10.1109/VISSOFT.2018.00014},
	Pages     = {54--64},
    Url       = {http://scg.unibe.ch/archive/papers/Meri18c.pdf}}

@inproceedings{Meri19a,
 author = {Merino, Leonel and Hess, Mario and Bergel, Alexandre and Nierstrasz, Oscar and Weiskopf, Daniel},
 title = {{PerfVis}: Pervasive Visualization in Immersive Augmented Reality for Performance Awareness},
 abstract = {Developers are usually unaware of the impact of code changes
	to the performance of software systems. Although developers
	can analyze the performance of a system by executing, for
	instance, a performance test to compare the performance of two
	consecutive versions of the system, changing from a
	programming task to a testing task would disrupt the
	development flow. In this paper, we propose the use of a city
	visualization that dynamically provides developers with a
	pervasive view of the continuous performance of a system. We
	use an immersive augmented reality device (Microsoft HoloLens)
	to display our visualization and extend the integrated
	development environment on a computer screen to use the
	physical space. We report on technical details of the design
	and implementation of our visualization tool, and discuss
	early feedback that we collected of its usability. Our
	investigation explores a new visual metaphor to support the
	exploration and analysis of possibly very large and
	multidimensional performance data. Our initial result
	indicates that the city metaphor can be adequate to analyze
	dynamic performance data on a large and non-trivial software
	system.},
 booktitle = {Companion of the 2019 ACM/SPEC International Conference on Performance Engineering},
 series = {ICPE '19},
 year = {2019},
 isbn = {978-1-4503-6286-3},
 location = {Mumbai, India},
 pages = {13--16},
 numpages = {4},
 Url = {http://scg.unibe.ch/archive/papers/Meri19a-perfvis.pdf},
 doi = {10.1145/3302541.3313104},
    PeerReview = {yes},
	Medium = {2},
   Annote    = {internationalconference},
 acmid = {3313104},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {scg-pub jb19 scg19 snf-asa3 performance engineering, software visualization}
}

@inproceedings{Meri19b,
    Author    = {Leonel Merino and Ekaterina Kozlova and Oscar Nierstrasz and Daniel Weiskopf},
    Title     = {{VISON}: An Ontology-Based Approach for Software Visualization Tool Discoverability},
    Booktitle = {{VISSOFT}'19: Proceedings of the 7th IEEE Working Conference on Software Visualization},
    Abstract  = {Although many tools have been presented in the research
		literature of software visualization, there is little
		evidence of their adoption. To choose a suitable
		visualization tool, practitioners need to analyze various
		characteristics of tools such as their supported software
		concerns and level of maturity. Indeed, some of such
		tools can be prototypes for which the lifespan is
		expected to be short, whereas some other tools can be
		fairly mature products that are maintained for a longer
		time. Although such characteristics are often described
		in papers, we conjecture that practitioners willing to
		adopt software visualizations require additional support
		to discover suitable visualization tools. In this paper,
		we elaborate on our efforts to provide such support. To
		this end, we systematically analyzed research papers in
		the literature of software visualization and curated a
		catalog of 70 available tools that employ various
		visualization techniques to support the analysis of
		multiple software concerns. We further encapsulate these
		characteristics in an ontology. VISON, our software
		visualization ontology, captures these semantics as
		concepts and relationships. We report on early results of
		usage scenarios that demonstrate how the ontology can
		support (i) developers to find suitable tools for
		particular development concerns, and (ii) researchers who
		propose new software visualization tools to identify a
		baseline tool for a controlled experiment.},
    Annote    = {internationalconference},
	DOI = {10.1109/VISSOFT.2019.00014},
    Url = {http://scg.unibe.ch/archive/papers/Meri19b-vison.pdf},
    Keywords  = {scg-pub snf-asa3 scg19 jb20},
    Publisher = {IEEE},
    PeerReview = {yes},
	Medium = {2},
    Year = {2019}
}

@inproceedings{Meye06a,
	Abstract = {Data visualization is the process of representing
				  data as pictures to support reasoning about the
				  underlying data. For the interpretation to be as
				  easy as possible, we need to be as close as possible
				  to the original data. As most visualization tools
				  have an internal meta-model, which is different from
				  the one for the presented data, they usually need to
				  duplicate the original data to conform to their
				  meta-model. This leads to an increase in the
				  resources needed, increase which is not always
				  justified. In this work we argue for the need of
				  having an engine that is as close as possible to the
				  data and we present our solution of moving the
				  visualization tool to the data, instead of moving
				  the data to the visualization tool. Our solution
				  also emphasizes the necessity of reusing basic
				  blocks to express complex visualizations and
				  allowing the programmer to script the visualization
				  using his preferred tools, rather than a third party
				  format. As a validation of the expressiveness of our
				  framework, we show how we express several already
				  published visualizations and describe the pros and
				  cons of the approach.},
	Address = {New York, NY, USA},
	Annote = {internationalconference},
	Author = {Michael Meyer and Tudor G\^irba and Mircea Lungu},
	Booktitle = {ACM Symposium on Software Visualization (SoftVis'06)},
	Doi = {10.1145/1148493.1148513},
	Keywords = {hasler07 scg-pub girba visualization scg-none jb07 fb06 mooseCincom norex06 moose-pub sde-visualization},
	Medium = {2},
	Pages = {135--144},
	Peerreview = {yes},
	Publisher = {ACM Press},
	Title = {Mondrian: An Agile Visualization Framework},
	Url = {http://scg.unibe.ch/archive/papers/Meye06aMondrian.pdf},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Meye06aMondrian.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1148493.1148513}}

@inproceedings{Milo14a,
	Annote = {internationalworkshop},
	Abstract = {Polymorphism, along with inheritance, is one of the most important
		features in object-oriented languages, but it is also one of the biggest
		obstacles to source code comprehension. Depending on the run-time type of the
		receiver of a message, any one of a number of possible methods may be invoked.
		Several algorithms for creating accurate call-graphs using static analysis
		already exist, however, they consume significant time and memory resources. We
		propose an approach that will combine static and dynamic analysis and yield the
		best possible precision with a minimal trade-off between used resources and
		accuracy.},
	Author = {Milojkovi\'{c}, Nevena},
	Booktitle = {SATToSE'14: Pre-Proceedings of the 7th International Seminar Series on Advanced Techniques \& Tools for Software Evolution},
	PeerReview = {yes},
	Medium = {1},
	Keywords = {scg-pub snf-asa1 skip-doi dynamic analysis scg14 jb14 Milojkovic Milojkovi\'{c}},
	Month = jul,
	Pages = {54--55},
	Title = {Towards cheap, accurate polymorphism detection},
	Year = {2014},
	Url = {http://scg.unibe.ch/archive/papers/Milo14a.pdf},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Milo14a.pdf}}

@inproceedings{Milo15a,
	Abstract = {Subtype polymorphism is a cornerstone of object-oriented programming. By
	hiding variability in behavior behind a uniform interface, polymorphism
	decouples clients from providers and thus enables genericity, modularity and extensi-
	bility. At the same time, however, it scatters the implementation of the behavior over
	multiple classes thus potentially hampering program comprehension. The extent to which
	polymorphism is used in real programs and the impact of polymorphism on program
	comprehension are not very well understood. We report on a preliminary study of the
	prevalence of polymorphism in several hundred open source software systems written in
	Smalltalk, one of the oldest object-oriented programming languages, and in Java, one of
	the most widespread ones. Although a large portion of the call sites in these systems are
	polymorphic, a majority have a small number of potential candidates. Smalltalk uses
	polymorphism to a much greater extent than Java. We discuss how these findings can be used
	as input for more detailed studies in program comprehension and for better developer
	support in the IDE.},
	Author = {Nevena Milojkovi\'{c} and Andrea Caracciolo and Mircea Lungu and Oscar Nierstrasz and David R\"{o}thlisberger and Romain Robbes},
	Booktitle = {Proceedings of the 2015 IEEE 23rd International Conference on Program Comprehension},
	location = {Florence, Italy},
	Issn = {1063-6897},
	Keywords = {scg-pub snf-asa1 scg15 jb15 Milojkovic Milojkovi\'{c}},
	Medium = {2},
	Pages = {186--195},
	numpages = {10},
	Peerreview = {yes},
	Title = {Polymorphism in the Spotlight: Studying its Prevalence in {Java} and {Smalltalk}},
	Note = {Published},
	Year = {2015},
	Publisher = {IEEE Press},
	doi={10.1109/ICPC.2015.29},
	Url = {http://scg.unibe.ch/archive/papers/Milo15a.pdf}
}

@inproceedings{Milo16a,
	Abstract = {Dynamically typed languages allow developers to write more expressive source code, but their lack of static information about types of variables is one of the main
obstacles during program comprehension and maintenance. Static type information reduces the complexity of a program.
Most of the type inference algorithms suffer from the problem of false positives or negatives. Complex approaches are required to avoid this problem.
We propose a simple heuristic that uses easily accessible run-time information about the usage of each class as a receiver type for a message send. This frequency serves as a proxy for the likelihood that a variable belongs to that class at run time and is used to promote the correct type towards the top of the list of possible types for a variable.
Our evaluation of a proof-of-concept prototype implemented in Pharo Smalltalk shows that our heuristic is reason- ably precise to detect both library and project-related types on average in 65.92% to 82.83% of cases.},
	Annote = {internationalworkshop},
	Author = {Nevena Milojkovi\'{c} and Cl\'ement B\'era and Mohammad Ghafari and Oscar Nierstrasz},
	Booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2016)},
	Keywords = {scg-pub snf-asa2 scg16 jb16 Milojkovic},
	PeerReview = {yes},
	Pages = {6:1--6:11},
	Title = {Inferring Types by Mining Class Usage Frequency from Inline Caches},
	Year = {2016},
	DOI = {10.1145/2991041.2991047},
	Medium = {4},
	Url = {http://scg.unibe.ch/archive/papers/Milo16a.pdf}
}

@inproceedings{Milo16b,
	Abstract = {Although dynamically typed languages allow developers to be more productive in writing source code, their lack of information about types of variables is one of the main obstacles during program comprehension. Static type information helps developers to decrease software maintenance time.
Inferring the types of variables requires complex algorithms in order to avoid false positives or negatives. Their main aim is to shorten the list of possible types for a variable.
We have developed a couple of cheap heuristics that use easily accessible information about the presence of each class in the available source code to promote the correct type towards the top of the list of possible types for a variable.
Our evaluation of a proof-of-concept prototype, implemented in Pharo Smalltalk, shows that both for domain- specific types and standard libraries these heuristics tend to work well. The evaluated heuristics prove to be reasonably precise, promoting the correct types of a variable towards the top of the list in 50.67% up to 89.09% of cases on average, depending on the applied heuristic. The heuristic that has proven to be the best was compared with one existing type inference algorithm and the best heuristic yields significantly better results with less effort.},
	Annote = {internationalconference},
	Author = {Nevena Milojkovi\'{c} and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 2016 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software, Onward! 2016},
	Keywords = {scg-pub snf-asa2 scg16 jb17 Milojkovic},
	PeerReview = {yes},
	Title = {Exploring Cheap Type Inference Heuristics in Dynamically Typed Languages},
    	doi = {10.1145/2986012.2986017},
	isbn = {978-1-4503-4076-2},
	location = {Amsterdam, Netherlands},
	pages = {43--56},
	publisher = {ACM},
	address = {New York, NY, USA},
	Year = {2016},
	Medium = {2},
	Url = {http://scg.unibe.ch/archive/papers/Milo16b.pdf}
	}

@inproceedings{Milo17a,
	Author = {Nevena Milojkovi\'{c} and Mohammad Ghafari and Oscar Nierstrasz},
	abstract = {The lack of static type information is one of the main obstacles to program comprehension in dynamically-typed languages. While static type inference algorithms try to remedy this problem, they usually suffer from the problem of false positives or false negatives.
In order to partially compensate for the lack of static type information, a common practice in dynamically-typed languages is to name or annotate method arguments in such a way that they reveal their expected type, e.g., aString, anInt, or string: String. Recent studies confirmed that these type annotations are indeed frequently used by developers in dynamically-typed languages.
We propose a lightweight heuristic that uses these hints from method argument names to augment the performance of a static type inference algorithm. The evaluation through a proof-of-concept prototype implemented in Pharo Smalltalk shows that the augmented algorithm outperforms the basic algorithm, and correctly infers types for 81% more method arguments.},
	location = {Buenos Aires, Argentina},
	Keywords = {scg-pub snf-asa2 scg17 jb17 Milojkovic},
	Peerreview = {yes},
	doi = {10.1109/ICPC.2017.33},
	Medium = {2},
	Booktitle = {25th IEEE International Conference on Program Comprehension},
    Annote    = {internationalconference},
	Title = {Exploiting Type Hints in Method Argument Names to Improve Lightweight Type Inference},
	Url = {http://scg.unibe.ch/archive/papers/Milo17a.pdf},
	Year = {2017}
}

@inproceedings{Milo17b,
	Author = {Nevena Milojkovi\'{c} and Mohammad Ghafari and Oscar Nierstrasz},
	location = {Buenos Aires, Argentina},
	abstract = {Duck typing provides a way to reuse code and allow a developer to write more extensible code. At the same time, it scatters the implementation of a functionality over multiple classes and causes difficulties in program comprehension.
The extent to which duck typing is used in real programs is not very well understood. We report on a preliminary study of the prevalence of duck typing in more than a thousand dynamically-typed open source software systems developed in Smalltalk.
Although a small portion of the call sites in these systems is duck-typed, in half of the analysed systems at least 20% of methods are duck-typed.},
	Keywords = {scg-pub snf-asa2 scg17 jb17 Milojkovic},
	Peerreview = {yes},
	doi = {10.1109/ICPC.2017.10},
	Medium = {2},
	Booktitle = {25th IEEE International Conference on Program Comprehension (ERA Track)},
    Annote    = {internationalconference},
	Title = {It's Duck (Typing) Season!},
	Url = {http://scg.unibe.ch/archive/papers/Milo17b.pdf},
	Year = {2017}
}

@inproceedings{Milo17c,
	Annote = {internationalworkshop},
	Abstract = {Dynamically-typed languages allow faster
software development by not posing the type
constraints. Static type information facilitates
program comprehension and software maintenance.
Type inference algorithms attempt
to reconstruct the type information from the
code, yet they suffer from the problem of
false positives or false negatives. The use of
complex type inference algorithms is questionable
during the development phase, due to
their performance costs. Instead, we propose
lightweight heuristics to improve simple type
inference algorithms and, at the same time,
preserve their swiftness.},
	Author = {Milojkovi\'{c}, Nevena},
	Booktitle = {SATToSE'17: Pre-Proceedings of the 10th International Seminar Series on Advanced Techniques \& Tools for Software Evolution},
	PeerReview = {yes},
	Medium = {1},
	Keywords = {scg-pub snf-asa2 scg17 jb17 skip-doi Milojkovic Milojkovi\'{c}},
	Month = jun,
	location = {Madrid, Spain},
	Title = {Improving the Precision of Type Inference Algorithms with Lightweight Heuristics},
	Year = {2017},
	Url = {http://scg.unibe.ch/archive/papers/Milo17c.pdf},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Milo17c.pdf}}

@article{Milo17e,
	Abstract = {The lack of static type information in dynamically-typed languages often
		poses obstacles for developers. Type inference algorithms can
		help, but inferring precise type information requires complex
		algorithms that are often slow. A simple approach that considers only
		the locally used interface of variables can identify potential classes
		for variables, but popular interfaces can generate a large number of
		false positives. We propose an approach called inline-cache type
		inference (ICTI) to augment the precision of fast and simple type
		inference algorithms. ICTI uses type information available in the
		inline caches during multiple software runs, to provide a ranked list
		of possible classes that most likely represent a variable's type. We
		evaluate ICTI through a proof-of-concept that we implement in Pharo
		Smalltalk. The analysis of the top-n+2 inferred types (where n is the
		number of recorded run-time types for a variable) for 5486 variables
		from four different software systems shows that ICTI produces
		promising results for about 75% of the variables. For more than 90% of
		variables, the correct run-time type is present among first six
		inferred types. Our ordering shows a twofold improvement when compared
		with the unordered basic approach, i.e., for a significant number of
		variables for which the basic approach offered ambiguous results, ICTI
		was able to promote the correct type to the top of the list.},
	Annote = {internationaljournal},
	Author = {Nevena Milojkovi\'{c} and Cl\'ement B\'era and Mohammad Ghafari and Oscar Nierstrasz},
	Journal = {Science of Computer Programming, Elsevier, Special Issue on Adv. Dynamic Languages},
	Keywords = {scg-pub scg17 snf-asa2 jb18},
	Peerreview = {yes},
	Medium = {2},
	Doi = {10.1016/j.scico.2017.11.003},
	Title = {Mining Inline Cache Data to Order Inferred Types in Dynamic Languages},
	Url = {http://scg.unibe.ch/archive/papers/Milo17e.pdf},
	Volume = {161},
	Pages = {105-121},
	Year = {2018}
}

@inproceedings{Minj05a,
	Abstract = {The trait model is complementary to class
				  inheritance and allows collections of methods to be
				  reused by several classes. The classbox model allows
				  a collection of classes to be locally extended with
				  variables and/or methods addition. This paper
				  describes a symbiosis of these two models: classes
				  can be locally extended by using a trait. It is
				  illustrated by an efficient implementation of the
				  collaboration model where a collaboration is
				  represented by a classbox and a role by a trait.},
	Address = {Bern, Switzerland},
	Aeres = {ACL},
	Annote = {nationalconference},
	Author = {Florian Minjat and Alexandre Bergel and Pierre Cointe and St\'ephane Ducasse},
	Booktitle = {Actes de Langages et Mod\`eles \`a Objets (LMO'05)},
	Inria = {hors},
	Keywords = {traits classbox scg-pub skip-doi scg stefPub scg-none jb05 alexPub alexandrePub noWorkshop snf05},
	Pages = {33--46},
	Selectif = {non},
	Title = {Mise en symbiose des traits et des classboxes: Application \`a l'expression des collaborations},
	Url = {http://scg.unibe.ch/archive/papers/Minj05a-TraitClassbox.pdf},
	Volume = {11},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Minj05a-TraitClassbox.pdf}}

@book{More99a,
	Address = {Kaiserslautern, Germany},
	Editor = {Ana Moreira and Serge Demeyer},
	Keywords = {olit ecoop99wr scg-pub skip-abstract skip-doi skip-pdf toBeChecked scglib snf99 scg-none jb99 sergedem-volume scg-none jb99},
	Month = dec,
	Number = 1743,
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Object-Oriented Technology ({ECOOP}'99 Workshop Reader)},
	Year = {1999}}

@incollection{Mose95a,
	Author = {Simon Moser},
	Booktitle = {Software --- Concepts and Tools},
	Issn = {0945-8115},
	Keywords = {skip-pdf skip-abstract skip-doi snf-none olit scg-pub toBeChecked scg-none jb95},
	Month = jul,
	Pages = {63--80},
	Publisher = {Springer Intl.},
	Title = {Metamodels for {Object}-{Oriented} {Systems}},
	Volume = {16},
	Year = {1995}}

@article{Mose96a,
	Abstract = {A field study of over thirty projects using Object
				  Technology has shown that the availability (or
				  absence) of reusable frameworks has substantial
				  productivity impacts. This can make it more
				  difficult to reliably estimate the size and cost of
				  such projects early in the software process. The
				  newly proposed System Meter method tackles this
				  problem by distinguishing functionality to be
				  implemented from functionality supported by reusable
				  components. It therefore yields more uniform and
				  predictable productivity measures. Moreover, it can
				  also be applied already after a preliminary analysis
				  phase, in contrast to the more traditional Function
				  Points approach.},
	Annote = {internationaljournal},
	Author = {Simon Moser and Oscar Nierstrasz},
	Doi = {10.1109/2.536783},
	Journal = {IEEE Computer},
	Keywords = {olit scg-pub snf96 scg-none jb96 onhindex(84)},
	Month = sep,
	Pages = {45--51},
	Title = {The Effect of Object-Oriented Frameworks on Developer Productivity},
	Url = {http://scg.unibe.ch/archive/papers/Mose96aOOMetrics.pdf},
	Year = {1996},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Mose96aOOMetrics.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/2.536783}}

@inproceedings{Moug03a,
	Abstract = {Array programming shines in its ability to express
				  computations at a high-level of abstraction,
				  allowing one to manipulate and query whole sets of
				  data at once. This paper presents the OPA model that
				  enhances object-oriented programming with array
				  programming features. The goal of OPA is to
				  determine a minimum set of modifications that must
				  be made to the traditional object model in order to
				  take advantage of the possibilities of array
				  programming. It is based on a minimal extension of
				  method invocation and the definition of a kernel of
				  methods implementing fundamental array programming
				  operations. The OPA model presents a generalization
				  of traditional message passing in the sense that a
				  message can be send to an entire set of objects. The
				  model is validated in FS, a new scripting language.},
	Acceptnum = {26},
	Accepttotal = {142},
	Annote = {internationalconference topconference},
	Author = {Philippe Mougin and St\'ephane Ducasse},
	Booktitle = {Proceedings of 17th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'03)},
	Doi = {10.1145/949305.949312},
	Keywords = {snf04 scg-pub scg-none jb04 stefPub},
	Misc = {acceptance rate: 26/142 = 18\%},
	Month = oct,
	Pages = {65--77},
	Title = {{OOPAL}: Integrating Array Programming in Object-Oriented Programming},
	Url = {http://scg.unibe.ch/archive/papers/Moug03aOOPALOOPSLA.pdf},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Moug03aOOPALOOPSLA.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/949305.949312}}

@inproceedings{Nebb98m,
	Author = {Robb Nebbe},
	Booktitle = {Object-Oriented Technology (ECOOP '98 Workshop Reader)},
	Editor = {Serge Demeyer and Jan Bosch},
	Keywords = {olit famoos-papunr scg-pub skip-abstract skip-doi toBeChecked snf98 scg-none jb98},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Semantic Structure: a Basis for Software Architecture},
	Url = {http://scg.unibe.ch/archive/famoos/Nebb98m/nebbe_oosa.pdf},
	Volume = {1543},
	Year = {1998},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/famoos/Nebb98m/nebbe_oosa.pdf}}

@inproceedings{Nebb98n,
	Abstract = {This position paper is based on work recovering
				  architectures from object-oriented systems in the
				  context of the FAMOOS Esprit project. Our experience
				  corroborates the existence of aspects that cross-cut
				  the functionality of a software system. However,
				  when examining how the problems arising from such a
				  situation are dealt with in Ada where the language
				  has built-in support for concurrency and C++ where
				  no such support exists suggests the possibility of a
				  more general approach to aspect-oriented programming
				  based on the following hypothesis about software
				  structure that so far has proven to be correct. "A
				  software system can be structured as a set of
				  independent semantic domains consisting of a core
				  problem domain and a set of coordinated supporting
				  domains." I will use the term semantics to refer to
				  an axiomatic or denotational notions of semantics
				  where only the result is considered as semantically
				  relevant as opposed to an operational notion of
				  semantics where how the result was obtained is
				  equally important. I will also use the term
				  coordination to mean the linking of actions or
				  instances from different semantic domains. This is a
				  very general notion of coordination of which the
				  more traditional use of coordination in relation to
				  concurrency is an example.},
	Author = {Robb Nebbe},
	Booktitle = {Object-Oriented Technology (ECOOP '98 Workshop Reader)},
	Editor = {Serge Demeyer and Jan Bosch},
	Keywords = {olit famoos-papunr scg-pub skip-doi toBeChecked snf98 scg-none jb98},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Composition and Coordination: the Two Paradigms Underlying {AOP}?},
	Url = {http://scg.unibe.ch/archive/famoos/Nebb98n/nebbe_aop.pdf},
	Volume = {1543},
	Year = {1998},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/famoos/Nebb98n/nebbe_aop.pdf}}

@techreport{Nebb99z,
	Abstract = {This document defines a language plug-in for FAMIX,
				  the FAMOOS information exchange model. It extends
				  and interprets the FAMIX core model to cover the
				  essential entities from the Ada programming
				  language.},
	Author = {Robb Nebbe},
	Institution = {University of Bern},
	Keywords = {scg-pub skip-doi scg-none jb-none olit famoos-techrep snf99 moose-pub},
	Month = aug,
	Title = {{FAMIX} {Ada} language plug-in 2.2},
	Url = {http://scg.unibe.ch/archive/famoos/FAMIX/Plugins/AdaPlugin2.2.html http://scg.unibe.ch/archive/famoos/FAMIX/Plugins/AdaPlugin2.2.pdf},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/famoos/FAMIX/Plugins/AdaPlugin2.2.html%20http://scg.unibe.ch/archive/famoos/FAMIX/Plugins/AdaPlugin2.2.pdf}}

@incollection{Nier95a,
	Abstract = {The key requirement for open systems is that they be
				  flexible, or recomposable. This suggests that they
				  must first of all be composable. Object-oriented
				  techniques help by allowing applications to be
				  viewed as compositions of collaborating objects, but
				  are limited in supporting other kinds of
				  abstractions that may have finer or coarser
				  granularity than objects. A composition language
				  supports the technical requirements of a
				  component-oriented development approach by shifting
				  emphasis from programming and inheritance of classes
				  to specification and composition of components.
				  Objects are viewed as processes, and components are
				  abstractions over the object space. An application
				  is viewed as an explicit composition of software
				  components. By making software architectures
				  explicit and manipulable, we expect to better
				  support application evolution and flexibility. In
				  this position paper we will elaborate our
				  requirements and outline a strategy for the design
				  and implementation of a composition language for the
				  development of open systems.},
	Author = {Oscar Nierstrasz and Theo Dirk Meijler},
	Booktitle = {Object-Based Models and Langages for Concurrent Systems},
	Doi = {10.1007/3-540-59450-7_9},
	Editor = {Paolo Ciancarini and Oscar Nierstrasz and Akinori Yonezawa},
	Isbn = {978-3-540-59450-5},
	Keywords = {olit scg-pub snf95 racl OBM94-09 scg-none jb94 scg-coord-old onhindex(117)},
	Pages = {147--161},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Requirements for a Composition Language},
	Url = {http://scg.unibe.ch/archive/papers/Nier95aReqtsForaCompLang.pdf},
	Volume = 924,
	Year = {1995},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier95aReqtsForaCompLang.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/3-540-59450-7_9}}

@book{Nier95b,
	Abstract = {Object-Oriented Software Composition represents the
				  results of about ten years of collective research by
				  the authors on various aspects of object-oriented
				  technology. The message of the book is that the
				  technology is not merely about ``object-oriented
				  programming,'' but that it provides the key to
				  component-oriented software development. Within this
				  view, one can see applications not only as
				  collections of collaborating and communicating
				  objects, but as compositions of plug-compatible
				  software components. The work presented in this book
				  was carried out either by members of the Object
				  Systems Group at the University of Geneva in
				  Switzerland, or by partners in collaborative
				  research projects.},
	Editor = {Oscar Nierstrasz and Dennis Tsichritzis},
	Isbn = {0-13-220674-9},
	Keywords = {olit-obc osg skip-doi scg-pub toBeChecked snf95 book scglib scg-none jb94 scg-none jb95 onhindex(211)},
	Publisher = {Prentice-Hall},
	Title = {Object-Oriented Software Composition},
	Url = {http://scg.unibe.ch/archive/oosc/index.html},
	Year = {1995},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/oosc/index.html}}

@incollection{Nier95c,
	Abstract = {Modern software systems are increasingly required to
				  be open and distributed. Such systems are open not
				  only in terms of network connections and
				  interoperability support for heterogeneous hardware
				  and software platforms, but, above all, in terms of
				  evolving and changing requirements. Although
				  object-oriented technology offers some relief, to a
				  large extent the languages, methods and tools fail
				  to address the needs of open systems because they do
				  not escape from traditional models of software
				  development that assume system requirements to be
				  closed and stable. We argue that open systems
				  requirements can only be adequately addressed by
				  adopting a component-oriented as opposed to a purely
				  object-oriented software development approach, by
				  shifting emphasis away from programming and towards
				  generalized software composition.},
	Author = {Oscar Nierstrasz and Laurent Dami},
	Booktitle = {Object-Oriented Software Composition},
	Editor = {Oscar Nierstrasz and Dennis Tsichritzis},
	Keywords = {olit osg OOSC01 scg-pub skip-doi toBeChecked snf95 onhindex(149) scg-none jb94 sclit omnrep},
	Pages = {3--28},
	Publisher = {Prentice-Hall},
	Title = {Component-Oriented Software Technology},
	Url = {http://scg.unibe.ch/archive/oosc/index.html},
	Year = {1995},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/oosc/index.html}}

@incollection{Nier95d,
	Abstract = {Previous work on type-theoretic foundations for
				  object-oriented programming languages has mostly
				  focused on applying or extending functional type
				  theory to functional "objects." This approach, while
				  benefiting from a vast body of existing literature,
				  has the disadvantage of dealing with state change
				  either in a roundabout way or not at all, and
				  completely sidestepping issues of concurrency. In
				  particular, dynamic issues of non-uniform service
				  availability and conformance to protocols are not
				  addressed by functional types. We propose a new type
				  framework that characterizes objects as regular
				  (finite state) processes that provide guarantees of
				  service along public channels. We also propose a new
				  notion of subtyping for active objects, based on
				  Brinksma's notion of extension, that extends Wegner
				  and Zdonik's "principle of substitutability" to
				  non-uniform service availability. Finally, we
				  formalize what it means to "satisfy a client's
				  expectations," and we show how regular types can be
				  used to tell when sequential or concurrent clients
				  are satisfied.},
	Author = {Oscar Nierstrasz},
	Booktitle = {Object-Oriented Software Composition},
	Editor = {Oscar Nierstrasz and Dennis Tsichritzis},
	Keywords = {olit-obc osg OOSC04 scg-pub skip-doi toBeChecked snf95 rtao scg-none jb94 omnrep},
	Pages = {99--121},
	Publisher = {Prentice-Hall},
	Title = {Regular Types for Active Objects},
	Url = {http://scg.unibe.ch/archive/oosc/index.html},
	Year = {1995},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/oosc/index.html}}

@article{Nier95e,
	Abstract = {Software composition refers to the
				  construction of software applications from
				  components that implement abstractions pertaining to
				  a particular problem domain. Raising the level of
				  abstraction is a time-honored way of dealing with
				  complexity, but the real benefit of composable
				  software systems lies in their increased
				  flexibility: a system built from components should
				  be easy to recompose to address new requirements. A
				  certain amount of success has been achieved in some
				  well-understood application domains, as witnessed by
				  the popularity of user-interface toolkits, fourth
				  generation languages and application generators. But
				  how can we generalize this?},
	Annote = {internationaljournal},
	Author = {Oscar Nierstrasz and Theo Dirk Meijler},
	Doi = {10.1145/210376.210389},
	Journal = {ACM Computing Surveys},
	Keywords = {olit scg-pub toBeChecked snf95 scg-none jb95 scg-coord-old onhindex(132)},
	Month = jun,
	Number = {2},
	Pages = {262--264},
	Title = {Research Directions in Software Composition},
	Url = {http://scg.unibe.ch/archive/papers/Nier95eResearchDirections.pdf},
	Volume = {27},
	Year = {1995},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier95eResearchDirections.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/210376.210389}}

@inproceedings{Nier95f,
	Abstract = {Traditional software development approaches do not
				  cope well with the evolving requirements of open
				  systems. We argue that such systems are best viewed
				  as flexible compositions of "software components"
				  designed to work together as part of a component
				  framework that formalizes a class of applications
				  with a common software architecture. To enable such
				  a view of software systems, we need appropriate
				  support from programming language technology,
				  software tools, and methods. We will briefly review
				  the current state of object-oriented technology,
				  insofar as it supports componentoriented
				  development, and propose a research agenda of topics
				  for further investigation.},
	Address = {Nancy},
	Annote = {internationalconference},
	Author = {Oscar Nierstrasz},
	Booktitle = {Proceedings, Langages et Mod\`eles \`a Objets},
	Keywords = {olit scg-pub skip-doi toBeChecked snf95 scg-none jb95 scg-coord-old},
	Month = oct,
	Pages = {193--204},
	Title = {Research Topics in Software Composition},
	Url = {http://scg.unibe.ch/archive/papers/Nier95fResearchTopics.pdf},
	Year = {1995},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier95fResearchTopics.pdf}}

@inproceedings{Nier96a,
	Abstract = {Flexibility is achieved in open systems by adopting
				  software architectures that allow software
				  components to be easily plugged in, adapted and
				  exchanged. But open systems are generally con
				  current, distributed and heterogeneous in addition
				  to being adaptable. Ad hoc approaches to specifying
				  component frameworks can lead to unexpected semantic
				  conflicts. We propose, instead, to develop a
				  rigorous foundation for composable software systems
				  by a series of experiments in modelling concurrent
				  and object-based software abstractions as
				  composable, communicating processes. Eventually we
				  hope to identify and realize the most useful
				  compositional idioms as a composition language for
				  open systems specification.},
	Annote = {internationalworkshop},
	Author = {Oscar Nierstrasz and Jean-Guy Schneider and Markus Lumpe},
	Booktitle = {Proceedings 1st IFIP Workshop on Formal Methods for Open Object-based Distributed Systems FMOODS '96},
	Keywords = {olit scg-pub skip-doi snf96 scg-none jb96 scg-coord-old fmoods96},
	Pages = {271--282},
	Publisher = {Chapmann \& Hall},
	Title = {Formalizing Composable Software Systems --- {A} Research Agenda},
	Url = {http://scg.unibe.ch/archive/papers/Nier96aCompositionResearch.pdf},
	Year = {1996},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier96aCompositionResearch.pdf}}

@article{Nier97a,
	Abstract = {In der letzten Zeit wird immer h\"{a}ufiger von
				  komponentenorientierter Softwareentwicklung
				  gesprochen, wobei meistens nicht klar ist, was
				  darunter eigentlich zu verstehen ist. Was macht ein
				  St\"{u}ck Software zur Komponente? Wir sagen,
				  da{\ss} Softwarekomponenten in einer speziellen Art
				  und Weise konstruiert werden m\"{u}ssen, um mit
				  anderen Komponenten zu einer Applikation
				  zusammengef\"{u}gt werden zu k\"{o}nnen. Mit anderen
				  Worten, eine Softwarekomponente ist Teil eines
				  Komponentenframeworks, da{\ss} (i) eine Bibliothek
				  von Black-Box-Komponenten zu Verf\"{u}gung stellt,
				  (ii) eine wiederverwendbare Softwarearchitektur
				  definiert, in der die Komponenten geeignet
				  integriert sind und (iii) eine bestimmte Art von
				  Glue, die es uns erlaubt, Komponenten miteinander zu
				  verbinden. In diesem Artikel versuchen wir, den
				  Ist-Zustand der Komponententechnologie wiederzugeben
				  und behaupten, da{\ss} nur eine bessere
				  Unterst\"{u}tzung im Bereich Frameworks und Gluing
				  die Komponententechnologie vorw\"{a}rts bringen
				  kann.},
	Annote = {invited},
	Author = {Oscar Nierstrasz and Markus Lumpe},
	Journal = {HMD --- Theorie und Praxis der Wirtschaftsinformatik},
	Keywords = {scg-pub skip-doi olit snf97 scg-none jb97},
	Month = sep,
	Pages = {8--23},
	Title = {Komponenten, Komponentenframeworks und Gluing},
	Url = {http://scg.unibe.ch/archive/papers/Nier97aKomponentenUndGluing.pdf},
	Year = {1997},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier97aKomponentenUndGluing.pdf}}

@techreport{Nier98a,
	Abstract = {The peer review process for technical contributions
				  to conferences in computing sciences is very
				  thorough, and can be as stringent as the review
				  process for journal publications in other domains.
				  The programme committee for such a conference will
				  typically convene at a meeting, where submitted
				  papers are discussed, and accepted or rejected for
				  presentation at the conference. Experience shows
				  that discussions are more focussed, and the entire
				  process runs more smoothly if most of the time is
				  devoted to those papers that are actually
				  "championed" by some committee member. In order to
				  make this work effectively, however, the notion of
				  "championing" must be introduced early in the review
				  process. This paper presents a set of process
				  patterns that help to achieve this goal.},
	Author = {Oscar Nierstrasz},
	Institution = {Washington University},
	Keywords = {snf-none olit scg-pub skip-doi scg-none jb98},
	Number = {\#WUCS-98-25},
	Title = {Identify the Champion},
	Type = {Proceedings of PLoP 98, TR},
	Url = {http://scg.unibe.ch/download/champion/champion.pdf},
	url2 = {http://scg.unibe.ch/download/champion/index.html},
	Year = {1998},
	Bdsk-Url-1 = {http://scg.unibe.ch/download/champion/champion.pdf%20http://scg.unibe.ch/download/champion/index.html}}

@inproceedings{Nier98b,
	Abstract = {Tool support is recognised as a key issue in the
				  reengineering of large scale object-oriented
				  systems. However, due to the heterogeneity in
				  today's object-oriented programming languages, it is
				  hard to reuse reengineering tools across legacy
				  systems. This paper proposes a language independent
				  exchange model, so that tools may perform their
				  tasks independent of the underlying programming
				  language. We have adopted CDIF as the basis for the
				  exchange of information, using this model, between
				  the reengineering tool prototypes in the FAMOOS
				  project. The main reasons for adopting CDIF are,
				  that firstly it is an industry standard, and
				  secondly it has a standard plain text encoding which
				  tackles the requirements of convenient querying and
				  human readability. Next to that the CDIF framework
				  supports the extensibility we need to define our
				  model and language plug-ins.},
	Annote = {internationalworkshop},
	Author = {Oscar Nierstrasz and Sander Tichelaar and Serge Demeyer},
	Booktitle = {OOPSLA '98 Workshop on Model Engineering, Methods and Tools Integration with CDIF},
	Keywords = {olit famoos-papunr scg-pub skip-doi sergedem-papunr tich-papunr snf98 scg-none jb98 moose-pub},
	Month = oct,
	Title = {{CDIF} as the Interchange Format between Reengineering Tools},
	Url = {http://scg.unibe.ch/archive/papers/Nier98bCDIFasReengFormat.pdf},
	Year = {1998},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier98bCDIFasReengFormat.pdf}}

@inproceedings{Nier00a,
	Abstract = {The peer review process for technical contributions
				  to conferences in computing sciences is very
				  thorough, and can be as stringent as the review
				  process for journal publications in other domains.
				  The programme committee for such a conference will
				  typically convene at a meeting, where submitted
				  papers are discussed, and accepted or rejected for
				  presentation at the conference. Experience shows
				  that discussions are more focussed, and the entire
				  process runs more smoothly if most of the time is
				  devoted to those papers that are actually
				  "championed" by some committee member. In order to
				  make this work effectively, however, the notion of
				  "championing" must be introduced early in the review
				  process. This paper presents a set of process
				  patterns that help to achieve this goal.},
	Annote = {internationalconference},
	Author = {Oscar Nierstrasz},
	Booktitle = {Pattern Languages of Program Design},
	Editor = {N. Harrison and B. Foote and H. Rohnert},
	Keywords = {olit scg-pub skip-doi scg-none jb98 snf99 jb00},
	Pages = {539--556},
	Publisher = {Addison Wesley},
	Title = {Identify the Champion},
	url = {https://www.oscar.nierstrasz.org/champion/},
	url2 = {http://scg.unibe.ch/archive/papers/Nier00aIdentifyTheChampion.pdf},
	Volume = {4},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/download/champion/champion.pdf%20http://scg.unibe.ch/archive/papers/Nier00aIdentifyTheChampion.pdf%20http://scg.unibe.ch/download/champion/index.html}}

@inproceedings{Nier00b,
	Abstract = {Software is not just difficult to develop, but it is
				  even more difficult to maintain in the face of
				  changing requirements. The complexity of software
				  evolution can, however, be significantly reduced if
				  we manage to separate the stable artifacts (the
				  components) from their configuration (the scripts).
				  We have proposed a simple, unifying framework of
				  forms, agents, and channels for modelling components
				  and scripts, and we have developed an experimental
				  composition language, called Piccola, based on this
				  framework, that supports the specification of
				  applications as flexible compositions of stable
				  components. In this paper we show how Piccola can be
				  used to reduce the complexity of software evolution
				  through the specification and use of an appropriate
				  compositional style, and we illustrate the approach
				  through a non-trivial example of mixin layer
				  composition.},
	Address = {Kanazawa, Japan},
	Annote = {internationalconference},
	Author = {Oscar Nierstrasz and Franz Achermann},
	Booktitle = {Proceedings International Symposium on Principles of Software Evolution (ISPSE 2000)},
	Doi = {10.1109/ISPSE.2000.913216},
	Keywords = {snf01 scg-pub piccola mixin-layers scg-none jb00 scg-coord-00},
	Misc = {Nov 1-2},
	Month = nov,
	Pages = {11--19},
	Publisher = {IEEE},
	Title = {{Supporting Compositional Styles for Software Evolution}},
	Url = {http://scg.unibe.ch/archive/papers/Nier00bSCS.pdf},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier00bSCS.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ISPSE.2000.913216}}

@inproceedings{Nier00c,
	Abstract = {Moore's Law is pushing us inevitably towards a world
				  of pervasive, wireless, spontaneously networked
				  computing devices. Whatever these devices do, they
				  will have to talk to and negotiate with one another,
				  and so software agents will have to represent them.
				  Whereas conventional services on intranets will
				  continue to be distributed using established
				  middleware standards, internet services are being
				  built on top of http, wap or other protocols, and
				  exchange information in HTML, XML and just about
				  anything that can be wrapped as a MIME type or
				  streamed. This situation leads us to three software
				  problems: (i) How can we simplify the task of
				  programming these agents? (i.e., {Java} is not
				  enough), (ii) How can agents interact and
				  interoperate in an open, evolving network
				  environment? (i.e., XML is not enough), (iii) How
				  can we reason about the services that agents provide
				  and use? (i.e., IDL is not enough). We discuss these
				  questions in the context of our work on Piccola, a
				  small composition language, and outline ongoing and
				  further research.},
	Annote = {internationalworkshop},
	Author = {Oscar Nierstrasz and Jean-Guy Schneider and Franz Achermann},
	Booktitle = {ECOOP 2000 Workshop on Component-Oriented Programming},
	Keywords = {oobib(gen) piccola scg-pub skip-doi snf00 scg-none jb00 scg-coord-00},
	Title = {Agents Everywhere, All the Time},
	Url = {http://scg.unibe.ch/archive/papers/Nier00cAgentsEverywhere.pdf},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier00cAgentsEverywhere.pdf}}

@inproceedings{Nier00d,
	Abstract = {Separation of concerns is a principle we apply to
				  reduce complexity. This principle is especially
				  important when it is used to separate stable from
				  flexible parts of software systems to reduce the
				  complexity of software evolution. We encapsulate the
				  stable parts as components and the flexible parts as
				  scripts. But there is a large range of requirements
				  and consequent techniques available to achieve this
				  separation. We propose a simple, unifying framework
				  of forms, agents, and channels for modelling
				  components and scripts. We have also developed an
				  experimental composition language, called Piccola,
				  based on this framework, that supports the
				  specification of applications as flexible
				  compositions of stable components.},
	Annote = {internationalworkshop},
	Author = {Oscar Nierstrasz and Franz Achermann},
	Booktitle = {ECOOP 2000 Workshop on Aspects \& Dimensions of Concerns},
	Keywords = {oobib(gen) piccola scg-pub skip-doi snf00 scg-none jb00 scg-coord-00},
	Title = {Separation of Concerns through Unification of Concepts},
	Url = {http://scg.unibe.ch/archive/papers/Nier00dSeparationOfConcerns.pdf},
	url2 = {http://trese.cs.utwente.nl/Workshops/adc2000/},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier00dSeparationOfConcerns.pdf%20http://trese.cs.utwente.nl/Workshops/adc2000/}}

@inproceedings{Nier02a,
	Abstract = {Component-based software development is becoming
				  mainstream for conventional applications. However,
				  components can be difficult to deploy in embedded
				  systems because of non-functional requirements.
				  Pecos is a collaborative project between industrial
				  and research partners that seeks to enable
				  component-based technology for a class of embedded
				  systems known as field devices. In this paper we
				  introduce a component model for field devices that
				  captures a range of non-functional properties and
				  constraints. We report on the current status of
				  Pecos, including the Pecos composition language,
				  language mappings to {Java} and C++, and industrial
				  case studies.},
	Address = {Berlin, Germany},
	Annote = {internationalconference},
	Author = {Oscar Nierstrasz and Gabriela Ar{\'e}valo and St{\'e}phane Ducasse and Roel Wuyts and Andrew Black and Peter M{\"u}ller and Christian Zeidler and Thomas Genssler and Reinier van den Born},
	Booktitle = {Proceedings First International IFIP/ACM Working Conference on Component Deployment},
	Keywords = {scg-pub skip-doi scg-none jb02 pecos stefPub arevalo onhindex(82)},
	Month = jun,
	Pages = {200--209},
	Publisher = {ACM},
	Title = {A Component Model for Field Devices},
	Url = {http://scg.unibe.ch/archive/papers/Nier02aPecosModel.pdf},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier02aPecosModel.pdf}}

@inproceedings{Nier02b,
	Abstract = {Despite the existence of a seemingly continuous
				  stream of new ``silver bullet'' technologies and
				  methods, software productivity remains universally
				  unimpressive. We argue that, as long as industry
				  remains focused on short-term goals, and maintains a
				  technology-centric view of software development, no
				  progress will be made. A clear symptom of this
				  problem is the fact that the metaphors we apply to
				  software development are largely obsolete. Instead
				  of thinking about software as we do about bridges,
				  buildings or hardware components, we should
				  encourage a view of software as a living and
				  evolving entity that is developed and maintained by
				  people. We begin with some assertions that are
				  intended as food for thought. We continue by
				  reviewing what we consider to be some of the key
				  difficulties with software development today. We
				  conclude with a few recommendations for research
				  into software practices that take evolution into
				  account.},
	Address = {Venice, Italy},
	Annote = {invited},
	Author = {Oscar Nierstrasz},
	Booktitle = {Proceedings Radical Innovations of Software and Systems Engineering in the Future},
	Keywords = {scg-pub skip-doi scg-none jb02 snf02 rissef},
	Month = oct,
	Note = {preprint},
	Title = {Software Evolution as the Key to Productivity},
	Url = {http://scg.unibe.ch/archive/papers/Nier02bEvolution.pdf},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier02bEvolution.pdf}}

@techreport{Nier03a,
	Abstract = {Piccola is small, experimental \emph{composition
				  language} --- a language for building applications
				  from software components implemented in another,
				  host programming language. This document describes
				  JPiccola, the implementation of Piccola for the
				  {Java} host language.},
	Address = {Universit\"at Bern, Switzerland},
	Author = {Oscar Nierstrasz and Franz Achermann and Stefan Kneub\"uhl},
	Cvs = {jpiccola/PiccolaGuide},
	Institution = {Institut f\"ur Informatik},
	Keywords = {snf03 scg-pub skip-doi scg-none jb03 piccola},
	Month = jun,
	Number = {IAM-03-003},
	Title = {A Guide to {JP}iccola},
	Type = {Technical Report},
	url = {http://scg.unibe.ch/archive/papers/Nier03aJPiccolaGuide.pdf},
	Url2 = {http://scg.unibe.ch/research/piccola},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/research/piccola%20http://scg.unibe.ch/archive/papers/Nier03aJPiccolaGuide.pdf}}

@techreport{Nier03b,
	Abstract = {Real software systems are open and evolving. It is a
				  constant challenge in such environments to ensure
				  that software components are safely composed in the
				  face of changing dependencies and incomplete
				  knowledge. To address this problem, we propose a new
				  kind of type system which allows us to infer not
				  only the type provided by a software component in an
				  open system, but also the type it requires of its
				  environment, subject to certain constraints. The
				  contractual type we infer for components can then be
				  statically checked when components are composed. To
				  illustrate our approach, we introduce the form
				  calculus, a calculus of explicit environments, and
				  we present a type system that infers types for form
				  expressions.},
	Address = {University of Bern, Switzerland},
	Author = {Oscar Nierstrasz},
	Institution = {Institute of Computer Science},
	Keywords = {snf03 scg-pub skip-doi piccola scg-none jb03},
	Number = {IAM-03-004},
	Title = {Contractual Types},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Nier03bcontractualTypes.pdf},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier03bcontractualTypes.pdf}}

@inproceedings{Nier03c,
	Abstract = {Many competing definitions of software components
				  have been proposed over the years, but still today
				  there is only partial agreement over such basic
				  issues as granularity (are components bigger or
				  smaller than objects, packages, or application?),
				  instantiation (do components exist at run-time or
				  only at compile-time?), and state (should we
				  distinguish between components and ``instances" of
				  components?). We adopt a minimalist view in which
				  components can be distinguished by \emph{composable
				  interfaces}. We have identified a number of key
				  features and mechanisms for expressing composable
				  software, and propose a calculus for modeling
				  components, based on the asynchronous pi calculus
				  extended with explicit namespaces, or ``forms". This
				  calculus serves as a semantic foundation and an
				  executable abstract machine for Piccola, an
				  experimental composition language. The calculus also
				  enables reasoning about compositional styles and
				  evaluation strategies for Piccola. We present the
				  design rationale for the Piccola calculus, and
				  briefly outline some of the results obtained.},
	Annote = {invited},
	Author = {Oscar Nierstrasz and Franz Achermann},
	Booktitle = {FMCO 2002 Proceedings},
	Cvs = {PiccolaFMCO},
	Doi = {10.1007/b14033},
	Editor = {F. S. De Boer, M. M. Bonsangue, S. Graf and W-P. de Roever},
	Isbn = {978-3-540-20303-2},
	Keywords = {snf04 scg-pub piccola scg-none jb04},
	Pages = {339--360},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {A Calculus for Modeling Software Components},
	Url = {http://scg.unibe.ch/archive/papers/Nier03cPiccolaCalculus.pdf},
	Volume = {2852},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier03cPiccolaCalculus.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/b14033}}

@inproceedings{Nier04a,
	Abstract = {Despite the existence of a seemingly continuous
				  stream of new technologies and methods, software
				  productivity remains universally unimpressive. We
				  argue that, as long as industry remains focused on
				  short-term goals, and maintains a technology-centric
				  view of software development, no progress will be
				  made. A clear symptom of this problem is the fact
				  that the metaphors we apply to software development
				  are largely obsolete. Instead of thinking about
				  software as we do about bridges, buildings or
				  hardware components, we should encourage a view of
				  software as a living and evolving entity that is
				  developed and maintained by people. We begin
				  with some assertions that are intended as food for
				  thought. We continue by reviewing what we consider
				  to be some of the key difficulties with software
				  development today. We conclude with a few
				  recommendations for research into software practices
				  that take evolution into account.},
	Annote = {invited},
	Author = {Oscar Nierstrasz},
	Booktitle = {Radical Innovations of Software and Systems Engineering in the Future},
	Cvs = {RadicalInnovation},
	Doi = {10.1007/b96009},
	Editor = {M. Wirsing, A. Knapp and S. Balsamo},
	Isbn = {978-3-540-21179-2},
	Keywords = {scg-pub scg-none jb04 snf04 rissef},
	Pages = {274--282},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Software Evolution as the Key to Productivity},
	Url = {http://scg.unibe.ch/archive/papers/Nier04aEvolution.pdf},
	Volume = {2941},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier04aEvolution.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/b96009}}

@inproceedings{Nier04b,
	Abstract = {We know that successful software systems are doomed
				  to change. But our programming languages and tools
				  continue to focus on developing static, unchanging
				  models of software. We propose that change should be
				  at the center of our software process. To that end,
				  we are exploring programming language mechanisms to
				  support both fine-grained composition and
				  coarse-grained extensibility, and we are developing
				  tools and techniques to analyse and facilitate
				  change in complex systems. In this talk we review
				  problems and limitations with object-oriented and
				  component-based development approaches, and we
				  explore both technological and methodological ways
				  in which change can be better accommodated.},
	Annote = {invited},
	Author = {Oscar Nierstrasz},
	Booktitle = {International Symposium on Component-Based Software Engineering (CBSE) 2004},
	Cvs = {SCG-CBSE7Abstract},
	Doi = {10.1007/b97813},
	Editor = {I. Crnkovic and J.A. Stafford and H.W. Schmidt and K. Wallnau},
	Isbn = {978-3-540-21998-9},
	Keywords = {scg-pub scg-none jb04 snf04 cbse7},
	Note = {Extended abstract of an invited talk},
	Pages = {1--4},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Putting Change at the Center of the Software Process},
	Url = {http://scg.unibe.ch/archive/papers/Nier04bChange.pdf},
	Volume = {3054},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier04bChange.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/b97813}}

@article{Nier04c,
	Abstract = {Aging software systems are difficult and expensive
				  to maintain. Moose is a language-independent
				  environment that supports a wide range of tools to
				  visualise, analyse and manipulate complex software
				  systems.},
	Annote = {notrefereed},
	Author = {Oscar Nierstrasz and St\'ephane Ducasse},
	Cvs = {ERCIM_ASE},
	Journal = {European Research Consortium for Informatics and Mathematics (ERCIM) News},
	Keywords = {scg-pub skip-doi scg-none jb04 stefPub recast04 moose-pub},
	Month = jul,
	Pages = {24--25},
	Title = {Moose -- a Language-Independent Reengineering Environment},
	Url = {http://www.ercim.org/publication/Ercim_News/enw58/nierstrasz.html},
	Volume = {58},
	Year = {2004},
	Bdsk-Url-1 = {http://www.ercim.org/publication/Ercim_News/enw58/nierstrasz.html}}

@inproceedings{Nier04d,
	Abstract = {In this paper we briefly review various kinds of
				  software changes and the issues that arise from
				  them. As a consequence, we propose research into
				  programming languages with explicit support for
				  representing first-class changes, and for
				  manipulating and merging multiple viewpoints of
				  evolving software systems.},
	Annote = {internationalworkshop},
	Author = {Oscar Nierstrasz and Marcus Denker},
	Booktitle = {OOPSLA Workshop on Revival of Dynamic Languages},
	Cvs = {RDLchange},
	Keywords = {snf05 scg-pub skip-doi scg-none jb05},
	Month = oct,
	Title = {Supporting Software Change in the Programming Language},
	Url = {http://scg.unibe.ch/archive/papers/Nier04dRDLchange.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier04dRDLchange.pdf}}

@incollection{Nier05a,
	Abstract = {As applications evolve, it becomes harder and harder
				  to separate independent concerns. Small changes to a
				  software system increasingly affect different parts
				  of the source code. AOP and related approaches offer
				  various ways to separate concerns into concrete
				  software artifacts, but what is the \emph{essence}
				  of this process? We claim that first-class
				  namespaces ---which we refer to as \emph{forms}---
				  offer a suitable foundation for separating concerns,
				  by offering simple, yet expressive mechanisms for
				  defining composable abstractions. We demonstrate how
				  forms help a programmer to separate concerns by
				  means of practical examples in Piccola, an
				  experimental composition language.},
	Author = {Oscar Nierstrasz and Franz Achermann},
	Booktitle = {Aspect-Oriented Software Development},
	Cvs = {PiccolaAOSDbook},
	Editor = {Robert E. Filman and Tzilla Elrad and Siobh\'an Clarke and Mehmet Aksit},
	Isbn = {0-321-21976-7},
	Keywords = {snf04 scg-pub skip-doi scg-none jb05},
	Pages = {243--259},
	Publisher = {Addison-Wesley},
	Title = {Separating Concerns with First-Class Namespaces},
	Url = {http://scg.unibe.ch/archive/papers/Nier05aNamespaces.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier05aNamespaces.pdf}}

@inproceedings{Nier05b,
	Abstract = {The programming languages of today are stuck in a
				  deep rut that has developed over the past 50 years.
				  Although we are faced with new challenges posed by
				  enormous advances in hardware and internet
				  technology, we continue to struggle with
				  old-fashioned languages based on rigid, static,
				  closed-world file-based views of programming. We
				  argue the need for a new class of dynamic languages
				  that support a view of programming as constant
				  evolution of living and open software models. Such
				  languages would require features such as dynamic
				  first-class namespaces, explicit meta-models,
				  optional, pluggable type systems, and incremental
				  compilation of running software systems.},
	Aeres = {INV},
	Annote = {invited},
	Author = {Oscar Nierstrasz and Alexandre Bergel and Marcus Denker and St\'ephane Ducasse and Markus Gaelli and Roel Wuyts},
	Booktitle = {Proceedings of Software Composition 2005},
	Cvs = {SC05Revival},
	Doi = {10.1007/11550679_1},
	Editor = {Thomas Gschwind and Uwe A{\ss}mann},
	Inria = {hors},
	Isbn = {3-540-28748-5},
	Keywords = {snf05 snf-actsc scg-pub scg-none jb06 gaelli},
	Misc = {gaelli},
	Note = {Invited paper},
	Pages = {1--13},
	Publisher = {LNCS 3628},
	Title = {On the Revival of Dynamic Languages},
	Url = {http://scg.unibe.ch/archive/papers/Nier05bRevival.pdf},
	Volume = {3628},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier05bRevival.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/11550679_1}}

@inproceedings{Nier05c,
	Abstract = {Moose is a language-independent environment for
				  reverse- and re-engineering complex software
				  systems. Moose provides a set of services including
				  a common meta-model, metrics evaluation and
				  visualization, a model repository, and generic GUI
				  support for querying, browsing and grouping. The
				  development effort invested in Moose has paid off in
				  precisely those research activities that benefit
				  from applying a combination of complementary
				  techniques. We describe how Moose has evolved over
				  the years, we draw a number of lessons learned from
				  our experience, and we outline the present and
				  future of Moose.},
	Address = {New York, NY, USA},
	Aeres = {INV},
	Aeresstatus = {aeres08},
	Annote = {invited},
	Author = {Oscar Nierstrasz and St\'ephane Ducasse and Tudor G\^irba},
	Booktitle = {Proceedings of the European Software Engineering Conference (ESEC/FSE'05)},
	Cvs = {MOOSE-ESEC05},
	Doi = {10.1145/1095430.1081707},
	Inria = {hors},
	Isbn = {1-59593-014-0},
	Keywords = {hasler07 girba stefPub recast06 scg-pub scg-none jb06 onhindex(81) mooseCincom moose-pub snf-actsc snf-bmcc norex06},
	Month = sep,
	Note = {Invited paper},
	Pages = {1--10},
	Publisher = {ACM Press},
	Title = {The Story of {Moose}: an Agile Reengineering Environment},
	Url = {http://scg.unibe.ch/archive/papers/Nier05cStoryOfMoose.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier05cStoryOfMoose.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1095430.1081707}}

@inproceedings{Nier05d,
	Abstract = {Successful software systems must be prepared to
				  evolve or they will die. Although object-oriented
				  software systems are built to last, over time they
				  degrade as much as any legacy software system. As a
				  consequence, one must invest in reengineering
				  efforts to keep further development costs down. Even
				  though software systems and their business contexts
				  may differ in countless ways, the techniques one
				  uses to understand, analyze and transform these
				  systems tend to be very similar. As a consequence,
				  one may identify various reengineering patterns that
				  capture best practice in reverse- and re-engineering
				  object-oriented legacy systems. We present a brief
				  outline of a large collection of these patterns that
				  have been mined over several years of experience
				  with object-oriented legacy systems, and we indicate
				  how some of these patterns can be supported by
				  appropriate tools.},
	Aeres = {INV},
	Aeresstatus = {aeres08},
	Annote = {invited},
	Author = {Oscar Nierstrasz and St\'ephane Ducasse and Serge Demeyer},
	Booktitle = {Proceedings of Generative Programming and Component Engineering (GPCE 2005)},
	Cvs = {GPCE05ReengPatterns},
	Doi = {10.1007/11561347_1},
	Editor = {Robert Gl\"uck, Michael Lowry},
	Inria = {hors},
	Isbn = {3-540-29138-5},
	Keywords = {stefPub recast06 scg-pub scg-none jb06},
	Note = {Invited paper},
	Pages = {1--9},
	Publisher = {LNCS 3676},
	Title = {Object-oriented Reengineering Patterns --- an Overview},
	Url = {http://scg.unibe.ch/archive/papers/Nier05dReengineeringPatterns.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier05dReengineeringPatterns.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/11561347_1}}

@techreport{Nier05e,
	Abstract = {Traits are fine-grained components that can be used
				  to compose classes, while avoiding many of the
				  problems of multiple inheritance and mixin-based
				  approaches. Since most implementations of traits
				  have focused on dynamically-typed languages, the
				  question naturally arises, how can one best
				  introduce traits to statically-typed languages, like
				  {Java} and C#? In this paper we argue that the
				  flattening property of traits should be used as a
				  guiding principle for any attempt to add traits to
				  statically-typed languages. This property
				  essentially states that, semantically, traits can be
				  compiled away. We demonstrate how this principle
				  applies to FTJ, a conservative extension to
				  Featherweight {Java}.},
	Address = {Universit\"at Bern, Switzerland},
	Author = {Oscar Nierstrasz and St\'ephane Ducasse and Nathanael Sch\"arli},
	Cvs = {TraitFlatteningTR},
	Institution = {Institut f\"ur Informatik},
	Keywords = {scg-pub skip-doi scg-rotor traits scg-none jb06 snf05 jot stefPub},
	Month = apr,
	Number = {IAM-05-005},
	Title = {Flattening {Traits}},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Nier05eFlatteningTraitsTR.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier05eFlatteningTraitsTR.pdf}}

@article{Nier05f,
	Abstract = {Erfolgreiche Softwaresysteme m\"ussen so konzipiert
				  sein, dass sie sich weiterentwickeln k\"onnen ---
				  ansonsten gehen sie ein. Obwohl objektorientierte
				  Softwaresysteme auf eine lange Lebensda\"ur
				  ausgerichtet sind, veralten sie \"uber die Jahre
				  genauso wie jedes andere Legacy-Softwaresystem. Um
				  die weiteren Entwicklungskosten niedrig zu halten,
				  m\"ussen daher Investitionen im Bereich
				  Re-Engineering get\"atigt werden. Softwaresysteme
				  und der Gesch\"aftskontext, in dem sie eingesetzt
				  werden, unterscheiden sich in vielen Punkten ---
				  dennoch \"ahneln sich Techniken, sie zu verstehen,
				  zu analysieren und zu transformieren. Folglich
				  lassen sich verschiedene Re-Engineering-Muster
				  identifizieren, die bew\"ahrte Vorgehensweisen beim
				  Reverse- und Re-Engineering objektorientierter
				  Legacy-Systeme beinhalten. Dieser Artikel stellt
				  einen kleinen Ausschnitt aus einer gr\"on Sammlung
				  dieser Muster vor, die auf der mehrj\"ahrigen
				  Erfahrung mit objektorientierten Legacy-Systemen
				  basieren. Dar\"uber hinaus werden Hinweise gegeben,
				  wie einige dieser Muster durch geeignete Werkzeuge
				  unterst\"utzt werden k\"onnen.},
	Aeres = {INV},
	Aeresstatus = {aeres08},
	Annote = {invited},
	Author = {Oscar Nierstrasz and St\'ephane Ducasse and Serge Demeyer},
	Inria = {hors},
	Journal = {ObjektSpektrum},
	Keywords = {stefPub recast06 scg-pub skip-doi scg-none jb06},
	Note = {German translation of ``Object-oriented Reengineering Patterns --- an Overview'' (GPCE 05)},
	Number = {6},
	Pages = {46--51},
	Title = {Objektorientierte Re-Engineering-Muster: ein \"{U}berblick},
	Url = {http://www.sigs-datacom.de/sd/publications/pub_article_show.htm?&AID=1713&TABLE=sd_article http://www.sigs.de/publications/os/2005/06/demeyer_nierstrasz_OS_06_05.pdf http://scg.unibe.ch/archive/papers/Nier05fOORM.pdf},
	Volume = {2005},
	Year = {2005},
	Bdsk-Url-1 = {http://www.sigs-datacom.de/sd/publications/pub_article_show.htm?&AID=1713&TABLE=sd_article%20http://www.sigs.de/publications/os/2005/06/demeyer_nierstrasz_OS_06_05.pdf%20http://scg.unibe.ch/archive/papers/Nier05fOORM.pdf}}

@techreport{Nier05g,
	Abstract = {Traits offer a fine-grained mechanism for composing
				  classes in object-oriented languages from reusable
				  components, while avoiding the fragility problems
				  introduced by multiple inheritance and mixins.
				  Although traits were developed in the context of
				  dynamically typed languages, they would also offer
				  clear benefits for statically typed languages like
				  Java and C\#. This report summarizes the issues
				  raised when integrating traits into such languages.
				  We examine traits in the context of the statically
				  typed languages FeatherweightJava, C\# and C++.},
	Address = {Universit\"at Bern, Switzerland},
	Author = {Oscar Nierstrasz and St\'ephane Ducasse and Stefan Reichhart and Nathanael Sch\"arli},
	Cvs = {TraitsCSharp},
	Institution = {Institut f\"ur Informatik},
	Keywords = {scg-pub skip-doi scg-rotor traits scg-none jb06 snf05 stefPub},
	Month = dec,
	Number = {IAM-05-006},
	Title = {Adding {Traits} to (Statically Typed) Languages},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Nier05gTraitsCSharp.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier05gTraitsCSharp.pdf}}

@article{Nier06a,
	Abstract = {Traits are fine-grained components that can be used
				  to compose classes, while avoiding many of the
				  problems of multiple inheritance and mixin-based
				  approaches. Since most implementations of traits
				  have focused on dynamically-typed languages, the
				  question naturally arises, how can one best
				  introduce traits to statically-typed languages, like
				  {Java} and C#? In this paper we argue that the
				  flattening property of traits should be used as a
				  guiding principle for any attempt to add traits to
				  statically-typed languages. This property
				  essentially states that, semantically, traits can be
				  compiled away. We demonstrate how this principle
				  applies to FTJ, a conservative extension to
				  Featherweight {Java}.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Oscar Nierstrasz and St\'ephane Ducasse and Nathanael Sch\"arli},
	Cached = {http://scg.unibe.ch/archive/papers/Nier06aFlatteningTraits.pdf},
	Cvs = {TraitFlatteningJOT},
	Doi = {10.5381/jot.2006.5.4.a4},
	Inria = {hors},
	Journal = {Journal of Object Technology},
	Keywords = {scg-pub skip-doi scg-rotor traits scg-none jb06 fb06 snf05 snf06 jot stefPub},
	Medium = {2},
	Misc = {May-June},
	Month = may,
	Number = {4},
	Pages = {129--148},
	Peerreview = {yes},
	Selectif = {non},
	Title = {Flattening {Traits}},
	Url = {http://www.jot.fm/contents/issue_2006_05/article4.html http://www.jot.fm/issues/issue_2006_05/article4.pdf},
	Volume = {5},
	Year = {2006},
	Bdsk-Url-1 = {http://www.jot.fm/issues/issue_2006_05/article4%20http://www.jot.fm/issues/issue_2006_05/article4.pdf}}

@inproceedings{Nier06b,
	Abstract = {Software systems need to continuously change to
				  remain useful. Change appears in several forms and
				  needs to be accommodated at different levels. We
				  propose ChangeBoxes as a mechanism to encapsulate,
				  manage, analyze and exploit changes to software
				  systems. Our thesis is that only by making change
				  explicit and manipulable can we enable the software
				  developer to manage software change more effectively
				  than is currently possible. Furthermore we argue
				  that we need new insights into assessing the impact
				  of changes and we need to provide new tools and
				  techniques to manage them. We report on the results
				  of some initial prototyping efforts, and we outline
				  a series of research activities that we have started
				  to explore the potential of ChangeBoxes.},
	Annote = {internationalworkshop},
	Author = {Oscar Nierstrasz and Marcus Denker and Tudor G{\^\i}rba and Adrian Lienhard},
	Booktitle = {Proceedings of the Workshop on Revival of Dynamic Languages (co-located with ECOOP'06)},
	Cvs = {RDL06ACTSC},
	Keywords = {girba snf06 scg-pub skip-doi scg-none jb06 fb06},
	Medium = {2},
	Month = jul,
	Peerreview = {yes},
	Title = {Analyzing, Capturing and Taming Software Change},
	Url = {http://scg.unibe.ch/archive/papers/Nier06bRDL06ACTSC.pdf},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier06bRDL06ACTSC.pdf}}

@book{Nier06c,
	Address = {Genoa, Italy},
	Doi = {10.1007/11880240},
	Editor = {Oscar Nierstrasz and Jon Whittle and David Harel and Gianna Reggio},
	Isbn = {0302-9743},
	Keywords = {olit models skip-abstract scg-pub snf-none scg-none jb07 fb06},
	Month = oct,
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Proceedings {MoDELS} 2006},
	Url = {http://www.springeronline.com/3-540-45772-0 http://www.springerlink.com/openurl.asp?genre=issue&issn=0302-9743&volume=4199&issue=preprint},
	Volume = {4199},
	Year = {2006},
	Bdsk-Url-1 = {http://www.springeronline.com/3-540-45772-0%20http://www.springerlink.com/openurl.asp?genre=issue&issn=0302-9743&volume=4199&issue=preprint},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/11880240}}

@inproceedings{Nier07a,
	Abstract = {As software systems evolve, they become more complex
				  and harder to understand and maintain. Certain
				  reverse engineering techniques attempt to
				  reconstruct software models from source code with
				  the help of a parser for the source language.
				  Unfortunately a great deal of effort may be required
				  to build a specialized parser for a legacy
				  programming language or dialect. On the other hand,
				  (i) we typically do not need a complete parser that
				  recognizes all language constructs, and (ii) we have
				  a rich supply of (legacy) examples. We present an
				  approach to use these facts to rapidly and
				  incrementally develop parsers as follows: we specify
				  mappings from source code examples to model
				  elements; we use the mappings to generate a parser;
				  we parse as much code as we can; we use the
				  exceptional cases to develop new example mappings;
				  and we iterate. Experiments with Java and Ruby, two
				  very different languages, suggest that our approach
				  can be a very efficient and effective way to rapidly
				  construct software models from legacy code.},
	Acceptnum = {33},
	Accepttotal = {62},
	Address = {Los Alamitos CA},
	Annote = {internationalconference},
	Author = {Oscar Nierstrasz and Markus Kobel and Tudor G\^irba and Michele Lanza and Horst Bunke},
	Booktitle = {Proceedings of Conference on Software Maintenance and Reengineering (CSMR 2007)},
	Doi = {10.1109/CSMR.2007.23},
	Keywords = {scg07 hasler07 scg-pub jb07 snf07 norex07 girba moose-pub parsebyexample},
	Medium = {2},
	Misc = {acceptance rate: 33/62 = 52\%},
	Pages = {275--286},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society Press},
	Title = {Example-Driven Reconstruction of Software Models},
	Url = {http://scg.unibe.ch/archive/papers/Nier07aExampleDrivenMR.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier07aExampleDrivenMR.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/CSMR.2007.23}}

@techreport{Nier08a,
	Abstract = {Few real software systems are built completely from
				  scratch nowadays. Instead, systems are built
				  iteratively and incrementally, while integrating and
				  interacting with components from many other systems.
				  These systems also last longer than their developers
				  might imagine --- they are, in effect, eternal.
				  Nevertheless the platforms, tools and environments
				  we use to develop software are still largely based
				  on an outmoded model that presupposes that software
				  systems are closed and will not significantly evolve
				  after deployment. We claim that in order to enable
				  effective and graceful evolution of eternal systems,
				  we must make them self-aware. A self-aware eternal
				  system supports evolution by: (i) providing
				  explicit, first-class models of software artifacts,
				  change and history at the level of the platform,
				  (ii) continuously analysing static and dynamic
				  evolution to track emergent properties, and (iii)
				  closing the gap between the domain model and the
				  developers' view of the evolving system. We outline
				  our vision of self-aware eternal systems and
				  identify the research challenges to realizing this
				  vision.},
	Annote = {report notrefereed},
	Author = {Oscar Nierstrasz and Marcus Denker and Tudor G\^irba and Adrian Kuhn and Adrian Lienhard and David R{\"o}thlisberger},
	Institution = {University of Bern, Institute of Applied Mathematics and Computer Sciences},
	Keywords = {scg-pub scg-none jb08 snf08 skip-doi girba roethlisberger akuhn},
	Number = {IAM-08-001},
	Title = {Self-aware, Evolving Eternal Systems},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Nier08aSelfAwareEternal.pdf},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier08aSelfAwareEternal.pdf}}

@incollection{Nier08b,
	Abstract = {Few real software systems are built completely from
				  scratch nowadays. Instead, systems are built
				  iteratively and incrementally, while integrating and
				  interacting with components from many other systems.
				  Adaptation, reconfiguration and evolution are
				  normal, ongoing processes throughout the lifecycle
				  of a software system. Nevertheless the platforms,
				  tools and environments we use to develop software
				  are still largely based on an outmoded model that
				  presupposes that software systems are closed and
				  will not significantly evolve after deployment. We
				  claim that in order to enable effective and graceful
				  evolution of modern software systems, we must make
				  these systems more amenable to change by (i)
				  providing explicit, first-class models of software
				  artifacts, change, and history at the level of the
				  platform, (ii) continuously analysing static and
				  dynamic evolution to track emergent properties, and
				  (iii) closing the gap between the domain model and
				  the developers' view of the evolving system. We
				  outline our vision of dynamic, evolving software
				  systems and identify the research challenges to
				  realizing this vision.},
	Author = {Oscar Nierstrasz and Marcus Denker and Tudor G\^irba and Adrian Lienhard and David R\"othlisberger},
	Booktitle = {Challenges for Software-Intensive Systems and New Computing Paradigms},
	Doi = {10.1007/978-3-540-89437-7_3},
	Editor = {Martin Wirsing and Jean-Pierre Ban\^atre and Matthias H\"olzl},
	Isbn = {978-3-540-89436-0},
	Keywords = {scg08 scg-pub snf09 jb09 hasler09 girba cop-lit roethlisberger},
	Medium = {2},
	Pages = {64-79},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Change-Enabled Software Systems},
	Url = {http://scg.unibe.ch/archive/papers/Nier08bChangeEnabledSoftware.pdf},
	Volume = {5380},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier08bChangeEnabledSoftware.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-540-89437-7_3}}

@incollection{Nier09a,
	Abstract = {Software must be constantly adapted to changing
				  requirements. The time scale, abstraction level and
				  granularity of adaptations may vary from short-term,
				  fine-grained adaptation to long-term, coarse-grained
				  evolution. Fine-grained, dynamic and
				  context-dependent adaptations can be particularly
				  difficult to realize in long-lived, large-scale
				  software systems. We argue that, in order to
				  effectively and efficiently deploy such changes,
				  adaptive applications must be built on an
				  infrastructure that is not just model-driven, but is
				  both model-centric and context-aware. Specifically,
				  this means that high-level, causally-connected
				  models of the application and the software
				  infrastructure itself should be available at
				  run-time, and that changes may need to be scoped to
				  the run-time execution context. We first review the
				  dimensions of software adaptation and evolution, and
				  then we show how model-centric design can address
				  the adaptation needs of a variety of applications
				  that span these dimensions. We demonstrate through
				  concrete examples how model-centric and
				  context-aware designs work at the level of
				  application interface, programming language and
				  runtime. We then propose a research agenda for a
				  model-centric development environment that supports
				  dynamic software adaptation and evolution.},
	Author = {Oscar Nierstrasz and Marcus Denker and Lukas Renggli},
	Booktitle = {Software Engineering for Self-Adaptive Systems},
	Doi = {10.1007/978-3-642-02161-9_7},
	Editor = {Betty H.C. Cheng and Rogerio de Lemos and Holger Giese and Paola Inverardi and Jeff Magee},
	Keywords = {scg09 scg-pub diesel helvetia reflectivity snf09 jb09},
	Medium = {2},
	Pages = {128-145},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Model-Centric, Context-Aware Software Adaptation},
	Url = {http://scg.unibe.ch/archive/papers/Nier09aModelCentric.pdf},
	Volume = {5525},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier09aModelCentric.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-642-02161-9_7}}

@proceedings{Nier09b,
	Address = {New York, NY, USA},
	Editor = {Oscar Nierstrasz},
	Isbn = {978-1-60558-707-3},
	Keywords = {scg09 scg-pub snf09 jb10 skip-doi skip-abstract},
	Location = {Amsterdam, The Netherlands},
	Medium = {1},
	Order_No = {594094},
	Peerreview = {yes},
	Publisher = {ACM},
	Title = {{CASTA} '09: Proceedings of the first international workshop on {Context}-{Aware} {Software} {Technology} and {Applications}},
	Url = {http://portal.acm.org/toc.cfm?id=1595768 http://casta.unibe.ch},
	Year = {2009},
	Bdsk-Url-1 = {http://portal.acm.org/toc.cfm?id=1595768%20http://casta.unibe.ch}}

@inproceedings{Nier10a,
	Annote = {invited},
	Abstract = {The biggest challenge facing software developers
				  today is how to gracefully evolve complex software
				  systems in the face of changing requirements. We
				  clearly need software systems to be more dynamic,
				  compositional and model-centric, but instead we
				  continue to build systems that are static, baroque
				  and inflexible. How can we better build
				  change-enabled systems in the future? To answer this
				  question, we propose to look back to one of the most
				  successful systems to support change, namely
				  Smalltalk. We briefly introduce Smalltalk with a few
				  simple examples, and draw some lessons for software
				  evolution. Smalltalk's simplicity, its reflective
				  design, and its highly dynamic nature all go a long
				  way towards enabling change in Smalltalk
				  applications. We then illustrate how these lessons
				  work in practice by reviewing a number of research
				  projects that support software evolution by
				  exploiting Smalltalk's design. We conclude by
				  summarizing open issues and challenges for
				  change-enabled systems of the future.},
	Author = {Oscar Nierstrasz and Tudor G\^irba},
	Booktitle = {SOFSEM 2010},
	Doi = {10.1007/978-3-642-11266-9_7},
	Editor = {J. van Leeuwen et al.},
	Keywords = {scg-pub scg10 snf10 jb10 girba},
	Medium = {2},
	Pages = {77--95},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Lessons in Software Evolution Learned by Listening to {Smalltalk}},
	Url = {http://scg.unibe.ch/archive/papers/Nier10aSmalltalkLessons.pdf},
	Volume = {5901},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier10aSmalltalkLessons.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-642-11266-9_7}}

@article{Nier10b,
	Author = {Oscar Nierstrasz},
	Doi = {10.5381/jot.2010.9.5.e1},
	Issn = {1660-1769},
	Journal = {Journal of Object Technology},
	Keywords = {scg-pub snf-none scg10 jb11 skip-abstract lowRoad},
	Medium = {1},
	Month = sep,
	Note = {(editorial --- transcript of ECOOP 2010 banquet speech)},
	Number = {5},
	Peerreview = {no},
	Title = {Ten Things {I} Hate About Object-Oriented Programming},
	Url = {http://www.jot.fm/contents/issue_2010_09/editorial.html},
	Volume = {9},
	Year = {2010},
	Bdsk-Url-1 = {http://www.jot.fm/contents/issue_2010_09/editorial.html},
	Bdsk-Url-2 = {http://dx.doi.org/10.5381/jot.2010.9.5.e1}}

@article{Nier12a,
	Abstract = {During software maintenance, much time is spent reading and assessing existing code.
Unfortunately most of the tools available for exploring and assessing code, such as browsers, debuggers and
profilers, focus on development tasks, and offer little to support program understanding. We present a
platform for software and data analysis, called Moose, which enables the rapid development of custom tools
for software assessment. We demonstrate how Moose supports agile software assessment through a series of
demos, we illustrate some of the custom tools that have been developed, and we draw various lessons learned
for future work in this domain.},
	Acmid = {2180925},
	Acmpage = {http://dl.acm.org/citation.cfm?id=2180925},
	Address = {New York, NY, USA},
	Author = {Oscar Nierstrasz},
	Doi = {10.1145/180921.2180925},
	Issn = {0163-5948},
	Issue_Date = {May 2012},
	Journal = {SIGSOFT Softw. Eng. Notes},
	Keywords = {scg-pub snf12 scg12 jb12 moose-pub},
	Medium = {2},
	Month = may,
	Number = {3},
	Numpages = {5},
	Pages = {1--5},
	Annote = {invited},
	Peerreview = {no},
	Publisher = {ACM},
	Title = {Agile software assessment with {Moose}},
	Url = {http://scg.unibe.ch/archive/papers/Nier12aASA.pdf},
	Volume = {37},
	Year = {2012},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier12aASA.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/180921.2180925}}

@inproceedings{Nier12b,
	Abstract = {Informed decision making is a critical activity in software development, but it is poorly
  supported by common development environments, which focus mainly on low-level programming tasks. We posit
  the need for agile software assessment, which aims to support decision making by enabling rapid and
  effective construction of software models and custom analyses. Agile software assessment entails
  gathering and exploiting the broader context of software information related to the system at hand as
  well as the ecosystem of related projects, and beyond to include ``big software data''. Finally, informed
  decision making entails continuous assessment by monitoring the evolving system and its architecture. We
  identify several key research challenges in supporting agile software assessment by focusing on
  customization, context and continuous assessment.},
	Author = {Oscar Nierstrasz and Mircea Lungu},
	Booktitle = {Proceedings of International Conference on Program Comprehension (ICPC 2012)},
	Doi = {10.1109/ICPC.2012.6240507},
	Issn = {1063-6897},
	Keywords = {scg-pub snf12 snf-asa1 scg12 jb12 moose-pub},
	Medium = {2},
	Pages = {3--10},
	Peerreview = {no},
	Title = {Agile software assessment},
	Annote = {invited},
	Url = {http://scg.unibe.ch/archive/papers/Nier12bASA.pdf},
	Year = {2012},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier12bASA.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICPC.2012.6240507}}

@incollection{Nier13a,
	Author = {Oscar Nierstrasz and Alexandre Bergel and Damien Cassou and St\'ephane Ducasse and Jannik Laval},
	Booktitle = {Deep Into Pharo},
	Isbn = {978-3-9523341-6-4},
	Keywords = {jb14 snf-none scg-pub scg13 skip-doi skip-abstract},
	Medium = {2},
	Month = sep,
	Pages = 21,
	Peerreview = {no},
	Publisher = {Square Bracket Associates},
	Title = {Regular Expressions in Pharo},
	Url = {http://scg.unibe.ch/archive/papers/Nier13aRegEx.pdf},
	Year = {2013},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier13aRegEx.pdf}}

@incollection{Nier13b,
	Author = {Oscar Nierstrasz and Alexandre Bergel and Damien Cassou and St\'ephane Ducasse and Jannik Laval},
	Booktitle = {Deep Into Pharo},
	Isbn = {978-3-9523341-6-4},
	Keywords = {jb14 snf-none scg-pub scg13 skip-doi skip-abstract},
	Medium = {2},
	Month = sep,
	Pages = 27,
	Peerreview = {no},
	Publisher = {Square Bracket Associates},
	Title = {Versioning Your Code with Monticello},
	Url = {http://scg.unibe.ch/archive/papers/Nier13bMonticello.pdf},
	Year = {2013},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier13bMonticello.pdf}}

@article{Nier13c,
	Abstract = {Abstract In order to analyze software systems, it is necessary to
		model them. Static software models are commonly imported by parsing source
        code and related data. Unfortunately, building custom parsers for most
        programming languages is a non-trivial endeavour. This poses a major
        bottleneck for analyzing software systems programmed in languages for
        which importers do not already exist. Luckily, initial software models do
        not require detailed parsers, so it is possible to start analysis with a
        coarse-grained importer, which is then gradually refined. In this paper we
        propose an approach to "agile modeling" that exploits island grammars to
        extract initial coarse-grained models, parser combinators to enable
        gradual refinement of model importers, and various heuristics to recognize
        language structure, keywords and other language artifacts.},
	Author = {Oscar Nierstrasz and Jan Kur\v{s}},
	Doi = {10.1016/j.scico.2013.11.011},
	Issn = {0167-6423},
	Journal = {Science of Computer Programming},
	Keywords = {jb14 snf-asa1 scg-pub scg13 kursjan},
	Annote = {internationaljournal},
	Medium = {2},
	Number = {0},
	Pages = {150--156},
	Peerreview = {yes},
	Title = {Parsing for agile modeling},
	Url = {http://scg.unibe.ch/archive/papers/Nier13cAgileModeling.pdf},
	Volume = {97, Part 1},
	Year = {2015},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Nier13cAgileModeling.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.scico.2013.11.011}}

@inproceedings{Nier16a,
	Annote = {invited, internationalconference},
	Abstract = {Modern software systems are increasingly long-lived. In order to gracefully
			evolve these systems as they address new requirements, developers need
			to navigate effectively between domain concepts and the code that
			addresses those domains. One of the original promises of
			object-orientation was that the same object-oriented models would be
			used throughout requirements analysis, design and implementation.
			Software systems today however are commonly constructed from a
			heterogeneous ``language soup'' of mainstream code and dedicated DSLs
			addressing a variety of application and technical domains. Has
			object-oriented programming outlived its purpose? In this essay we
			argue that we need to rethink the original goals of object-orientation
			and their relevance for modern software development. We propose as a
			driving maxim, ``Programming is Modeling,'' and explore what this
			implies for programming languages, tools and environments. In
			particular, we argue that: (1) source code should serve not only to
			specify an implementation of a software system, but should encode a
			queryable and manipulable model of the application and technical
			domains concerned; (2) IDEs should exploit these domain models to
			enable inexpensive browsing, querying and analysis by developers; and
			(3) barriers between the code base, the running application, and the
			software ecosystem at large need to be broken down, and their
			connections exploited and monitored to support developers in
			comprehension and evolution tasks.},
	Author = {Oscar Nierstrasz},
	Booktitle = {FASE 2016},
	Editor = {Perdita Stevens and Andrzej Wasowski},
	Keywords = {scg-pub snf-none scg16 jb16},
	Doi = {10.1007/978-3-662-49665-7_1},
	Pages = {3--10},
	Medium = {2},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {The Death of Object-Oriented Programming},
	Url = {http://scg.unibe.ch/archive/papers/Nier16a-death-of-oop.pdf},
	Volume = {9633},
	Year = {2016}
}

@inproceedings{Osma14a,
	Annote = {internationalconference},
	Abstract = {Detecting bugs as early as possible plays an important role in ensuring software quality before shipping. We argue that mining previous bug fixes can produce good knowledge about why bugs happen and how they are fixed. In this paper, we mine the change history of 717 open source projects to extract bug-fix patterns. We also manually inspect many of the bugs we found to get insights into the contexts and reasons behind those bugs. For instance, we found out that missing null checks and missing initializations are very recurrent and we believe that they can be automatically detected and fixed.},
	Author = {Osman, Haidar and Lungu, Mircea and Nierstrasz, Oscar},
	Booktitle = {Software Maintenance, Reengineering and Reverse Engineering (CSMR-WCRE), 2014 Software Evolution Week - IEEE Conference on},
	Doi = {10.1109/CSMR-WCRE.2014.6747191},
	Keywords = {scg14 jb14 scg-pub snf-asa1; Cloning;Computer bugs;Data mining;History;Java;Software;Software engineering scg-bigdata},
	Month = feb,
	Pages = {343-347},
	Title = {Mining frequent bug-fix code changes},
	Url = {http://scg.unibe.ch/archive/papers/Osma14aMiningBugFixChanges.pdf},
	Year = {2014},
	PeerReview = {yes},
	Medium = {2},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Osma14aMiningBugFixChanges.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/CSMR-WCRE.2014.6747191}}

@inproceedings{Osma15a,
		Annote = {internationalworkshop},
		Author = {Haidar Osman},
		Abstract = {Null dereferencing is one of the most frequent bugs in Java systems
causing programs to crash due to the uncaught NullPointerException.
Developers often fix this bug by introducing a guard (i.e., null check)
on the potentially-null objects before using them.
In this paper we investigate the null checks in 717 open-source Java
systems to understand when and why developers introduce null checks.
We find that 35% of the if-statements are null checks. A deeper investigation
shows that 71% of the checked-for-null objects are returned
from method calls. This indicates that null checks have a serious impact
on performance and that developers introduce null checks when
they use methods that return null.},
title = {Null Check Analysis},
		booktitle = {Extended Abstracts of the Eighth Seminar on Advanced Techniques and Tools for Software Evolution (SATToSE 2015)},
		year = {2015},
		month = jul,
		location = {Mons, Belgium},
		pages = {86--88},
		numpages = {3},
		PeerReview = {yes},
		Medium = {2},
		Keywords = {scg-pub snf-asa1 scg15 jb15 skip-doi},
		Url = {http://scg.unibe.ch/archive/papers/Osma15a.pdf}}

@inproceedings{Osma16a,
		Annote = {internationalconference},
		Author = {Haidar Osman and Manuel Leuenberger and Mircea Lungu and Oscar Nierstrasz},
		Title = {Tracking Null Checks in Open-Source {Java} Systems},
		Abstract = {It is widely acknowledged that null values should be avoided if possible or carefully used when necessary in Java code. The careless use of null has negative effects on maintainability, code readability, and software performance. However, a study on understanding null usage is still missing.
		In this paper we analyze null checks in 810 open-source Java systems and manually inspect 100 code samples to understand when and why developers use null. We find that 35% of all conditional statements contain null checks. A deeper investigation reveals many questionable practices with respect to using null. Uninitialized member variables, returning null in methods, and passing null as a method parameter are among the most recurrent reasons for introducing null checks. Developers often return null in methods to signal errors instead of throwing a proper exception. As a result, 71% of the values checked for null are returned from method calls.
		Our study provides a novel evidence of an overuse of null checks and of the null value itself in Java, and at the same time, reveals actionable recommendations to reduce this null usage.},
		Keywords = {scg-pub snf-asa2 jb16 scg16},
		Booktitle = {Proceedings of the 23rd IEEE International Conference on Software Analysis, Evolution, and Reengineering (SANER)},
		PeerReview = {yes},
		Medium = {2},
		Year = {2016},
		doi= {10.1109/SANER.2016.57},
		month=mar,
		Url = {http://scg.unibe.ch/archive/papers/Osma16a.pdf}}

@inproceedings{Osma16b,
				Annote = {internationalworkshop},
				Author = {Haidar Osman},
				Abstract = {Bug prediction is a technique used to estimate the most bug-prone entities in software systems. Bug prediction approaches vary in many design options, such as dependent variables, independent variables, and machine learning models. Choosing the right combination of design options to build an effective bug predictor is hard. Previous studies do not consider this complexity and draw conclusions based on fewer-than-necessary experiments.
We argue that each software project is unique from the perspective of its development process. Consequently, metrics and AI models perform differently on different projects, in the context of bug prediction.
We confirm our hypothesis empirically by running different bug predictors on different systems. We show that no single bug prediction configuration works globally on all projects and, thus, previous bug prediction findings cannot generalize.},
		title = {Against the Mainstream in Bug Prediction},
				booktitle = {Extended Abstracts of the Ninth Seminar on Advanced Techniques and Tools for Software Evolution (SATToSE 2016)},
				year = {2016},
				month = jul,
				location = {Bergen, Norway},
				numpages = {4},
				PeerReview = {yes},
				Medium = {2},
				Keywords = {scg-pub snf-asa2 scg16 jb16 skip-doi},
				Url = {http://scg.unibe.ch/archive/papers/Osma16b.pdf},
				note = {http://sattose.wdfiles.com/local--files/2016:alltalks/SATTOSE2016\_paper\_2.pdf}
}

@inproceedings{Osma16c,
				Annote = {internationalworkshop},
				Author = {Haidar Osman},
				Abstract={Bug prediction is a technique used to estimate the most
bug-prone entities in software systems. Bug prediction
approaches vary in many design options, such as dependent
variables, independent variables, and machine
learning models. Choosing the right combination of design
options to build an effective bug predictor is hard.
Previous studies do not consider this complexity and
draw conclusions based on fewer-than-necessary experiments.
We argue that each software project is unique from the
perspective of its development process. Consequently,
metrics and machine learning models perform differently
on different projects, in the context of bug prediction.
We confirm our hypothesis empirically by running different
bug predictors on different systems. We show there
are no universal bug prediction configurations that work
on all projects.},
		title = {On the Non-Generalizability in Bug Prediction},
				booktitle = {Post Proceedings of the Ninth Seminar on Advanced Techniques and Tools for Software Evolution (SATToSE 2016)},
				year = {2016},
				location = {Bergen, Norway},
				PeerReview = {yes},
				numpages = {7},
				Medium = {2},
				Keywords = {scg-pub snf-asa2 scg16 jb17 skip-doi},
				Url = {http://ceur-ws.org/Vol-1791/paper-03.pdf}
}

@inproceedings{Osma17a,
	Annote = {internationalworkshop},
	Author = {Haidar Osman and Mohammad Ghafari and Oscar Nierstrasz},
	booktitle = {1st International Workshop on Machine Learning Techniques for Software Quality Evaluation (MaLTeSQuE 2017)},
	Title = {Hyperparameter Optimization to Improve Bug Prediction Accuracy},
	month = feb,
	Year = {2017},
	location = {Klagenfurt, Austria},
	PeerReview = {yes},
	numpages = {6},
	Medium = {2},
	pages={33--38},
	Url = {http://scg.unibe.ch/archive/papers/Osma17a.pdf},
	DOI = {10.1109/MALTESQUE.2017.7882014},
	keywords={scg-pub snf-asa2 scg17 jb17},
	abstract={Bug prediction is a technique that strives to identify
where defects will appear in a software system. Bug prediction
employs machine learning to predict defects in software entities
based on software metrics. These machine learning models
usually have adjustable parameters, called hyperparameters, that
need to be tuned for the prediction problem at hand. However,
most studies in the literature keep the model hyperparameters
set to the default values provided by the used machine learning
frameworks.
In this paper we investigate whether optimizing the hyperparameters
of a machine learning model improves its prediction
power. We study two machine learning algorithms: k-nearest
neighbours (IBK) and support vector machines (SVM). We
carry out experiments on five open source Java systems. Our
results show that (i) models differ in their sensitivity to their
hyperparameters, (ii) tuning hyperparameters gives at least as
accurate models for SVM and significantly more accurate models
for IBK, and (iii) most of the default values are changed during
the tuning phase. Based on these findings we recommend tuning
hyperparameters as a necessary step before using a machine
learning model in bug prediction.}
}

@inproceedings{Osma17b,
		Annote = {internationalconference},
		Author = {Osman, Haidar and Chi\c{s}, Andrei and Schaerer, Jakob and Ghafari, Mohammad and Nierstrasz, Oscar},
		Booktitle = {Proceedings of the 24rd IEEE International Conference on Software Analysis, Evolution, and Reengineering (SANER)},
		Month = feb,
		Pages = {422--426},
		Medium = {2},
		Title = {On the Evolution of Exception Usage in {Java} Projects},
		Url = {http://scg.unibe.ch/archive/papers/Osma17b-exception-usage.pdf},
		DOI = {10.1109/SANER.2017.7884646},
		Year = {2017},
		PeerReview = {yes},
		keywords={scg-pub snf-asa2 scg17 jb17},
		abstract={Programming languages use exceptions to handle
abnormal situations during the execution of a program. While
programming languages often provide a set of standard exceptions,
developers can further create custom exceptions to capture
relevant data about project- and domain-specific errors. We
hypothesize that, given their usefulness, custom exceptions are
used increasingly as software systems mature. To assess this
claim, we empirically analyze the evolution of exceptions and
exception-handling code within four, popular and long-lived Java
systems. We observe that indeed the amount of error-handling
code, together with the number of custom exceptions and their
usage in catch handlers and throw statements increase as projects
evolve. However, we find that the usage of standard exceptions
increases more than the usage of custom exceptions in both catch
handlers and throw statements. A preliminary manual analysis
of throw statements reveals that developers encode the domain
information into the standard Java exceptions as custom string
error messages instead of relying on custom exception classes.}}

@inproceedings{Osma17c,
	Annote = {internationalworkshop},
	Author = {Haidar Osman and Mohammad Ghafari and Oscar Nierstrasz},
	booktitle = {1st International Workshop on Machine Learning Techniques for Software Quality Evaluation (MaLTeSQuE 2017)},
	Title = {Automatic Feature Selection by Regularization to Improve Bug Prediction Accuracy},
	month = feb,
	Year = {2017},
	location = {Klagenfurt, Austria},
	PeerReview = {yes},
	numpages = {6},
	Medium = {2},
	pages={27--32},
	Url = {http://scg.unibe.ch/archive/papers/Osma17c-bugPredictionRegularization.pdf},
	DOI = {10.1109/MALTESQUE.2017.7882013},
	keywords={scg-pub snf-asa2 scg17 jb17},
	abstract={Bug prediction has been a hot research topic for
the past two decades, during which different machine learning
models based on a variety of software metrics have been
proposed. Feature selection is a technique that removes noisy and
redundant features to improve the accuracy and generalizability
of a prediction model. Although feature selection is important, it
adds yet another step to the process of building a bug prediction
model and increases its complexity. Recent advances in machine
learning introduce embedded feature selection methods that allow
a prediction model to carry out feature selection automatically
as part of the training process. The effect of these methods on
bug prediction is unknown.
In this paper we study regularization as an embedded feature
selection method in bug prediction models. Specifically, we study
the impact of three regularization methods (Ridge, Lasso, and
ElasticNet) on linear and Poisson Regression as bug predictors
for five open source Java systems. Our results show that the
three regularization methods reduce the prediction error of the
regressors and improve their stability}
}

@inproceedings{Osma17d,
 author = {Haidar Osman and Andrei Chi\c{s} and Claudio Corrodi and Mohammad Ghafari and Oscar Nierstrasz},
 title = {Exception Evolution in Long-lived {Java} Systems},
 booktitle = {Proceedings of the 14th International Conference on Mining Software Repositories},
    Annote    = {internationalconference},
 series = {MSR '17},
 year = {2017},
 location = {Buenos Aires, Argentina},
 url = {http://scg.unibe.ch/archive/papers/Osma17d-exception-evolution.pdf},
 keywords={scg-pub snf-asa2 scg17 jb17},
 doi = {10.1109/MSR.2017.21},
 PeerReview = {yes},
 Medium = {2},
 abstract = {Exception handling allows developers to deal with abnormal situations that disrupt the execution flow of a program. There are mainly three types of exceptions: standard exceptions provided by the programming language itself, custom exceptions defined by the project developers, and third-party exceptions defined in external libraries. We conjecture that there are multiple factors that affect the use of these exception types. We perform an empirical study on long-lived Java projects to investigate these factors. In particular, we analyze how developers rely on the different types of exceptions in throw statements and exception handlers. We confirm that the domain, the type, and the development phase of a project affect the exception handling patterns. We observe that applications have significantly more error handling code than libraries and they increasingly rely on custom exceptions. Also, projects that belong to different domains have different preferences of exception types. For instance, content management systems rely more on custom exceptions than standard exceptions whereas the opposite is true in parsing frameworks.}
}

@inproceedings{Osma17f,
author = {Osman, Haidar and Ghafari, Mohammad and Nierstrasz, Oscar and Lungu, Mircea},
 title = {An Extensive Analysis of Efficient Bug Prediction Configurations},
 booktitle = {Proceedings of the 13th International Conference on Predictive Models and Data Analytics in Software Engineering},
    Annote    = {internationalconference},
 series = {PROMISE},
 year = {2017},
 isbn = {978-1-4503-5305-2},
 location = {Toronto, Canada},
 pages = {107--116},
 numpages = {10},
 PeerReview = {yes},
 medium = {2},
 url = {http://scg.unibe.ch/archive/papers/Osma17f-EfficientBugPrediction.pdf},
 doi = {10.1145/3127005.3127017},
 acmid = {3127017},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords={scg-pub snf-asa2 scg17 jb18},
abstract = {Background: Bug prediction helps developers steer maintenance activities towards the buggy parts of a software. There are many design aspects to a bug predictor, each of which has several options, i.e. software metrics, machine learning model, and response variable.
Aims: These design decisions should be judiciously made because an improper choice in any of them might lead to wrong, misleading, or even useless results. We argue that bug prediction configurations are intertwined and thus need to be evaluated in their entirety, in contrast to the common practice in the field where each aspect is investigated in isolation.
Method: We use a cost-aware evaluation scheme to evaluate 60 different bug prediction configuration combinations on five open source Java projects.
Results: We find out that the best choices for building a cost-effective bug predictor are change metrics mixed with source code metrics as independent variables, Random Forest as the machine learning model, and the number of bugs as the response variable. Combining these configuration options results in the most efficient bug predictor across all subject systems.
Conclusions: We demonstrate a strong evidence for the interplay among bug prediction configurations and provide concrete guidelines for researchers and practitioners on how to build and evaluate efficient bug predictors.}
}

@inproceedings{Patk18b,
 author = {Nitish Patkar},
 title = {Towards Executable Domain Models},
 abstract = {Lack of stakeholder commitment to project activities is an important cause of project failure. It leads to poor understanding of the problem domain and ultimately to incorrect domain modeling. We believe that combining Goal Directed Design methodology with Domain Driven Design using the Naked Objects Pattern would help stakeholders to become actively involved in important project activities such as requirements elicitation and rapid prototyping. This paper suggests how these approaches can gracefully be combined to facilitate active stakeholder involvement right from requirements elicitation until rapid prototyping to build a clear product vision, and realize it through an executable domain model.},
 booktitle = {Seminar Series on Advanced Techniques \& Tools for Software Evolution (SATToSE)},
 Annote = {internationalworkshop},
 PeerReview = {yes},
 Medium = {1},
 Keywords = {scg-pub skip-doi snf-asa2 scg18 jb18},
 year = {2018},
 Url = {http://scg.unibe.ch/archive/papers/Patk18b.pdf}
}

@inproceedings{Patk19a,
	author={Patkar, Nitish and Gadient, Pascal and Ghafari, Mohammad and Nierstrasz, Oscar},
	booktitle={25th International Conference on Requirements Engineering: Foundation for Software Quality (REFSQ)},
	title={Towards a Catalogue of Mobile Elicitation Techniques},
	year={2019},
	annote={internationalconference},
	peerreview={yes},
	medium={2},
	doi={10.1007/978-3-030-15538-4_20},
	abstract={Mobile apps are crucial for many businesses. Their reach and impact on the end users and on the business in return demands that requirements are elicited carefully and properly. Traditional requirements elicitation techniques may not be adequate in the mobile apps domain. Researchers have proposed numerous requirements elicitation techniques for the mobile app domain, but unfortunately, the community still lacks a comprehensive overview of available techniques. This paper presents a literature survey of about 60 relevant publications, in which we identify 24 techniques that target mobile apps. We found that only every second strategy was evaluated empirically, and even worse, non-functional requirements were rarely considered. We provide an evaluation scheme that is intended to support readers in efficiently finding opportune elicitation techniques for mobile apps. The found literature characteristics may guide future research and help the community to create more efficient, yet better, apps.},
	keywords={scg-pub snf-asa3 scg19 jb19},
	url={http://scg.unibe.ch/archive/papers/Patk19a.pdf}
}

@inproceedings{Patk20a,
author = {Patkar, Nitish and Ghafari, Mohammad and Nierstrasz, Oscar and Hotomski, Sofija},
title = {Caveats in Eliciting Mobile App Requirements},
year = {2020},
peerreview={yes},
abstract={Factors such as app stores or platform choices heavily affect functional and non-functional mobile app requirements. We surveyed 45 companies and interviewed ten experts to explore how factors that impact mobile app requirements are understood by requirements engineers in the mobile app industry.
We observed the lack of knowledge in several areas. For instance, we observed that all practitioners were aware of data privacy concerns, however, they did not know that certain third-party libraries, usage aggregators, or advertising libraries also occasionally leak sensitive user data. Similarly, certain functional requirements may not be implementable in the absence of a third-party library that is either banned from an app store for policy violations or lacks features, for instance, missing desired features in ARKit library for iOS made practitioners turn to Android.
We conclude that requirements engineers should have adequate technical experience with mobile app development as well as sufficient knowledge in areas such as privacy, security and law, in order to make informed decisions during requirements elicitation.
},
isbn = {9781450377317},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {http://scg.unibe.ch/archive/papers/Patk20.pdf},
doi = {10.1145/3383219.3383238},
booktitle = {Proceedings of the Evaluation and Assessment in Software Engineering},
pages = {180--189},
numpages = {10},
keywords = {scg-pub  snf-asa3 scg20 jb20 snf-imad},
location = {Trondheim, Norway},
series = {EASE 2020},
Medium = {2},
Url={http://scg.unibe.ch/archive/papers/Patk20.pdf}
}

@inproceedings{Patk20b,
author    = {Nitish Patkar and Leonel Merino and Oscar Nierstrasz},
title     = {Towards requirements engineering with immersive augmented reality},
peerreview={yes},
abstract={Often, requirements engineering (RE) activities demand project stakeholders to communicate and collaborate with each other towards building a common software product vision. We conjecture that augmented reality (AR) can be a good fit to support such communication and collaboration. In this vision paper, we report on state-of-the-art research at the intersection of AR and RE. We found that requirements elicitation and analysis have been supported by the ability of AR to provision on-the-fly information such as augmented prototypes. We discuss and map the existing challenges in RE to the aspects of AR that can boost the productivity and user experience of existing RE techniques. Finally, we elaborate on various envisioned usage scenarios in which we highlight concrete benefits and challenges of adopting immersive AR to assist project stakeholders in RE activities.
  },
booktitle = {Proc.\ Programming'20 Companion},
publisher = {ACM},
pages     = {55--60},
doi       = {10.1145/3397537.3398472},
year      = {2020},
url = {http://scg.unibe.ch/archive/papers/Patk20b.pdf},
keywords = {scg-pub  snf-asa3 scg20 jb20 snf-imad},
Medium = {2}
}

@inproceedings{Patk20c,
author    = {Nitish Patkar},
title     = {Moldable requirements},
peerreview={yes},
abstract={Separate tools are employed to carry out
individual requirements engineering (RE) activities.
The lack of integration among these tools scatters
the domain knowledge, making collaboration between
technical and non-technical stakeholders difficult, and
management of requirements a tedious task. In this
Ph.D. research proposal, we argue that an integrated
development environment (IDE) should support various
RE activities. For that, distinct stakeholders must
be able to effortlessly create and manage requirements
as first-class citizens within an IDE.
With "moldable requirements," developers create
custom hierarchies of requirements and build tailored
interfaces that enable other stakeholders to create
requirements and navigate between them. Similarly,
they create custom representations of requirements
and involved domain objects to reflect various levels
of detail. Such custom and domain-specific representations
assist non-technical stakeholders in accomplishing
their distinguished RE related tasks. The custom
interfaces make the IDE usable for non-technical
stakeholders and help to preserve requirements in one
place, closer to the implementation.},
booktitle = {Benevol'20},
year      = {2020},
url = {http://scg.unibe.ch/archive/papers/Patk20c.pdf},
keywords = {scg-pub skip-doi snf-asa3 scg20 jb21 snf-imad},
Medium = {2}
}

@inproceedings{Patk21a,
author    = {Nitish Patkar and Andrei Chis and Nataliia Stulova and Oscar Nierstrasz},
title     = {Interactive Behavior-driven Development: a Low-code Perspective},
peerreview={yes},
abstract={Within behavior-driven development (BDD), different
types of stakeholders collaborate in creating scenarios
that specify application behavior. The current workflow for
BDD expects non-technical stakeholders to use an integrated
development environment (IDE) to write textual scenarios in
the Gherkin language and verify application behavior using test
passed/failed reports. Research to date shows that this approach
leads non-technical stakeholders to perceive BDD as an overhead
in addition to the testing.
In this vision paper, we propose an alternative approach to
specify and verify application behavior visually, interactively,
and collaboratively within an IDE. Instead of writing textual
scenarios, non-technical stakeholders compose, edit, and save
scenarios by using tailored graphical interfaces that allow them
to manipulate involved domain objects. Upon executing such
interactively composed scenarios, all stakeholders verify the application
behavior by inspecting domain-specific representations
of run-time domain objects instead of a test run report. Such
a low code approach to BDD has the potential to enable nontechnical
stakeholders to engage more harmoniously in behavior
specification and validation together with technical stakeholders
within an IDE. There are two main contributions of this work:
(i) we present an analysis of the features of 13 BDD tools, (ii) we
describe a prototype implementation of our approach, and (iii) we
outline our plan to conduct a large-scale developer survey to
evaluate our approach to highlight the perceived benefits over
the existing approach.},
booktitle = {Proceedings of the 24rd ACM/IEEE International Conference on Model Driven Engineering Languages and Systems: Companion Proceedings},
publisher = {ACM},
year      = {2021},
url = {http://scg.unibe.ch/archive/papers/Patk21a.pdf},
keywords = {scg-pub snf-asa3 scg22 jb22 snf-imad},
doi = {10.1109/MODELS-C53483.2021.00024},
Medium = {2}
}

@inproceedings{Patk22a,
author    = {Nitish Patkar and Andrei Chis and Nataliia Stulova and Oscar Nierstrasz},
title     = {First-class artifacts as building blocks for live in-{IDE} documentation},
peerreview={yes},
abstract={A traditional round-trip engineering approach based on model transformations does not scale well to modern agile development environments where numerous artifacts are
produced using a range of heterogeneous tools and technologies. To boost artifact connectivity and maintain their consistency, we propose to create and manage software-related artifacts as first-class entities directly in an integrated development environment (IDE).  This approach has two advantages: (i) compared to employing separate tools, creating various artifacts directly within a development platform eliminates the necessity to recover trace links, and (ii) first-class artifacts can be composed into stakeholder-specific live document-artifacts. We detail and exemplify our approach in the Glamorous Toolkit IDE (henceforth,
Glamorous toolkit), and discuss the results of a semi-structured pilot survey we conducted with practitioners and researchers to evaluate its usefulness in practice.},
booktitle = {2022 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)},
organization = {IEEE},
year      = {2022},
url = {http://scg.unibe.ch/archive/papers/Patk22a.pdf},
doi = {10.1109/SANER53432.2022.00016},
keywords = {scg-pub snf-asa3 scg22 jb22 snf-imad},
Medium = {2}
}

@inproceedings{Patk22b,
  author    = {Adwait Chandorkar and Nitish Patkar and Andrea Di Sorbo and Oscar Nierstrasz},
  title     = {An Exploratory Study on the Usage of {Gherkin} Features in Open-Source Projects},
  peerreview={yes},
  abstract={With behavior-driven development (BDD), domain experts describe system behavior and desired outcomes through natural language-like sentences, e.g., using the Gherkin language. BDD frameworks partially convert the content of Gherkin specifications into executable test code. Previous studies have reported several issues with the current BDD practice, for example long repetitive Gherkin specifications and slow-running test suites. Data tables and additional features were added to the Gherkin syntax to express compactly test inputs (e.g., provide different combinations of input values and desired outputs to run tests multiple times) and also to improve the readability of Gherkin files (henceforth called spec files). However, there is no empirical evidence about the actual usage of these Gherkin features. To fill this gap, we analyzed the content of 1,572 spec files extracted from 23 open-source projects. For each spec file, we collected a set of metrics modeling the structure and the usage of the different Gherkin features. We found that only a minority of the considered spec files (i.e., 590) used data tables that contain two rows, on average. We also used statistical tests to compare the contents of spec files with and without data tables and found significant differences between the two populations, especially for what concerns the number of lines of code (LoC). On the one hand, our results shed some light on the discrepancies between the recommendations for defining Gherkin specifications and their actual adoption in practice. On the other hand, our findings demonstrate that the adoption of additional features, such as data tables, might only partially help to reduce the length of Gherkin specifications.},
	booktitle={5th Workshop on Validation, Analysis and Evolution of Software Tests (VST 2022, co-located with SANER 2022)},
organization = {IEEE},
	month=mar,
  year      = {2022},
  url = {http://scg.unibe.ch/archive/papers/Patk22b.pdf},
  doi = {10.1109/SANER53432.2022.00134},
  keywords = {scg-pub  snf-asa3 scg22 jb22 snf-imad},
	Annote = {internationalworkshop},
  Medium = {2}
}

@inproceedings{Peri09a,
	Abstract = {Enterprise Applications are complex software systems
				  that manipulate much persistent data and interact
				  with the user through a vast and complex user
				  interface. In particular applications written for
				  the Java 2 Platform, Enterprise Edition (J2EE) are
				  composed using various technologies such as
				  Enterprise Java Beans (EJB) or Java Server Pages
				  (JSP) that in turn rely on languages other than
				  Java, such as XML or SQL. In this heterogeneous
				  context applying existing reverse engineering and
				  quality assurance techniques developed for
				  object-oriented systems is not enough. Because those
				  techniques have been created to measure quality or
				  provide information about one aspect of J2EE
				  applications, they cannot properly measure the
				  quality of the entire system. We intend to devise
				  techniques and metrics to measure quality in J2EE
				  applications considering all their aspects and to
				  aid their evolution. Using software visualization we
				  also intend to inspect to structure of J2EE
				  applications and all other aspects that can be
				  investigate through this technique. In order to do
				  that we also need to create a unified meta-model
				  including all elements composing a J2EE
				  application.},
	Annote = {internationalworkshop},
	Author = {Fabrizio Perin},
	Booktitle = {Proceedings of the PhD Symposium at the Working Conference on Reverse Engineering (WCRE 2009)},
	Doi = {10.1109/WCRE.2009.45},
	Keywords = {scg09 scg-pub jb10 hasler09 moose-pub},
	Location = {Lille, France},
	Medium = {2},
	Month = oct,
	Pages = {291-294},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society Press},
	Title = {Enabling the evolution of {J2EE} applications through reverse engineering and quality assurance},
	Url = {http://scg.unibe.ch/archive/papers/Peri09aEnablingevolutionOfJEAs.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Peri09aEnablingevolutionOfJEAs.pdf}}

@inproceedings{Peri09b,
	Abstract = {Java Enterprise Applications (JEAs) are complex
				  systems composed using various technologies that in
				  turn rely on languages other than Java, such as XML
				  or SQL. Given the complexity of these applications,
				  the need to reverse engineer them in order to
				  support further development becomes critical. In
				  this paper we show how it is possible to split a
				  system into layers and how is possible to interpret
				  the distance between application elements in order
				  to support the refactoring of JEAs. The purpose of
				  this paper is to explore ways to provide suggestions
				  about the refactoring operations to perform on the
				  code by evaluating the distance between layers and
				  elements belonging those layers. We split JEAs into
				  layers by considering the kinds and the purposes of
				  the elements composing the application. We measure
				  distance between elements by using the notion of the
				  shortest path in a graph. Also we present how to
				  enrich the interpretation of the distance value with
				  enterprise pattern detection in order to refine the
				  suggestion about modifications to perform on the
				  code.},
	Annote = {internationalworkshop},
	Author = {Fabrizio Perin},
	Booktitle = {Proceedings of FAMOOSr at the Working Conference on Reverse Engineering (WCRE 2009)},
	Keywords = {scg09 scg-pub jb10 hasler09 moose-pub skip-doi},
	Location = {Lille, France},
	Medium = {2},
	Month = oct,
	Pages = {20-24},
	Peerreview = {yes},
	Title = {Driving the refactoring of {Java Enterprise} applications by evaluating the distance between application elements},
	Url = {http://scg.unibe.ch/archive/papers/Peri09bDistancesBetweenElements.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Peri09bDistancesBetweenElements.pdf}}

@inproceedings{Peri10a,
	Abstract = {Java Enterprise Applications (JEAs) are large
				  systems that integrate multiple technologies and
				  programming languages. Transactions in JEAs simplify
				  the development of code that deals with failure
				  recovery and multi-user coordination by guaranteeing
				  atomicity of sets of operations. The heterogeneous
				  nature of JEAs, however, can obfuscate conceptual
				  errors in the application code, and in particular
				  can hide incorrect declarations of transaction
				  scope. In this paper we present a technique to
				  expose and analyze the application transaction scope
				  in JEAs by merging and analyzing information from
				  multiple sources. We also present several novel
				  visualizations that aid in the analysis of
				  transaction scope by highlighting anomalies in the
				  specification of transactions and violations of
				  architectural constraints. We have validated our
				  approach on two versions of a large commercial case
				  study.},
	Annote = {internationalconference},
	Author = {Fabrizio Perin and Tudor G\^irba and Oscar Nierstrasz},
	Booktitle = {Proceedings of International Conference on Software Maintenance 2010},
	Doi = {10.1109/ICSM.2010.5609572},
	Keywords = {scg-pub scg10 jb11 hasler10 moose-pub girba},
	Location = {Timi\c{s}oara, Romania},
	Medium = {2},
	Month = sep,
	Pages = {1-10},
	Peerreview = {yes},
	Title = {Recovery and Analysis of Transaction Scope from Scattered Information in {Java} Enterprise Applications},
	Url = {http://scg.unibe.ch/archive/papers/Peri10aTransactionRecovery.pdf},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Peri10aTransactionRecovery.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICSM.2010.5609572}}

@inproceedings{Peri10b,
	Abstract = {Reengineering and integrated development plat- forms
				  typically do not list search results in a
				  particularly useful order. PageRank is the algorithm
				  prominently used by the Google internet search
				  engine to rank the relative importance of elements
				  in a set of hyperlinked documents. To determine the
				  relevance of objects, classes, attributes, and
				  methods we propose to apply PageRank to software
				  artifacts and their relationship (reference,
				  inheritance, access, and invocation). This paper
				  presents various experiments that demonstrate the
				  usefulness of the ranking algorithm in software
				  (re)engineering.},
	Annote = {internationalworkshop},
	Author = {Fabrizio Perin and Lukas Renggli and Jorge Ressia},
	Booktitle = {4th Workshop on FAMIX and Moose in Reengineering (FAMOOSr 2010)},
	Keywords = {scg-pub scg10 jb11 snf10 hasler10 moose-pub skip-doi},
	Medium = {1},
	Peerreview = {yes},
	Title = {Ranking Software Artifacts},
	Url = {http://scg.unibe.ch/archive/papers/Peri10bRankingSoftware.pdf},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Peri10bRankingSoftware.pdf}}

@inproceedings{Peri10c,
	Abstract = {Java Enterprise Applications (JEAs) are large
				  systems that integrate multiple technologies and
				  programming languages. With the purpose to support
				  the analysis of JEAs we have developed MooseJEE an
				  extension of the \emph{Moose} environment capable to
				  model the typical elements of JEAs.},
	Annote = {internationalworkshop},
	Author = {Fabrizio Perin},
	Booktitle = {Proceedings of the 26th International Conference on Software Maintenance (ICSM 2010) (Tool Demonstration)},
	Doi = {10.1109/ICSM.2010.5609569},
	Keywords = {scg-pub scg10 jb11 hasler10 moose-pub},
	Location = {Timi\c{s}oara, Romania},
	Medium = {2},
	Month = sep,
	Peerreview = {yes},
	Title = {{MooseJEE}: A {Moose} Extension to Enable the assessment of {JEAs}},
	Url = {http://scg.unibe.ch/archive/papers/Peri10cMooseExtension.pdf},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Peri10cMooseExtension.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICSM.2010.5609569}}

@inproceedings{Peri10d,
	Abstract = {Java Enterprise Applications (JEAs) are complex
				  software systems written using multiple
				  technologies. Moreover they are usually distributed
				  systems and use a database to deal with persistence.
				  A particular problem that appears in the design of
				  these systems is the lack of a rich business model.
				  In this paper we propose a technique to support the
				  recovery of such rich business objects starting from
				  anemic Data Transfer Objects (DTOs). Exposing the
				  code duplications in the application's elements
				  using the DTOs we suggest which business logic can
				  be moved into the DTOs from the other classes.},
	Annote = {internationalworkshop},
	Author = {Fabrizio Perin and Tudor G\^irba},
	Booktitle = {4th Workshop on FAMIX and Moose in Reengineering (FAMOOSr 2010)},
	Keywords = {scg-pub scg10 jb11 hasler10 moose-pub skip-doi girba},
	Location = {Timi\c{s}oara, Romania},
	Medium = {1},
	Month = sep,
	Peerreview = {yes},
	Title = {Evaluating Code Duplication to Identify Rich Business Objects from Data Transfer Objects},
	Url = {http://scg.unibe.ch/archive/papers/Peri10dDTOs.pdf},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Peri10dDTOs.pdf}}

@inproceedings{Peri10e,
	Abstract = {Written text is an important component in the
				  process of knowledge acquisition and communication.
				  Poorly written text fails to deliver clear ideas to
				  the reader no matter how revolutionary and
				  ground-breaking these ideas are. Providing text with
				  good writing style is essential to transfer ideas
				  smoothly. While we have sophisticated tools to check
				  for stylistic problems in program code, we do not
				  apply the same techniques for written text. In this
				  paper we present TextLint, a rule-based tool to
				  check for common style errors in natural language.
				  TextLint provides a structural model of written text
				  and an extensible rule-based checking mechanism.},
	Annote = {internationalworkshop},
	Author = {Fabrizio Perin and Lukas Renggli and Jorge Ressia},
	Booktitle = {Smalltalks 2010},
	Keywords = {scg11 scg-pub jb11 snf11 textlint petitparser skip-doi},
	Location = {Concepcion del Uruguay, Entre Rios, Argentina},
	Medium = {2},
	Peerreview = {yes},
	Title = {Natural Language Checking with Program Checking Tools},
	Url = {http://scg.unibe.ch/archive/papers/Peri10eNaturalLanguageChecking.pdf},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Peri10eNaturalLanguageChecking.pdf}}

@article{Peri11a,
	Abstract = {Written text is an important component in the process of
				  knowledge acquisition and communication. Poorly written
				  text fails to deliver clear ideas to the reader no
				  matter how revolutionary and ground-breaking these ideas
				  are. Providing text with good writing style is essential
				  to transfer ideas smoothly. While we have sophisticated
				  tools to check for stylistic problems in program code,
				  we do not apply the same techniques for written text. In
				  this paper we present TextLint, a rule-based tool to
				  check for common style errors in natural language.
				  TextLint provides a structural model of written text
				  and an extensible rule-based checking mechanism.},
	Annote = {internationaljournal},
	Author = {Fabrizio Perin and Lukas Renggli and Jorge Ressia},
	Doi = {10.1016/j.cl.2011.11.002},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {scg11 scg-pub jb12 snf-none textlint petitparser},
	Medium = {2},
	Peerreview = {yes},
	Publisher = {Elsevier},
	Title = {Linguistic Style Checking with Program Checking Tools},
	Url = {http://scg.unibe.ch/archive/papers/Peri11aNaturalLanguageCheckingWithProgramCheckingTools.pdf},
	Year = {2011},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Peri11aNaturalLanguageCheckingWithProgramCheckingTools.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.cl.2011.11.002}}

@inproceedings{Poni06a,
	Abstract = {Successful software systems cope with complexity by
				  organizing classes into packages. However, a
				  particular organization may be neither
				  straightforward nor obvious for a given developer.
				  As a consequence, classes can be misplaced, leading
				  to duplicated code and ripple effects with minor
				  changes effecting multiple packages. We claim that
				  contextual information is the key to rearchitecture
				  a system. Exploiting contextual information, we
				  propose a technique to detect misplaced classes by
				  analyzing how client packages access the classes of
				  a given provider package. We define locality as a
				  measure of the degree to which classes reused by
				  common clients appear in the same package. We then
				  use locality to guide a simulated annealing
				  algorithm to obtain optimal placements of classes in
				  packages. The result is the identification of
				  classes that are candidates for relocation. We apply
				  the technique to three applications and validate the
				  usefulness of our approach via developer
				  interviews.},
	Annote = {internationalconference},
	Author = {Laura Ponisio and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 3rd Software Measurement European Forum 2006 (SMEF'06)},
	Cvs = {AlchemistSimulatedAnnealingSMEF06},
	Keywords = {scg-none jb06 fb06 scg-pub skip-doi oscarPub recast06},
	Medium = {2},
	Pages = {91--103},
	Peerreview = {yes},
	Title = {Using Context Information to Re-architect a System},
	Url = {http://scg.unibe.ch/archive/papers/Poni06aSimulatedAnnealing.pdf},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Poni06aSimulatedAnnealing.pdf}}

@techreport{Poni06b,
	Abstract = {Complex systems are decomposed into cohesive
				  packages with the goal of limiting the scope of
				  changes: if our packages are cohesive, we hope that
				  changes will be limited to the packages responsible
				  for the features we are changing, or at worst the
				  packages that are immediate clients of those
				  features. But how should we measure cohesion?
				  Traditional cohesion metrics focus on the explicit
				  dependencies and interactions between the classes
				  within the package under study. A package, however,
				  may be conceptually cohesive even though its classes
				  exhibit no explicit dependencies. We propose a group
				  of contextual metrics that assess the cohesion of a
				  package based on the degree to which its classes are
				  used together by common clients. We apply these
				  metrics to various case studies, and contrast the
				  degree of cohesion detected with that of traditional
				  cohesion metrics. In particular, we note that
				  object-oriented frameworks may appear not to be
				  cohesive with traditional metrics, whereas our
				  contextual metrics expose the implicit cohesion that
				  results from the framework's clients.},
	Annote = {report notrefereed},
	Author = {Laura Ponisio and Oscar Nierstrasz},
	Institution = {University of Bern, Institute of Applied Mathematics and Computer Sciences},
	Keywords = {scg-none jb06 fb06 scg-pub skip-doi recast06 moose-pub},
	Number = {IAM-06-002},
	Title = {Using Contextual Information to Assess Package Cohesion},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Poni06bAlchemistPackageCohesion.pdf},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Poni06bAlchemistPackageCohesion.pdf}}

@inproceedings{Rani18a,
 author = {Pooja Rani},
 title = {Software Analysis using Natural Language Queries},
 abstract = {Understanding a software system consumes a substantial portion of a developer's effort. To support software comprehension and evolution, reverse engineering aims at creating a high-level representation of an existing software system. With state- of-the-art technology, abstract models of software systems are created by reverse engineering tools and analyzed using software analysis tools. Despite the rich functionalities offered by analysis tools, a novice user may find them difficult to use due to an unfamiliar tool environment and query language. In this paper, we propose an approach that allows the developer to formulate a query in a natural language in order to overcome these obstacles.},
 booktitle = {Seminar Series on Advanced Techniques \& Tools for Software Evolution (SATToSE)},
 Annote = {internationalworkshop},
 PeerReview = {yes},
 Medium = {1},
 Keywords = {scg-pub skip-doi snf-asa2 scg18 jb18},
 year = {2018},
 Url = {http://scg.unibe.ch/archive/papers/Rani18a.pdf}
}

@inproceedings{Rani21a,
    title={Speculative Analysis for Quality Assessment of Code Comments},
      author={Rani, Pooja},
      booktitle={2021 IEEE/ACM 43rd International Conference on Software Engineering: Companion Proceedings (ICSE-Companion)},
      abstract= {Previous studies have shown that high-quality code comments assist developers in program comprehension and maintenance tasks. However, the semi-structured nature of comments, unclear conventions for writing good comments, and the lack of quality assessment tools for all aspects of comments make their evaluation and maintenance a non-trivial problem. To achieve high-quality comments, we need a deeper understanding of code comment characteristics and the practices developers follow. In this thesis, we approach the problem of assessing comment quality from three different perspectives: what developers ask about commenting practices, what they write in comments, and how researchers support them in assessing comment quality.
	  Our preliminary findings show that developers embed various kinds of information in class comments across programming languages. Still, they face problems in locating relevant guidelines to write consistent and informative comments, verifying the adherence of their comments to the guidelines, and evaluating the overall state of comment quality. To help developers and researchers in building comment quality assessment tools, we provide: (i) an empirically validated taxonomy of comment convention-related questions from various community forums, (ii) an empirically validated taxonomy of comment information types from various programming languages, (iii) a language-independent approach to automatically identify the information types, and (iv) a comment quality taxonomy prepared from a systematic literature review.},
      year={2021},
      eprint={2102.09605},
      archivePrefix={arXiv},
      primaryClass={cs.SE},
      PeerReview = {yes},
      Medium = {2},
  	  pages={299-303},
      doi={10.1109/ICSE-Companion52605.2021.00132},
      Keywords = {comments scg-pub snf-asa3 scg21 jb21},
  	  Url = {http://scg.unibe.ch/archive/papers/Rani21a.pdf}
}

@article{Rani21b,
  title={What do class comments tell us? {An} investigation of comment evolution and practices in {Pharo} {Smalltalk}},
  author={Rani, Pooja and Panichella, Sebastiano and Leuenberger, Manuel and Ghafari, Mohammad and Nierstrasz, Oscar},
  abstract = {Previous studies have characterized code comments in various programming languages, showing how high quality of code comments is crucial to support program comprehension activities, and to improve the effectiveness of maintenance tasks. However, very few studies have focused on understanding developer practices to write comments. None of them has compared such developer practices to the standard comment guidelines to study the extent to which developers follow the guidelines. This paper reports the first empirical study investigating commenting practices in Pharo Smalltalk. First, we analyze class comment evolution over seven Pharo versions. Then, we quantitatively and qualitatively investigate the information types embedded in class comments. Finally, we study the adherence of developer commenting practices to the official class comment template over Pharo versions. The results of this study show that there is a rapid increase in class comments in the initial three Pharo versions, while in subsequent versions developers added comments to both new and old classes, thus maintaining a similar code to comment ratio. We furthermore found three times as many information types in class comments as those suggested by the template. However, the information types suggested by the template tend to be present more often than other types of information. Additionally, we find that a substantial proportion of comments follow the writing style of the template in writing these information types, but they are written and formatted in a non-uniform way. This suggests the need to standardize the commenting guidelines for formatting the text, and to provide headers for the different information types to ensure a consistent style and to identify the information easily. Given the importance of high-quality code comments, we draw numerous implications for developers and researchers to improve the support for comment quality assessment tools.},
  journal={Empirical Software Engineering},
  Annote = {internationaljournal},
  volume={26},
  number={6},
  pages={1--49},
  year={2021},
  doi = {10.1007/s10664-021-09981-5},
  publisher={Springer},
  eprint={2005.11583},
  archivePrefix={arXiv},
  primaryClass={cs.SE},
  PeerReview = {yes},
  Medium = {2},
  keywords = {comments scg-pub scg21 jb21 snf-asa3 pharo},
  Url = {http://scg.unibe.ch/archive/papers/Rani21b.pdf}
}

@inproceedings{Rani21c,
  author={Birrer, Mathias and Rani, Pooja and Panichella, Sebastiano and Nierstrasz, Oscar},
  booktitle={2021 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)},
  title={Makar: {A} Framework for Multi-source Studies based on Unstructured Data},
  abstract = {To perform various development and maintenance tasks, developers frequently seek information on various sources such as mailing lists, Stack Overflow (SO), and Quora. Researchers analyze these sources to understand developer information needs in these tasks. However, extracting and preprocessing unstructured data from various sources, building and maintaining a reusable dataset is often a time-consuming and iterative process. Additionally, the lack of tools for automating this data analysis process complicates the task to reproduce previous results or datasets.To address these concerns we propose Makar, which provides various data extraction and preprocessing methods to support researchers in conducting reproducible multi-source studies. To evaluate Makar, we conduct a case study that analyzes code comment related discussions from SO, Quora, and mailing lists. Our results show that Makar is helpful for preparing reproducible datasets from multiple sources with little effort, and for identifying the relevant data to answer specific research questions in a shorter time compared to state-of-the-art tools, which is of critical importance for studies based on unstructured data. Tool webpage: https://github.com/maethub/makar},
  year={2021},
  PeerReview = {yes},
  Medium = {1},
  pages={577-581},
  doi={10.1109/SANER50967.2021.00069},
  Keywords = {scg-pub snf-asa3 scg21 jb21},
  Url = {http://scg.unibe.ch/archive/papers/Rani21c.pdf}
 }

@article{Rani21d,
  title={How to Identify Class Comment Types? {A} Multi-language Approach for Class Comment Classification},
 	journal = {Journal of Systems and Software},
    Annote = {internationaljournal},
	volume = {181},
	pages = {111047},
	year = {2021},
	issn = {0164-1212},
	doi = {https://doi.org/10.1016/j.jss.2021.111047},
	PeerReview = {yes},
	Medium = {1},
	author = {Pooja Rani and Sebastiano Panichella and Manuel Leuenberger and Andrea {Di Sorbo} and Oscar Nierstrasz},
	abstract = {Most software maintenance and evolution tasks require developers to understand the source code of their software systems. Software developers usually inspect class comments to gain knowledge about program behavior, regardless of the programming language they are using. Unfortunately, (i) different programming languages present language-specific code commenting notations and guidelines; and (ii) the source code of software projects often lacks comments that adequately describe the class behavior, which complicates program comprehension and evolution activities. To handle these challenges, this paper investigates the different language-specific class commenting practices of three programming languages: Python, Java, and Smalltalk. In particular, we systematically analyze the similarities and differences of the information types found in class comments of projects developed in these languages. We propose an approach that leverages two techniques -namely Natural Language Processing and Text Analysis -to automatically identify class comment types, i.e., the specific types of semantic information found in class comments. To the best of our knowledge, no previous work has provided a comprehensive taxonomy of class comment types for these three programming languages with the help of a common automated approach. Our results confirm that our approach can classify frequent class comment information types with high accuracy for the Python, Java, and Smalltalk programming languages. We believe this work can help in monitoring and assessing the quality and evolution of code comments in different programming languages, and thus support maintenance and evolution tasks.},
	eprint={2107.04521},
	archivePrefix={arXiv},
	primaryClass={cs.SE},
	keywords = {comments scg-pub scg21 jb21 snf-asa3 pharo, Natural language processing technique, Code comment analysis, Software documentation},
	Url = {http://scg.unibe.ch/archive/papers/Rani21d.pdf}
}

@inproceedings{Rani21e,
	title={What Do Developers Discuss about Code Comments?},
 	booktitle = {2021 IEEE 21st International Working Conference on Source Code Analysis and Manipulation (SCAM)},
 	abstract = {Code comments are important for program comprehension, development, and maintenance tasks. Given the varying standards for code comments, and their unstructured or semi-structured nature, developers get easily confused (especially novice developers) about which convention(s) to follow, or what tools to use while writing code documentation. Thus, they post related questions on external online sources to seek better commenting practices. In this paper, we analyze code comment discussions on online sources such as Stack Overflow (SO) and Quora to shed some light on the questions developers ask about commenting practices. We apply Latent Dirichlet Allocation (LDA) to identify emerging topics concerning code comments. Then we manually analyze a statistically significant sample set of posts to derive a taxonomy that provides an overview of the developer questions about commenting practices. Our results highlight that on SO nearly 40% of the questions mention how to write or process comments in documentation tools and environments, and nearly 20% of the questions are about potential limitations and possibilities of documentation tools to add automatically and consistently more information in comments. On the other hand, on Quora, developer questions focus more on background information (35% of the questions) or asking opinions (16% of the questions) about code comments. We found that (i) not all aspects of comments are covered in coding style guidelines, e.g., how to add a specific type of information, (ii) developers need support in learning the syntax and format conventions to add various types of information in comments, and (iii) developers are interested in various automated strategies for comments such as detection of bad comments, or verify comment style automatically, but lack tool support to do that.},
	year = {2021},
	PeerReview = {yes},
	Medium = {1},
	eprint={2108.07648},
	archivePrefix={arXiv},
	primaryClass={cs.SE},
	author = {Pooja Rani and Mathias Birrer and Sebastiano Panichella and Mohammad Ghafari and Oscar Nierstrasz},
	keywords = {comments snf-asa3 jb22 scg21 scg-pub},
  doi = {10.1109/SCAM52516.2021.00027},
	Url = {http://scg.unibe.ch/archive/papers/Rani21e.pdf}
}

@inproceedings{Rani21f,
	title={Do Comments follow Commenting Conventions? {A} Case Study in {Java} and {Python}},
 	booktitle = {2021 IEEE 21st International Working Conference on Source Code Analysis and Manipulation (SCAM)},
 	abstract = {Assessing code comment quality is known to be a difficult problem. A number of coding style guidelines have been created with the aim to encourage writing of informative, readable, and consistent comments. However, it is not clear from the research to date which specific aspects of comments the guidelines cover (e.g., syntax, content, structure). Furthermore, the extent to which developers follow these guidelines while writing code comments is unknown.
 	We analyze various style guidelines in Java and Python and uncover that the majority of them address more the content aspect of the comments rather than syntax or formatting, but when considering the different types of information developers embed in comments and the concerns they raise on various online platforms about the commenting practices, existing comment conventions are not yet specified clearly enough, nor do they adequately cover important concerns. Our results highlight the mismatch between developer commenting practices and style guidelines, and provide several focal points for the design and improvement of comment quality checking tools.},
	year = {2021},
	PeerReview = {yes},
	Medium = {1},
	eprint={2108.10766},
	archivePrefix={arXiv},
	primaryClass={cs.SE},
	author = {Pooja Rani and Suada Abukar and Nataliia Stulova and Alexander Bergel and Oscar Nierstrasz},
	keywords = {comments snf-asa3 jb22 scg21 scg-pub},
  doi = {10.1109/SCAM52516.2021.00028},
	Url = {http://scg.unibe.ch/archive/papers/Rani21f.pdf}
}

@inproceedings{Rani22b,
	Abstract = {Code comments support developers in
    understanding and maintaining codebases. Specifically in the Pharo
    environment, code comments serve as the main form of code documentation
    and usually convey information ranging from high-level design
    descriptions to low-level implementation details. Nevertheless, numerous
    important classes in Pharo still lack comments as developers find writing
    comments to be a tedious and effort-intensive task. Previous works in
    Java have recommended generating comments {automatically} to reduce
    commenting effort and save developers time. There exist several
    approaches to achieve this goal. One such popular approach is based on
    identifying stereotypes, \ie a generalized set of characteristics
    supposed to represent an entity (object, class). However, this approach
    has not been tested for other programming languages. In this paper, we
    adopt the stereotype-based approach to automatically generate class
    comments in the Pharo programming environment. Specifically, we generated
    information about the class type, collaborators and key methods. We
    surveyed seven developers to evaluate the generated comments for 24
    classes. The responses suggest that, although more information could be
    added to the comments, the generated class comments are readable and
    understandable, and the majority of comments do not contain unnecessary
    information.},
	Annote = {internationalworkshop},
	Author = {Pooja Rani and Alexandre Bergel and Lino Hess and Timo Kehrer and Oscar Nierstrasz},
	Booktitle = {IWST'22: Proceedings of International Workshop on Smalltalk Technologies},
	Keywords = {scg22 scg-pub jb22 snf-asa3 MISSING-DOI},
	Peerreview = {yes},
	Title = {Can We Automatically Generate Class Comments in {Pharo}?},
	location = {Novi Sad, Serbia},
	Url = {http://scg.unibe.ch/archive/papers/Rani22b.pdf},
	pdf = {https://ceur-ws.org/Vol-3325/regular4.pdf},
	Year = {2022},
	Medium = {4}
}

@article{Rani22c,
  title={A decade of code comment quality assessment: A systematic literature review},
  journal = {Journal of Systems and Software},
  Annote = {internationaljournal},
  volume = {195},
  pages = {111515},
  year = {2022},
  issn = {0164-1212},
  doi = {https://doi.org/10.1016/j.jss.2022.111515},
  PeerReview = {yes},
  Medium = {1},
  author = {Pooja Rani and Arianna Blasi and Nataliia Stulova and Sebastiano Panichella and Alessandra Gorla and Oscar Nierstrasz},
  abstract = {Code comments are important artifacts in software systems
  and play a paramount role in many software engineering (SE) tasks related to maintenance and program
  comprehension. However, while it is widely accepted that high quality matters in code comments just
  as it matters in source code, assessing comment quality in practice is still an open problem. First
  and foremost, there is no unique definition of quality when it comes to evaluating code comments.
  The few existing studies on this topic rather focus on specific attributes of quality that can be
  easily quantified and measured. Existing techniques and corresponding tools may also focus on
  comments bound to a specific programming language, and may only deal with comments with specific
  scopes and clear goals (e.g., Javadoc comments at the method level, or in-body comments describing
  TODOs to be addressed). In this paper, we present a Systematic Literature Review (SLR) of the last
  decade of research in SE to answer the following research questions: (i) What types of comments do
  researchers focus on when assessing comment quality? (ii) What quality attributes (QAs) do they
  consider? (iii) Which tools and techniques do they use to assess comment quality?, and (iv) How do
  they evaluate their studies on comment quality assessment in general? Our evaluation, based on the
  analysis of 2353 papers and the actual review of 47 relevant ones, shows that (i) most studies and
  techniques focus on comments in Java code, thus may not be generalizable to other languages, and
  (ii) the analyzed studies focus on four main QAs of a total of 21 QAs identified in the literature,
  with a clear predominance of checking consistency between comments and the code. We observe that
  researchers rely on manual assessment and specific heuristics rather than the automated assessment
  of the comment quality attributes, with evaluations often involving surveys of students and the
  authors of the original studies but rarely professional developers.},
  keywords = {comments scg-pub scg22 jb22 snf-asa3 pharo, Natural language processing technique, Code comment analysis, Software documentation},
  Url = {http://scg.unibe.ch/archive/papers/Rani22c.pdf}
}

@inproceedings{Rapi98a,
	Abstract = {Type information is a crucial information to support
				  object-oriented reengineering. In a dynamically
				  typed language like Smalltalk standard static type
				  inference is a complex and heavily computational
				  task. In this paper, we report how we use message
				  passing control and compiler extension to support
				  dynamic inference type in Smalltalk.},
	Annote = {internationalworkshop},
	Author = {Pascal Rapicault and Mireille Blay-Fornarino and St\'ephane Ducasse and Anne-Marie Dery},
	Keywords = {scg-pub skip-doi olit famoos-papunr oobib snf98 scg-none jb98 stefPub},
	Booktitle = {Proceedings of the ECOOP '98 International Workshop Experiences in Object-Oriented Reengineering, abstract in Object-Oriented Technology (ECOOP '98 Workshop Reader forthcoming LNCS)},
	Pages = {76--77},
	Title = {Dynamic Type Inference to Support Object-Oriented Reengineering in {Smalltalk}},
	Url = {http://scg.unibe.ch/archive/famoos/Rapi98a/type.pdf},
	Year = {1998},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/famoos/Rapi98a/type.pdf}}

@inproceedings{Rati04a,
	Abstract = {As systems evolve and their structure decays,
				  maintainers need accurate and automatic
				  identification of the design problems. Current
				  approaches for automatic detection of design
				  problems are not accurate enough because they
				  analyze only a single version of a system and
				  consequently they miss essential information as
				  design problems appear and evolve over time. Our
				  approach is to use the historical information of the
				  suspected flawed structure to increase the accuracy
				  of the automatic problem detection. Our means is to
				  define measurements which summarize how persistent
				  the problem was and how much maintenance effort was
				  spent on the suspected structure. We apply our
				  approach on a large scale case study and show how it
				  improves the accuracy of the detection of God
				  Classes and Data Classes, and additionally how it
				  adds valuable semantical information about the
				  evolution of flawed design structures.},
	Acceptnum = {33},
	Accepttotal = {62},
	Address = {Los Alamitos CA},
	Annote = {internationalconference},
	Author = {Daniel Ra\c{t}iu and St\'ephane Ducasse and Tudor G\^irba and Radu Marinescu},
	Booktitle = {Proceedings of 8th European Conference on Software Maintenance and Reengineering (CSMR'04)},
	Keywords = {recast04 scg-pub skip-doi stefPub scg-none jb04 moose-pub girba ratiu evolution},
	Misc = {acceptance rate: 33/62 = 52\%},
	Pages = {223--232},
	Publisher = {IEEE Computer Society},
	Title = {Using History Information to Improve Design Flaws Detection},
	Url = {http://scg.unibe.ch/archive/papers/Rati04aHistoryImproveFlawsDetection.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Rati04aHistoryImproveFlawsDetection.pdf}}

@techreport{Reic05a,
	Abstract = {Traits are a well-known simple, but powerful
				  compositional model for reuse. Although traits
				  already implemented in dynamically typed languages,
				  they're not yet practically realized in statically
				  typed languages. Typing traits and adapting the
				  model to these languages is more complex to achieve.
				  We report on our experience and practical research
				  implementing traits in {C\#} 2.0, concerning
				  generics. We show the difficulties and possible
				  solutions of typing and parameterizing traits in
				  generally, possible enhancements for statically
				  typed languages as well as adapting traits to {C\#}
				  regarding features like overriding and hiding.},
	Author = {Stefan Reichhart},
	Institution = {University of Bern},
	Keywords = {scg-ip scg-none jb06 snf06 scg-pub skip-doi scg-rotor traits {C\#}},
	Title = {A Prototype of {Traits} for {C\#}},
	Type = {Informatikprojekt},
	Url = {http://scg.unibe.ch/archive/projects/Reic05a.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/projects/Reic05a.pdf}}

@inproceedings{Reic07a,
	Abstract = {With the success of agile methodologies more and
				  more projects develop large test suites to ensure
				  that the system is behaving as expected. Not only do
				  tests ensure correctness, but they also offer a live
				  documentation for the code. However, as the system
				  evolves, the tests need to evolve as well to keep up
				  with the system, and as the test suite grows larger,
				  the effort invested into maintaining tests is a
				  significant activity. In this context, the quality
				  of tests becomes an important issue, as developers
				  need to assess and understand the tests they have to
				  maintain. In this paper we present TestLint, an
				  approach together with an experimental tool for
				  qualifying tests. We define a set of criteria to
				  determine test quality, and we evaluate our approach
				  on a large sample of unit tests found in open-source
				  projects.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Stefan Reichhart and Tudor G\^irba and St\'ephane Ducasse},
	Booktitle = {Journal of Object Technology, Special Issue. Proceedings of TOOLS Europe 2007},
	Cached = {http://scg.unibe.ch/archive/papers/Reic07aTestQualityAssessment.pdf},
	Doi = {10.5381/jot.2007.6.9.a12},
	Inria = {hors},
	Issn = {1660-1769},
	Keywords = {scg07 scg-pub jb08 snf07 skip-doi testlint test smell refactoring girba},
	Medium = {2},
	Month = oct,
	Note = {Special Issue. Proceedings of TOOLS Europe 2007},
	Pages = {231--251},
	Peerreview = {yes},
	Selectif = {non},
	Title = {Rule-based Assessment of Test Quality},
	Url = {http://www.jot.fm/contents/issue_2007_10/paper12.html http://www.jot.fm/issues/issue_2007_10/paper12.pdf},
	Volume = {6/9},
	Year = {2007},
	Bdsk-Url-1 = {http://www.jot.fm/issues/issue_2007_10/paper12/%20http://www.jot.fm/issues/issue_2007_10/paper12.pdf}}

@inproceedings{Reng07a,
	Abstract = {Model-driven engineering is a powerful approach to
				  build large-scale applications. However, an
				  application's metamodel often remains static after
				  the development phase and cannot be changed unless a
				  new development effort occurs. Yet, end users often
				  need to rapidly adapt their applications to new
				  business needs. In many cases, the end users would
				  know how to make the required adaptations, if only,
				  the application would let them do so. In this paper
				  we present how we built a runtime-dynamic
				  meta-environment by integrating Magritte, a
				  self-described metamodel, into Smalltalk's
				  reflective language model. Our solution offers the
				  best of both worlds: developers can develop their
				  applications using the same tools they were used to,
				  but at the same time they gain the power of
				  meta-programming. We show in particular that our
				  approach is adapted to support end user
				  customization of applications: the adaptive model of
				  Magritte enables to not only describe existing
				  classes, but also lets end users build their own
				  metamodels on the fly.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Lukas Renggli and St\'ephane Ducasse and Adrian Kuhn},
	Booktitle = {Model Driven Engineering Languages and Systems},
	Doi = {10.1007/978-3-540-75209-7_8},
	Editor = {Gregor Engels and Bill Opdyke and Douglas C. Schmidt and Frank Weil},
	Inria = {hors},
	Isbn = {978-3-540-75208-0},
	Keywords = {scg07 scg-pub jb07 snf07 snf-bmcc akuhn fame},
	Medium = {2},
	Month = sep,
	Pages = {106--120},
	Peerreview = {yes},
	Publisher = {Springer},
	Ratex = {32%},
	Series = {LNCS},
	Title = {Magritte --- A Meta-Driven Approach to Empower Developers and End Users},
	Url = {http://scg.unibe.ch/archive/papers/Reng07aMagritte.pdf},
	Volume = {4735},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Reng07aMagritte.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-540-75209-7_8}}

@inproceedings{Reng07b,
	Abstract = {Concurrency control in Smalltalk is based on locks
				  and is therefore notoriously difficult to use. Even
				  though some implementations provide high-level
				  constructs, these add complexity and potentially
				  hard-to-detect bugs to the application.
				  Transactional memory is an attractive mechanism that
				  does not have the drawbacks of locks, however the
				  underlying implementation is often difficult to
				  integrate into an existing language. In this paper
				  we show how we have introduced transactional
				  semantics in Smalltalk by using the reflective
				  facilities of the language. Our approach is based on
				  method annotations, incremental parse tree
				  transformations and an optimistic commit protocol.
				  We report on a practical case study, benchmarks and
				  further and on-going work.},
	Annote = {internationalconference},
	Author = {Lukas Renggli and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 2007 International Conference on Dynamic Languages (ICDL 2007)},
	Doi = {10.1145/1352678.1352692},
	Isbn = {978-1-60558-084-5},
	Keywords = {scg07 scg-pub jb08 snf08 reflectivity},
	Medium = {2},
	Pages = {207--221},
	Peerreview = {yes},
	Publisher = {ACM Digital Library},
	Title = {Transactional Memory for {Smalltalk}},
	Url = {http://scg.unibe.ch/archive/papers/Reng07bTransMem.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Reng07bTransMem.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1352678.1352692}}

@article{Reng09a,
	Abstract = {Concurrency control is mostly based on locks and is
				  therefore notoriously difficult to use. Even though
				  some programming languages provide high-level
				  constructs, these add complexity and potentially
				  hard-to-detect bugs to the application.
				  Transactional memory is an attractive mechanism that
				  does not have the drawbacks of locks, however the
				  underlying implementation is often difficult to
				  integrate into an existing language. In this paper
				  we show how we have introduced transactional
				  semantics into Smalltalk by using the reflective
				  facilities of the language. Our approach is based on
				  method annotations, incremental parse tree
				  transformations and an optimistic commit protocol.
				  The implementation does not depend on modifications
				  to the virtual machine and therefore can be changed
				  at the language level. We report on a practical case
				  study, benchmarks and further and on-going work.},
	Annote = {internationaljournal},
	Author = {Lukas Renggli and Oscar Nierstrasz},
	Doi = {10.1016/j.cl.2008.06.001},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {scg09 scg-pub jb09 snf09},
	Medium = {2},
	Misc = {was: Reng08a},
	Month = apr,
	Number = {1},
	Pages = {21--30},
	Peerreview = {yes},
	Publisher = {Elsevier},
	Title = {Transactional Memory in a Dynamic Language},
	Url = {http://scg.unibe.ch/archive/papers/Reng08aTransMemory.pdf},
	Volume = {35},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Reng08aTransMemory.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.cl.2008.06.001}}

@inproceedings{Reng09b,
	Abstract = {Integration of multiple languages into each other
				  and into an existing development environment is a
				  difficult task. As a consequence, developers often
				  end up using only internal DSLs that strictly rely
				  on the constraints imposed by the host language.
				  Infrastructures do exist to mix languages, but they
				  often do it at the price of losing the development
				  tools of the host language. Instead of inventing a
				  completely new infrastructure, our solution is to
				  integrate new languages deeply into the existing
				  host environment and reuse the infrastructure
				  offered by it. In this paper we show why Smalltalk
				  is the best practical choice for such a host
				  language.},
	Address = {New York, NY, USA},
	Annote = {internationalworkshop},
	Author = {Lukas Renggli and Tudor G\^irba},
	Booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2009)},
	Doi = {10.1145/1735935.1735954},
	Isbn = {978-1-60558-899-5},
	Keywords = {scg10 scg-pub jb10 snf10 helvetia girba},
	Location = {Brest, France},
	Medium = {2},
	Pages = {107--113},
	Peerreview = {yes},
	Publisher = {ACM},
	Title = {Why {Smalltalk} Wins the Host Languages Shootout},
	Url = {http://scg.unibe.ch/archive/papers/Reng09bLanguageShootout.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Reng09bLanguageShootout.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1735935.1735954}}

@inproceedings{Reng09c,
	Abstract = {As domain-specific modeling begins to attract
				  widespread acceptance, pressure is increasing for
				  the development of new domain-specific languages.
				  Unfortunately these DSLs typically conflict with the
				  grammar of the host language, making it difficult to
				  compose hybrid code except at the level of strings;
				  few mechanisms (if any) exist to control the scope
				  of usage of multiple DSLs; and, most seriously,
				  existing host language tools are typically unaware
				  of the DSL extensions, thus hampering the
				  development process. Language Boxes address these
				  issues by offering a simple, modular mechanism to
				  encapsulate (i) compositional changes to the host
				  language, (ii) transformations to address various
				  concerns such as compilation and highlighting, and
				  (iii) scoping rules to control visibility of
				  language extensions. We describe the design and
				  implementation of Language Boxes, and show with the
				  help of several examples how modular extensions can
				  be introduced to a host language and environment.},
	Annote = {internationalconference},
	Author = {Lukas Renggli and Marcus Denker and Oscar Nierstrasz},
	Booktitle = {Software Language Engineering: Second International Conference, SLE 2009, Denver, Colorado, October 5-6, 2009},
	Doi = {10.1007/978-3-642-12107-4_20},
	Isbn = {978-3-642-12106-7},
	Keywords = {scg09 scg-pub snf10 jb10 helvetia},
	Medium = {2},
	Pages = {274--293},
	Peerreview = {yes},
	Publisher = {Springer},
	Ratex = {29%},
	Series = {LNCS},
	Title = {{Language} {Boxes}: Bending the Host Language with Modular Language Changes},
	Url = {http://scg.unibe.ch/archive/papers/Reng09cLanguageBoxes.pdf},
	Volume = {5969},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Reng09cLanguageBoxes.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-642-12107-4_20}}

@inproceedings{Reng10a,
	Abstract = {Domain-specific languages (DSLs) are increasingly
				  used as embedded languages within general-purpose
				  host languages. DSLs provide a compact, dedicated
				  syntax for specifying parts of an application
				  related to specialized domains. Unfortunately, such
				  language extensions typically do not integrate well
				  with the development tools of the host language.
				  Editors, compilers and debuggers are either unaware
				  of the extensions, or must be adapted at a
				  non-trivial cost. We present a novel approach to
				  embed DSLs into an existing host language by
				  leveraging the underlying representation of the host
				  language used by these tools. Helvetia is an
				  extensible system that intercepts the compilation
				  pipeline of the Smalltalk host language to
				  seamlessly integrate language extensions. We
				  validate our approach by case studies that
				  demonstrate three fundamentally different ways to
				  extend or adapt the host language syntax and
				  semantics.},
	Address = {Maribor, Slovenia},
	Annote = {internationalconference},
	Author = {Lukas Renggli and Tudor G\^irba and Oscar Nierstrasz},
	Booktitle = {ECOOP'10: Proceedings of the 24th European Conference on Object-Oriented Programming},
	Doi = {10.1007/978-3-642-14107-2_19},
	Editor = {Theo D'Hondt},
	Isbn = {978-3-642-14106-5},
	Keywords = {scg-pub scg10 helvetia girba snf10 jb10 damiencbib},
	Medium = {2},
	Pages = {380--404},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Ratex = {23%},
	Series = {LNCS},
	Title = {Embedding Languages Without Breaking Tools},
	Url = {http://scg.unibe.ch/archive/papers/Reng10aEmbeddingLanguages.pdf},
	Volume = {6183},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Reng10aEmbeddingLanguages.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-642-14107-2_19}}

@inproceedings{Reng10b,
	Abstract = {Lint-like program checkers are popular tools that
				  ensure code quality by verifying compliance with
				  best practices for a particular programming
				  language. The proliferation of internal
				  domain-specific languages and models, however, poses
				  new challenges for such tools. Traditional program
				  checkers produce many false positives and fail to
				  accurately check constraints, best practices, common
				  errors, possible optimizations and portability
				  issues particular to domain-specific languages. We
				  advocate the use of dedicated rules to check
				  domain-specific practices. We demonstrate the
				  implementation of domain-specific rules, the
				  automatic fixing of violations, and their
				  application to two case-studies: (1) Seaside defines
				  several internal DSLs through a creative use of the
				  syntax of the host language; and (2) Magritte adds
				  meta-descriptions to existing code by means of
				  special methods. Our empirical validation
				  demonstrates that domain-specific program checking
				  significantly improves code quality when compared
				  with general purpose program checking.},
	Annote = {internationalconference},
	Author = {Lukas Renggli and St\'ephane Ducasse and Tudor G\^irba and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 48th International Conference on Objects, Models, Components and Patterns (TOOLS'10)},
	Doi = {10.1007/978-3-642-13953-6_12},
	Editor = {Jan Vitek},
	Isnb = {978-3-642-13952-9},
	Keywords = {scg-pub scg10 helvetia girba snf10 jb10 evol11},
	Pages = {213--232},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Ratex = {29%},
	Series = {LNCS},
	Title = {Domain-Specific Program Checking},
	Url = {http://scg.unibe.ch/archive/papers/Reng10bDomainSpecificProgramChecking.pdf},
	Volume = {6141},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Reng10bDomainSpecificProgramChecking.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-642-13953-6_12}}

@inproceedings{Reng10c,
	Abstract = {Grammars for programming languages are traditionally
				  specified statically. They are hard to compose and
				  reuse due to ambiguities that inevitably arise.
				  PetitParser combines ideas from scannerless parsing,
				  parser combinators, parsing expression grammars and
				  packrat parsers to model grammars and parsers as
				  objects that can be reconfigured dynamically.
				  Through examples and benchmarks we demonstrate that
				  dynamic grammars are not only flexible but highly
				  practical.},
	Address = {Malaga, Spain},
	Annote = {internationalworkshop},
	Author = {Lukas Renggli and St\'ephane Ducasse and Tudor G\^irba and Oscar Nierstrasz},
	Booktitle = {4th Workshop on Dynamic Languages and Applications (DYLA 2010)},
	Keywords = {scg-pub scg10 helvetia petitparser girba skip-doi moose-pub snf10 jb10 hasler10 evol11},
	Medium = {1},
	Month = jun,
	Peerreview = {yes},
	Title = {Practical Dynamic Grammars for Dynamic Languages},
	Pages = {1--4},
	Url = {http://scg.unibe.ch/archive/papers/Reng10cDynamicGrammars.pdf},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Reng10cDynamicGrammars.pdf}}

@inproceedings{Ress09a,
	Abstract = {In conventional software applications,
				  synchronization code is typically interspersed with
				  functional code, thereby impacting understandability
				  and maintainability of the code base. At the same
				  time, the synchronization defined statically in the
				  code is not capable of adapting to different runtime
				  situations. We propose a new approach to concurrency
				  control which strictly separates the functional code
				  from the synchronization requirements to be used and
				  which adapts objects to be synchronized dynamically
				  to their environment. First-class synchronization
				  specifications express safety requirements, and a
				  dynamic synchronization system dynamically adapts
				  objects to different runtime situations. We present
				  an overview of a prototype of our approach together
				  with several classical concurrency problems, and we
				  discuss open issues for further research.},
	Address = {New York, NY, USA},
	Annote = {internationalworkshop},
	Author = {Jorge Ressia and Oscar Nierstrasz},
	Booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2009)},
	Doi = {10.1145/1735935.1735952},
	Isbn = {978-1-60558-899-5},
	Keywords = {scg10 scg-pub jb10 snf10},
	Location = {Brest, France},
	Medium = {2},
	Pages = {101--106},
	Peerreview = {yes},
	Publisher = {ACM},
	Title = {Dynamic Synchronization --- A Synchronization Model through Behavioral Reflection},
	Url = {http://scg.unibe.ch/archive/papers/Ress09aDynamicSynchronization.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Ress09aDynamicSynchronization.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1735935.1735952}}

@inproceedings{Ress10a,
	Abstract = {Software must be constantly adapted due to evolving
				  domain knowledge and unanticipated requirements
				  changes. To adapt a system at run-time we need to
				  reflect on its structure and its behavior.
				  Object-oriented languages introduced reflection to
				  deal with this issue, however, no reflective
				  approach up to now has tried to provide a unified
				  solution to both structural and behavioral
				  reflection. This paper describes Albedo, a unified
				  approach to structural and behavioral reflection.
				  Albedo is a model of fined-grained unanticipated
				  dynamic structural and behavioral adaptation.
				  Instead of providing reflective capabilities as an
				  external mechanism we integrate them deeply in the
				  environment. We show how explicit meta-objects allow
				  us to provide a range of reflective features and
				  thereby evolve both application models and
				  environments at run-time.},
	Annote = {internationalworkshop},
	Author = {Jorge Ressia and Lukas Renggli and Tudor G\^irba and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 5th Workshop on Models@run.time at the ACM/IEEE 13th International Conference on Model Driven Engineering Languages and Systems (MODELS 2010)},
	Keywords = {snf10 jb11 scg-pub skip-doi girba scg10 bifrost},
	Medium = {2},
	Month = oct,
	Note = {http://sunsite.informatik.rwth-aachen.de/Publications/CEUR-WS/Vol-641/},
	Pages = {37--48},
	Peerreview = {yes},
	Title = {Run-Time Evolution through Explicit Meta-Objects},
	Url = {http://scg.unibe.ch/archive/papers/Ress10a-RuntimeEvolution.pdf},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Ress10a-RuntimeEvolution.pdf}}

@inproceedings{Ress11a,
	Abstract = {Reuse in object-oriented languages typically focuses on inheritance.
				  Numerous techniques have been developed to provide finer-grained reuse
				  of methods, such as flavors, mixins and traits. These techniques,
				  however, only deal with reuse at the level of classes. Class-based
				  reuse is inherently static. Increasing use of reflection and
				  meta-programming techniques in real world applications underline the
				  need for more dynamic approaches. New approaches have shifted to
				  object-specific reuse. However, these techniques fail to provide a
				  complete solution to the composition issues arising during reuse.
				  We propose a new approach that deals with reuse at the object level
				  and that supports behavioral composition. We introduce a new
				  abstraction called a talent which models features that are shared
				  between objects of different class hierarchies. Talents provide
				  a composition mechanism that is as flexible as that of traits but
				  which is dynamic.},
	Annote = {internationalworkshop},
	Author = {Jorge Ressia and Tudor G\^irba and Oscar Nierstrasz and Fabrizio Perin and Lukas Renggli},
	Booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2011)},
	Doi = {10.1145/2166929.2166940},
	Keywords = {scg11 scg-pub jb11 snf11 bifrost talents girba},
	Medium = {2},
	Pages = {109--118},
	Peerreview = {yes},
	Title = {Talents: Dynamically Composable Units of Reuse},
	Url = {http://scg.unibe.ch/archive/papers/Ress11a-Talents.pdf},
	Year = {2011},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Ress11a-Talents.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/2166929.2166940}}

@inproceedings{Ress12a,
	Abstract = {During the process of developing and maintaining a complex
				  software system, developers pose detailed questions about the
				  runtime behavior of the system. Source code views offer strictly
				  limited insights, so developers often turn to tools like debuggers
				  to inspect and interact with the running system. Unfortunately,
				  traditional debuggers focus on the runtime stack as the key
				  abstraction to support debugging operations, though the questions
				  developers pose often have more to do with objects and their
				  interactions.
				  We propose object-centric debugging as an alternative approach
				  to interacting with a running software system. We show how, by
				  focusing on objects as the key abstraction, natural debugging
				  operations can be defined to answer developer questions related
				  to runtime behavior. We present a running prototype of an
				  object-centric debugger, and demonstrate, with the help of a series
				  of examples, how object-centric debugging offers more effective
				  support for many typical developer tasks than a traditional
				  stack-oriented debugger.},
	Annote = {internationalconference},
	Author = {Ressia, Jorge and Bergel, Alexandre and Nierstrasz, Oscar},
	Booktitle = {Proceedings of the 34rd international conference on Software engineering},
	Doi = {10.1109/ICSE.2012.6227167},
	Keywords = {scg12 scg-pub jb12 snf12 reflection bifrost ocdebugging},
	Location = {Zurich, Switzerland},
	Medium = {2},
	Peerreview = {yes},
	Series = {ICSE '12},
	Title = {Object-Centric Debugging},
	Url = {http://scg.unibe.ch/archive/papers/Ress12a-ObjectCentricDebugging.pdf},
	Year = {2012},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Ress12a-ObjectCentricDebugging.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICSE.2012.6227167}}

@article{Ress12b,
	Abstract = {Domain-specific languages and models are increasingly used within
				  general-purpose host languages. While traditional profiling tools
				  perform well on host language code itself, they often fail to provide
				  meaningful results if the developers start to build and use abstractions
				  on top of the host language. In this paper we motivate the need for
				  dedicated profiling tools with three different case studies. Furthermore,
				  we present an infrastructure that enables developers to quickly prototype
				  new profilers for their domain-specific languages and models.},
	Annote = {internationaljournal},
	Author = {Jorge Ressia and Alexandre Bergel and Oscar Nierstrasz and Lukas Renggli},
	Doi = {10.5381/jot.2012.11.1.a5},
	Issn = {1660-1769},
	Journal = {Journal of Object Technology},
	Keywords = {scg12 scg-pub jb12 snf12 reflection bifrost metaspy},
	Medium = {2},
	Month = apr,
	Number = {1},
	Pages = {1-21},
	Peerreview = {yes},
	Title = {Modeling Domain-Specific Profilers},
	Url = {http://www.jot.fm/issues/issue_2012_04/article5.pdf},
	Volume = {11},
	Year = {2012},
	Bdsk-Url-1 = {http://www.jot.fm/issues/issue_2012_04/article5.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.5381/jot.2012.11.1.a5}}

@inproceedings{Ress12c,
	Abstract = {The way programming languages manage memory has been
				  a hot topic for many years. Languages with garbage
				  collection (GC) removed the burden of memory management
				  from developers. Typically the garbage collection
				  infrastructure is a black box that developers have
				  no control over. This is particularly striking in
				  object-oriented systems, where objects themselves
				  have no way to control their life and death. Instead
				  an external process (the GC) decides if an object is
				  still needed or not. In this paper we propose suicide
				  objects, objects that make their own decisions about
				  their life and death. With two examples we demonstrate
				  how the traditional garbage collector can be replaced,
				  and how developers can benefit from an object-centric
				  memory management.},
	Acmid = {2307197},
	Address = {New York, NY, USA},
	Annote = {internationalworkshop},
	Articleno = {1},
	Author = {Jorge Ressia and Fabrizio Perin and Lukas Renggli},
	Booktitle = {Proceedings of the 6th Workshop on Dynamic Languages and Applications},
	Doi = {10.1145/2307196.2307197},
	Isbn = {978-1-4503-1507-4},
	Keywords = {scg-pub scg12 snf12 jb12 ressia},
	Location = {Beijing, China},
	Medium = {1},
	Numpages = {2},
	Pages = {1:1--1:2},
	Peerreview = {yes},
	Publisher = {ACM},
	Series = {DYLA '12},
	Title = {Suicide Objects},
	Url = {http://scg.unibe.ch/archive/papers/Ress12cSuicideObjects.pdf},
	Year = {2012},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Ress12cSuicideObjects.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/2307196.2307197}}

@article{Ress12e,
	Abstract = {Reuse in object-oriented languages typically focuses on
				  inheritance. Numerous techniques have been developed to
				  provide finer-grained reuse of methods, such as flavors,
				  mixins, and traits. These techniques, however, only deal
				  with reuse at the level of classes. Class-based reuse is
				  inherently static. Increasing use of reflection and meta-
				  programming techniques in real-world applications underlines
				  the need for more dynamic approaches. New approaches have
				  shifted to object-specific reuse. However, these techniques
				  fail to provide a complete solution to the composition
				  issues arising during reuse. We propose a new approach that
				  deals with reuse at the object level and that supports
				  behavioral and state composition. We introduce a new
				  abstraction called a talent that models features that are
				  shared between objects of different class hierarchies.
				  Talents provide a composition mechanism that is as flexible
				  as that of traits but that is dynamic.},
	Annote = {internationaljournal},
	Author = {Jorge Ressia and Tudor G\^irba and Oscar Nierstrasz and Fabrizio Perin and Lukas Renggli},
	Doi = {10.1002/spe.2160},
	Issn = {1097-024X},
	Journal = {Software: Practice and Experience},
	Keywords = {snf12 jb12 scg-pub scg12 bifrost talents reflection traits Mixins object-specific smalltalk girba},
	Medium = {2},
	Peerreview = {yes},
	Publisher = {John Wiley & Sons, Ltd},
	Title = {Talents: an environment for dynamically composing units of reuse},
	Url = {http://scg.unibe.ch/archive/papers/Ress12eTalentsSPE.pdf},
	Year = {2012},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Ress12eTalentsSPE.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1002/spe.2160}}

@inproceedings{Rich97a,
	Abstract = {We have identified two levels of restructuring in
				  the re-engineering of object-oriented legacy
				  systems: high-level restructuring is concerned with
				  improving the overall architecture of the system,
				  whereas low-level restructuring deals with repairing
				  local problems which are symptoms of bad style. We
				  propose to characterize these low-level problems as
				  patterns of dependencies between classes as an aid
				  in detecting and resolving them. In this paper we
				  briefly present low-level problems and give two
				  examples of how these can be characterized as
				  specific dependency patterns.},
	Author = {Tamar Richner and Robb Nebbe},
	Booktitle = {Object-Oriented Technology (ECOOP '97 Workshop Reader)},
	Editor = {Jan Bosch and Stuart Mitchell},
	Keywords = {olit famoos-papunr scglit oobib scg-pub skip-doi toBeChecked snf97 scg-none jb97},
	Month = jun,
	Pages = {266--267},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Analyzing Dependencies to Solve Low-Level Problems},
	Url = {http://scg.unibe.ch/archive/papers/Rich97aLowLevel.pdf},
	Volume = 1357,
	Year = {1997},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Rich97aLowLevel.pdf}}

@inproceedings{Rich98a,
	Abstract = {In this paper we argue for the necessity of an
				  architectural description of a framework. We then
				  analyze why design patterns on their own are
				  insufficient for such a description and propose that
				  a variety of complementary forms of documentation
				  are needed to address the requirements of an
				  architectural description. We claim that traditional
				  artifacts of domain analysis and object-oriented
				  design can better capture the architecture of a
				  framework by describing the design solutions in the
				  problem context at a higher level of granularity
				  than can design patterns.},
	Author = {Tamar Richner},
	Booktitle = {Proceedings of the ECOOP '98 Workshop on Object-Oriented Software Architectures},
	Editor = {Jan Bosch and Helene Bachatene and G{\"o}rel Hedin and Kai Koskimies},
	Keywords = {olit famoos-papunr scglit oobib scg-pub skip-doi toBeChecked snf98 scg-none jb98},
	Month = jul,
	Publisher = {University of Karlskrona},
	Series = {Research Report 13/98},
	Title = {Describing Framework Architectures: more than Design Patterns},
	Url = {http://scg.unibe.ch/archive/papers/Rich98aFrameworkArch.pdf},
	Year = {1998},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Rich98aFrameworkArch.pdf}}

@inproceedings{Rich98b,
	Abstract = {Understanding how components in an application
				  interact to ensure a certain functionality is an
				  essential aspect of understanding a software
				  application. To obtain this kind of information an
				  analysis of the dynamic behavior of an application
				  is more appropriate than a static analysis of the
				  code. Understanding dynamic behavior through event
				  analysis is a challenge because of the large amount
				  of data gathered through program executions. In this
				  paper, we show how we define declarative queries
				  that allow us to filter the event data collected and
				  to define new abstractions which aid in program
				  understanding.},
	Annote = {internationalworkshop},
	Author = {Tamar Richner and St\'ephane Ducasse and Roel Wuyts},
	Booktitle = {Object-Oriented Technology (ECOOP '98 Workshop Reader)},
	Editor = {Serge Demeyer and Jan Bosch},
	Keywords = {olit famoos-papunr scglit oobib scg-pub skip-doi toBeChecked snf98 scg-none jb98 stefPub},
	Month = jul,
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Understanding Object-Oriented Programs with Declarative Event Analysis},
	Url = {http://scg.unibe.ch/archive/papers/Rich98bEvents.pdf},
	Volume = {1543},
	Year = {1998},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Rich98bEvents.pdf}}

@inproceedings{Rich99a,
	Abstract = {Recovering architectural documentation from code is
				  crucial to maintaining and reengineering software
				  systems. Reverse engineering and program
				  understanding approaches are often limited by the
				  fact that (1) they propose a fixed set of predefined
				  views and (2) they consider either purely static or
				  purely dynamic views of the application. In this
				  paper we present an environment supporting the
				  generation of tailorable views of object-oriented
				  systems from both static and dynamic information.
				  Our approach is based on the combination of
				  user-defined queries which allow an engineer to
				  create high-level abstractions and to produce views
				  using these abstractions.},
	Acceptnum = {49},
	Accepttotal = {100},
	Address = {Los Alamitos CA},
	Annote = {internationalconference},
	Author = {Tamar Richner and St\'ephane Ducasse},
	Booktitle = {Proceedings of 15th IEEE International Conference on Software Maintenance (ICSM'99)},
	Doi = {10.1109/ICSM.1999.792487},
	Editor = {Hongji Yang and Lee White},
	Keywords = {olit famoos-papref scg-pub toBeChecked snf99 scg-none jb99 oorp stefPub},
	Misc = {acceptance rate: 49/100 = 49\%},
	Month = sep,
	Pages = {13--22},
	Publisher = {IEEE Computer Society Press},
	Title = {Recovering High-Level Views of Object-Oriented Applications from Static and Dynamic Information},
	Url = {http://scg.unibe.ch/archive/papers/Rich99aRecoveringViews.pdf},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Rich99aRecoveringViews.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICSM.1999.792487}}

@inproceedings{Rich99b,
	Abstract = {Tracking the evolution of a software system through
				  time gives us valuable information. It suggests
				  which parts are likely to remain stable and which
				  'problem' aspects are likely to change, and it gives
				  us insight into some of the design choices made. In
				  this paper we show how recovered views of succesive
				  versions of the same software system can be used to
				  track evolution. We first briefly describe our
				  approach for recovering views of software
				  applications. We then compare views of two versions
				  of the HotDraw framework. Our objective is to
				  illustrate a number of issues concerning
				  architectural evolution: what is architectural
				  change as opposed to change in general? how can we
				  detect architectural drift? how can we evaluate the
				  relative quality of different architectural
				  solutions? what are guidelines for building
				  evolvable software?},
	Author = {Tamar Richner},
	Booktitle = {ECOOP '99 Workshop Reader},
	Keywords = {olit famoos-papunr scglit oobib scg-pub skip-doi snf99 scg-none jb99},
	Month = jun,
	Number = 1743,
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Using Recovered Views to Track Architectural Evolution},
	Url = {http://scg.unibe.ch/archive/famoos/Rich99b/ecoop99.pdf},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/famoos/Rich99b/ecoop99.pdf}}

@inproceedings{Rich02a,
	Abstract = {Modeling object-oriented applications using
				  collaborations and roles is now well accepted.
				  Collaboration-based or role-based designs decompose
				  an application into tasks performed by a subset of
				  the applications' classes. Collaborations prov ide a
				  larger unit of understanding and reuse than classes,
				  and are an important aid in the maintenance and
				  evolution of the software. This kind of design
				  information is lost, however, at the implementation
				  level, making it hard to maintain and evolve an e
				  xisting software application. The extraction of
				  collaborations from code is therefore an important
				  issue in design recovery. In this paper we propose
				  an iterative approach which uses dynamic information
				  to support the recovery and understanding of collabo
				  rations. We describe a tool we have developed to
				  support our approach and demonstrate its use on a
				  case study.},
	Acceptnum = {61},
	Accepttotal = {127},
	Address = {Los Alamitos CA},
	Annote = {internationalconference},
	Author = {Tamar Richner and St\'ephane Ducasse},
	Booktitle = {Proceedings of 18th IEEE International Conference on Software Maintenance (ICSM'02)},
	Doi = {10.1109/ICSM.2002.1167745},
	Keywords = {scg-pub snf02 scg-none jb02 stefPub},
	Misc = {acceptance rate: 61/127 = 48\%},
	Month = oct,
	Pages = {34},
	Publisher = {IEEE Computer Society},
	Title = {Using Dynamic Information for the Iterative Recovery of Collaborations and Roles},
	Url = {http://scg.unibe.ch/archive/papers/Rich02aRolesExtractionICSM2002.pdf},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Rich02aRolesExtractionICSM2002.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICSM.2002.1167745}}

@inproceedings{Rieg98a,
	Abstract = {Code duplication is considered as bad practice that
				  complicates the maintenance and evolution of
				  software. Detecting duplicated code is a difficult
				  task because of the large amount of data to be
				  checked and the fact that a priori it is unknown
				  which code part has been duplicated. In this paper,
				  we present a tool called DUPLOC that supports code
				  duplication detection in a visual and exploratory or
				  an automatic way.},
	Annote = {internationalworkshop},
	Author = {Matthias Rieger and St\'ephane Ducasse},
	Booktitle = {Proceedings ECOOP Workshop on Experiences in Object-Oriented Re-Engineering},
	Editor = {St\'ephane Ducasse and Joachim Weisbrod},
	Keywords = {scg-none jb98 famoos-papunr snf98 scg-pub skip-doi},
	Number = {6/7/98},
	Publisher = {Forschungszentrum Informatik Karlsruhe},
	Series = {FZI Report},
	Title = {Visual Detection of Duplicated Code},
	Url = {http://scg.unibe.ch/archive/papers/Rieg98aEcoopWorkshop.pdf},
	Year = {1998},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Rieg98aEcoopWorkshop.pdf}}

@inproceedings{Rieg98b,
	Abstract = {Code duplication is considered as bad practice that
				  complicates the maintenance and evolution of
				  software. Detecting duplicated code is a difficult
				  task because of the large amount of data to be
				  checked and the fact that a priori it is unknown
				  which code part has been duplicated. In this paper,
				  we present a tool called DUPLOC that supports code
				  duplication detection in a visual and exploratory or
				  an automatic way.},
	Annote = {internationalworkshop},
	Author = {Matthias Rieger and St\'ephane Ducasse},
	Booktitle = {Object-Oriented Technology (ECOOP '98 Workshop Reader)},
	Editor = {Serge Demeyer and Jan Bosch},
	Keywords = {olit famoos-papunr reveng scg-pub skip-doi scg-none jb-none stefPub},
	Month = jul,
	Pages = {75--76},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Visual Detection of Duplicated Code},
	Url = {http://scg.unibe.ch/archive/papers/Rieg98aEcoopWorkshop.pdf},
	Volume = {1543},
	Year = {1998},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Rieg98aEcoopWorkshop.pdf}}

@inproceedings{Rieg99a,
	Abstract = {Code duplication is an important problem in
				  application maintenance. Tools exist that support
				  code duplication detection. However, few of them
				  propose a solution for the problem, i.e.
				  refactorings. We propose an approach that uses the
				  information given by code duplication detection to
				  guide the refactorings of OO applications.},
	Annote = {internationalworkshop},
	Author = {Matthias Rieger and St\'ephane Ducasse and Georges Golomingi},
	Booktitle = {Object-Oriented Technology (ECOOP '99 Workshop Reader)},
	Keywords = {olit scg-pub skip-doi scg-none jb-none},
	Number = {1743},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Tool Support for Refactoring Duplicated OO Code},
	Url = {http://scg.unibe.ch/archive/papers/Rieg99aToolSuppRefacOOCode.pdf},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Rieg99aToolSuppRefacOOCode.pdf}}

@techreport{Rieg04a,
	Abstract = {Duplicated code can have a severe, negative impact
				  on the maintainability of large software systems.
				  Techniques for detecting duplicated code exist but
				  they rely mostly on parsers, technology that is
				  often fragile in the face of different languages and
				  dialects. In this paper we show that a lightweight
				  approach based on simple string-matching can be
				  effectively used to detect a significant amount of
				  code duplication. The approach scales well, and can
				  be easily adapted to different languages and
				  contexts. We validate our approach by applying it to
				  a number of industrial and open source case studies,
				  involving five different implementation languages
				  and ranging from 256KB to 13MB of source code.
				  Finally, we compare our approach to a more
				  sophisticated one employing parameterized matching,
				  and demonstrate that little if anything is gained by
				  adopting a more heavyweight approach.},
	Author = {Matthias Rieger},
	Institution = {University of Bern, Institute of Applied Mathematics and Computer Science},
	Keywords = {olit scg-pub skip-doi scg-none jb05 clones duploc recast05},
	Number = {iam-04-002},
	Title = {Experiments on Language Independent Duplication Detection},
	Url = {http://scg.unibe.ch/archive/papers/Rieg04a-IAM-04-002.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Rieg04a-IAM-04-002.pdf}}

@inproceedings{Rieg04b,
	Abstract = {Duplication of code is a common phenomenon in the
				  development and maintenance of large software
				  systems. The detection and removal of duplicated
				  code has become a standard activity during the
				  refactoring phases of a software life-cycle.
				  However, code duplication identification ends to
				  produce large amounts of data making the
				  understanding of the duplication situation as a
				  whole difficult. Reengineers can easily lose sight
				  of the forest for the trees. There is a need to
				  support a qualitative analysis of the duplicated
				  code. In this paper we propose a number of
				  visualzations of duplicated source elements that
				  support reengineers in answering questions, e.g.,
				  which parts of the sysem are connected by copied
				  code or which parts of the sysem are copied the
				  most.},
	Acceptnum = {28},
	Accepttotal = {78},
	Annote = {internationalconference},
	Author = {Matthias Rieger and St\'ephane Ducasse and Michele Lanza},
	Booktitle = {Proceedings of 11th Working Conference on Reverse Engineering (WCRE'04)},
	Cvs = {DuplocVizPaper},
	Doi = {10.1109/WCRE.2004.25},
	Keywords = {olit scg-pub scg-none jb05 recast05 stefPub clones},
	Location = {Delft, The Netherlands},
	Misc = {acceptance rate: 28/78 = 36\%},
	Month = nov,
	Pages = {100--109},
	Publisher = {IEEE Computer Society Press},
	Title = {Insights into System-Wide Code Duplication},
	Url = {http://scg.unibe.ch/archive/papers/Rieg04bWCRE2004ClonesVisualization.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Rieg04bWCRE2004ClonesVisualization.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.2004.25}}

@inproceedings{Robb05b,
	Abstract = {Understanding classes and methods is a key activity
				  in object-oriented programming, since classes
				  represent the primary abstractions from which
				  applications are built, while methods contain the
				  actual program logic. The main problem of this task
				  is to quickly grasp the purpose and inner structure
				  of a class. To achieve this goal, one must be able
				  to overview multiple methods at once. In this paper,
				  we present microprints, pixel-based representations
				  of methods enriched with semantical information. We
				  present three specialized microprints each dealing
				  with a specific aspect we want to understand of
				  methods: (1) state access, (2) control flow, and (3)
				  invocation relationship. We present the microprints
				  in conjunction with the class blueprints of the CODE
				  CRAWLER visualization tool [12] and also integrated
				  into the default code browser of the Smalltalk
				  VisualWorks development environment.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Romain Robbes and St\'ephane Ducasse and Michele Lanza},
	Booktitle = {Proceedings of 13th International Smalltalk Conference (ISC'05)},
	Inria = {hors},
	Keywords = {scg-pub skip-doi stefPub snf05 scg-none jb06 listic},
	Pages = {131--157},
	Selectif = {non},
	Title = {Microprints: A Pixel-based Semantically Rich Visualization of Methods},
	Url = {http://scg.unibe.ch/archive/papers/Robb05b-microprintsESUG.pdf},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Robb05b-microprintsESUG.pdf}}

@inproceedings{Robb11a,
	Abstract = {When the Application Programming Interface (API) of a framework or library changes, its clients must be adapted. This change propagation -- known as a ripple effect -- is a problem that has garnered interest: several approaches have been proposed in the literature to react to these changes.
			Although studies of ripple effects exist at the single system level, no study has been performed on the actual extend and impact of these API changes in practice on an entire software ecosystem associated with a community of developers. This paper reports on early results of such an empirical study of API changes that led to ripple effects across an entire ecosystem. Our case study subject is the development community gravitating around the Squeak and Pharo software ecosystems: six years of evolution, nearly 3,000 contributors, and close to 2,500 distinct systems.
			},
	Annote = {internationalconference},
	Author = {Romain Robbes and Mircea Lungu},
	Booktitle = {Proceedings of the 33rd International Conference on Software Engineering (ICSE 2011)},
	Doi = {10.1145/1985793.1985940},
	Keywords = {scg-bigdata scg-pub scg11 snf11 jb11 sde-ecosystems ercim11},
	Medium = {2},
	Month = may,
	Pages = {904-907},
	Peerreview = {yes},
	Title = {A Study of Ripple Effects in Software Ecosystems (NIER)},
	Url = {http://scg.unibe.ch/archive/papers/Robb11aRipples.pdf},
	Year = {2011},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Robb11aRipples.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1985793.1985940}}

@inproceedings{Robb12a,
	Abstract = {When the Application Programming Interface (API) of a framework or library changes, its clients must be adapted. This change propagation -- known as a ripple effect -- is a problem that has garnered interest: several approaches have been proposed in the literature to react to these changes. Although studies of ripple effects exist at the single system level, no study has been performed on the actual extent and impact of these API changes in practice, on an entire software ecosystem associated with a community of developers. This paper reports on an empirical study of API deprecations that led to ripple effects across an entire ecosystem. Our case study subject is the development community gravitating around the Squeak and Pharo software ecosystems: seven years of evolution, more than 3,000 contributors, and more than 2,600 distinct systems. We analyzed 577 methods and 186 classes that were deprecated, and answer research questions regarding the frequency, magnitude, duration, adaptation, and consistency of the ripple effects triggered by API changes.},
	Author = {Romain Robbes and Mircea Lungu and David Roethlisberger},
	Booktitle = {Proceedings of the 20th International Symposium on the		 Foundations of Software Engineering (FSE'12)},
	Doi = {10.1145/2393596.2393662},
	Keywords = {scg-pub snf12 sde-ecosystems roethlisberger scg12 jb13},
	Medium = {2},
	Pages = {56:1 - 56:11},
	Peerreview = {yes},
	Title = {How Do Developers React to {API} Deprecation? {The} Case of a {Smalltalk} Ecosystem},
	Url = {http://scg.unibe.ch/archive/papers/Rob12aAPIDeprecations.pdf},
	Year = {2012},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Rob12aAPIDeprecations.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/2393596.2393662}}

@inproceedings{Roet07b,
	Abstract = {Dynamic, unanticipated adaptation of running systems
				  is of interest in a variety of situations, ranging
				  from functional upgrades to on-the-fly debugging or
				  monitoring of critical applications. In this paper
				  we study a particular form of computational
				  reflection, called unanticipated partial behavioral
				  reflection, which is particularly well-suited for
				  unanticipated adaptation of real-world systems. Our
				  proposal combines the dynamicity of unanticipated
				  reflection, i.e., reflection that does not require
				  preparation of the code of any sort, and the
				  selectivity and efficiency of partial behavioral
				  reflection. First, we propose unanticipated partial
				  behavioral reflection which enables the developer to
				  precisely select the required reifications, to
				  flexibly engineer the metalevel and to introduce the
				  meta behavior dynamically. Second, we present a
				  system supporting unanticipated partial behavioral
				  reflection in Squeak Smalltalk, called Geppetto, and
				  illustrate its use with a concrete example of a
				  Seaside web application. Benchmarks validate the
				  applicability of our proposal as an extension to the
				  standard reflective abilities of Smalltalk.},
	Annote = {internationalconference},
	Author = {David R{\"o}thlisberger and Marcus Denker and {\'E}ric Tanter},
	Booktitle = {Advances in Smalltalk --- Proceedings of 14th International Smalltalk Conference (ISC 2006)},
	Doi = {10.1007/978-3-540-71836-9_3},
	Isbn = {978-3-540-71835-2},
	Issn = {0302-9743},
	Keywords = {scg07 scg-pub jb07 snf06 roethlisberger reflectivity},
	Medium = {2},
	Pages = {47--65},
	Peerreview = {yes},
	Publisher = {Springer},
	Series = {LNCS},
	Title = {Unanticipated Partial Behavioral Reflection},
	Url = {http://scg.unibe.ch/archive/papers/Roet07bUPBReflection.pdf},
	Volume = {4406},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Roet07bUPBReflection.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-540-71836-9_3}}

@inproceedings{Roet07c,
	Annote = {internationalworkshop},
	Author = {David R{\"o}thlisberger and Orla Greevy and Adrian Lienhard},
	Booktitle = {Proceedings IEEE International Workshop on Visualizing Software for Understanding (Vissoft 2007) (tool demonstration)},
	Keywords = {scg07 scg-pub skip-doi skip-abstract snf07 jb07 roethlisberger},
	Medium = {2},
	Peerreview = {yes},
	Title = {Feature-centric Environment},
	Url = {http://scg.unibe.ch/archive/papers/Roet07cFeatureBrowserVissoft.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Roet07cFeatureBrowserVissoft.pdf}}

@inproceedings{Roet07d,
	Annote = {internationalworkshop},
	Author = {David R{\"o}thlisberger and Oscar Nierstrasz},
	Booktitle = {Proceedings of FAMOOSr 2007 (Ist International Workshop on FAMIX and Moose in Reengineering)},
	Keywords = {scg07 scg-pub skip-doi skip-abstract snf07 jb07 roethlisberger},
	Medium = {2},
	Peerreview = {yes},
	Title = {Combining Development Environments with Reverse Engineering},
	Url = {http://scg.unibe.ch/archive/papers/Roet07dFamoosrIDEReverseEngineering.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Roet07dFamoosrIDEReverseEngineering.pdf}}

@inproceedings{Roet07e,
	Abstract = {Development environments typically present the
				  software engineer with a structural perspective of
				  an object-oriented system in terms of packages,
				  classes and methods. From a structural perspective
				  it is difficult to gain an understanding of how
				  source entities participate in a system's features
				  at runtime. In this paper we evaluate the usefulness
				  of offering an alternative feature-centric
				  perspective of a software system when performing
				  maintenance activities. We present a feature-centric
				  environment combining interactive visual
				  representations of features with a source code
				  browser displaying only the classes and methods
				  participating in a feature under investigation. To
				  validate the usefulness of our feature-centric view,
				  we conducted a controlled empirical experiment where
				  we measured and compared the performance of subjects
				  when correcting two defects in an unfamiliar
				  software system with a traditional development
				  environment and with our feature-centric
				  environment. We evaluate both quantitative and
				  qualitative data to draw conclusions about the
				  usefulness of a feature-centric perspective to
				  support program comprehension during maintenance
				  activities.},
	Annote = {internationalconference},
	Author = {David R{\"o}thlisberger and Orla Greevy and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 2007 International Conference on Dynamic Languages (ICDL 2007)},
	Doi = {10.1145/1352678.1352684},
	Keywords = {scg07 scg-pub snf07 jb08 roethlisberger snf-bmcc},
	Medium = {2},
	Pages = {79--100},
	Peerreview = {yes},
	Publisher = {ACM Digital Library},
	Title = {Feature Driven Browsing},
	Url = {http://scg.unibe.ch/archive/papers/Roet07eFeatureBrowser.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Roet07eFeatureBrowser.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1352678.1352684}}

@article{Roet08a,
	Abstract = {Dynamic, unanticipated adaptation of running systems
				  is of interest in a variety of situations, ranging
				  from functional upgrades to on-the-fly debugging or
				  monitoring of critical applications. In this paper
				  we study a particular form of computational
				  reflection, called unanticipated partial behavioral
				  reflection, which is particularly well-suited for
				  unanticipated adaptation of real-world systems. Our
				  proposal combines the dynamicity of unanticipated
				  reflection, i.e. reflection that does not require
				  preparation of the code of any sort, and the
				  selectivity and efficiency of partial behavioral
				  reflection. First, we propose unanticipated partial
				  behavioral reflection which enables the developer to
				  precisely select the required reifications, to
				  flexibly engineer the metalevel and to introduce the
				  meta behavior dynamically. Second, we present a
				  system supporting unanticipated partial behavioral
				  reflection in Squeak Smalltalk, called Geppetto, and
				  illustrate its use with a concrete example of a web
				  application. Benchmarks validate the applicability
				  of our proposal as an extension to the standard
				  reflective abilities of Smalltalk.},
	Annote = {internationaljournal},
	Author = {David R{\"o}thlisberger and Marcus Denker and {\'E}ric Tanter},
	Doi = {10.1016/j.cl.2007.05.001},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {scg08 scg08 scg-pub jb08 snf08 roethlisberger reflectivity},
	Medium = {2},
	Month = jul,
	Number = {2-3},
	Pages = {46--65},
	Peerreview = {yes},
	Publisher = {Elsevier},
	Title = {Unanticipated Partial Behavioral Reflection: Adapting Applications at Runtime},
	Url = {http://scg.unibe.ch/archive/papers/Roet08aUPBReflectionJournal.pdf},
	Volume = {34},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Roet08aUPBReflectionJournal.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.cl.2007.05.001}}

@inproceedings{Roet08b,
	Abstract = {Developers rely on the mechanisms provided by their
				  IDE to browse and navigate a large software system.
				  These mechanisms are usually based purely on a
				  system's static source code. The static perspective,
				  however, is not enough to understand an
				  object-oriented program's behavior, in particular if
				  implemented in a dynamic language. We propose to
				  enhance IDEs with a program's runtime information
				  (eg. message sends and type information) to support
				  program comprehension through precise navigation and
				  informative browsing. To precisely specify the type
				  and amount of runtime data to gather about a system
				  under development, dynamically and on demand, we
				  adopt a technique known as partial behavioral
				  reflection. We implemented navigation and browsing
				  enhancements to an IDE that exploit this runtime
				  information in a prototype called Hermion. We
				  present preliminary validation of our experimental
				  enhanced IDE by asking developers to assess its
				  usefulness to understand an unfamiliar software
				  system.},
	Address = {Los Alamitos, CA, USA},
	Annote = {internationalconference},
	Author = {David R{\"o}thlisberger and Orla Greevy and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 16th International Conference on Program Comprehension (ICPC 2008)},
	Doi = {10.1109/ICPC.2008.32},
	Isbn = {978-0-7695-3176-2},
	Journal = {icpc},
	Keywords = {scg08 scg-pub jb08 snf08 roethlisberger reflectivity},
	Medium = {2},
	Pages = {63--72},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Title = {Exploiting Runtime Information in the {IDE}},
	Url = {http://scg.unibe.ch/archive/papers/Roet08bDynamicInfoIDE.pdf},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Roet08bDynamicInfoIDE.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICPC.2008.32}}

@inproceedings{Roet08c,
	Abstract = {Code queries focus mainly on the static structure of
				  a system. To comprehend the dynamic behavior of a
				  system however, a software engineer needs to be able
				  to reason about the dynamics of this system, for
				  instance by querying a database of dynamic
				  information. Such a querying mechanism should be
				  directly available in the IDE where the developers
				  implements, navigates and reasons about the software
				  system. We propose (i) concepts to gather dynamic
				  information, (ii) the means to query this
				  information, and (iii) tools and techniques to
				  integrate querying of dynamic information in the
				  IDE, including the presentation of results generated
				  by queries.},
	Annote = {internationalworkshop},
	Author = {David R{\"o}thlisberger},
	Bdsk-Url-1 = {http://www.cs.vu.nl/icpc2008/qtapc2008.php http://scg.unibe.ch/archive/papers/Roet08c-QTAPC08.pdf},
	Booktitle = {Proceedings of the 2008 workshop on Query Technologies and Applications for Program Comprehension (QTAPC 2008)},
	Keywords = {scg08 scg-pub skip-doi jb08 snf08 roethlisberger},
	Medium = {2},
	Pages = {n4},
	Peerreview = {yes},
	Title = {Querying Runtime Information in the {IDE}},
	Url = {http://www.cs.vu.nl/icpc2008/qtapc2008.php http://scg.unibe.ch/archive/papers/Roet08c-QTAPC08.pdf},
	Year = {2008},
	Bdsk-Url-2 = {http://www.cs.vu.nl/icpc2008/qtapc2008.php%20http://scg.unibe.ch/archive/papers/Roet08c-QTAPC08.pdf}}

@inproceedings{Roet08g,
	Abstract = {Moose is a powerful reverse engineering platform,
				  but its facilities and means to analyze software are
				  separated from the tools developers typically use to
				  develop and maintain their software systems:
				  development environments such as Eclipse,
				  VisualWorks, or Squeak. In practice, this requires
				  developers to work with two distinct environments,
				  one to actually develop the software, and another
				  one (e.g., Moose) to analyze it. We worked on
				  several different techniques, using both dynamic and
				  static analyzes to provide software analysis
				  capabilities to developers directly in the IDE. The
				  immediate availability of analysis tools in an IDE
				  significantly increases the likelihood that
				  developers integrate software analysis in their
				  daily work, as we discovered by conducting user
				  studies with developers. Finally, we identified
				  several important aspect of integrating software
				  analysis in IDEs that need to be addressed in the
				  future to increase the adoption of these techniques
				  by developers.},
	Annote = {internationalworkshop},
	Author = {David R{\"o}thlisberger},
	Booktitle = {FAMOOSr, 2nd Workshop on FAMIX and Moose in Reengineering},
	Keywords = {scg08 scg-pub skip-doi snf09 jb09 roethlisberger},
	Medium = {2},
	Peerreview = {yes},
	Title = {Embedding {Moose} Facilities Directly in {IDEs}},
	Url = {http://scg.unibe.ch/archive/papers/Roet08gMooseFacilitiesInIDE.pdf},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Roet08gMooseFacilitiesInIDE.pdf}}

@inproceedings{Roet09a,
	Abstract = {Mainstream IDEs generally rely on the static
				  structure of a software project to support browsing
				  and navigation. We propose HeatMaps, a simple but
				  highly configurable technique to enrich the way an
				  IDE displays the static structure of a software
				  system with additional kinds of information. A
				  heatmap highlights software artifacts according to
				  various metric values, such as bright red or pale
				  blue, to indicate their potential degree of
				  interest. We present a prototype system that
				  implements heatmaps, and we describe an initial
				  study that assesses the degree to which different
				  heatmaps effectively guide developers in navigating
				  software.},
	Address = {Los Alamitos, CA, USA},
	Annote = {internationalconference},
	Author = {David R{\"o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse and Damien Pollet and Romain Robbes},
	Booktitle = {Proceedings of the 17th International Conference on Program Comprehension (ICPC 2009)},
	Doi = {10.1109/ICPC.2008.32},
	Isbn = {978-0-7695-3176-2},
	Journal = {icpc},
	Keywords = {scg09 scg-pub snf09 jb09 roethlisberger},
	Medium = {2},
	Pages = {253--257},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Title = {Supporting Task-oriented Navigation in {IDEs} with Configurable {HeatMaps}},
	Url = {http://scg.unibe.ch/archive/papers/Roet09aHeatMapsICPC2009.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Roet09aHeatMapsICPC2009.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICPC.2008.32}}

@inproceedings{Roet09b,
	Abstract = {Mainstream IDEs such as Eclipse support developers
				  in managing software projects mainly by offering
				  static views of the source code. Such a static
				  perspective neglects any information about runtime
				  behavior. However, object-oriented programs heavily
				  rely on polymorphism and late-binding, which makes
				  them difficult to understand just based on their
				  static structure. Developers thus resort to
				  debuggers or profilers to study the system's
				  dynamics. However, the information provided by these
				  tools is volatile and hence cannot be exploited to
				  ease the navigation of the source space. In this
				  paper we present an approach to augment the static
				  source perspective with dynamic metrics such as
				  precise runtime type information, or memory and
				  object allocation statistics. Dynamic metrics can
				  leverage the understanding for the behavior and
				  structure of a system. We rely on dynamic data
				  gathering based on aspects to analyze running Java
				  systems. By solving concrete use cases we illustrate
				  how dynamic metrics directly available in the IDE
				  are useful. We also comprehensively report on the
				  efficiency of our approach to gather dynamic
				  metrics.},
	Address = {Los Alamitos, CA, USA},
	Annote = {internationalconference},
	Author = {David R{\"o}thlisberger and Marcel H\"{a}rry and Alex Villaz\'on and Danilo Ansaloni and Walter Binder and Oscar Nierstrasz and Philippe Moret},
	Booktitle = {Proceedings of the 25th International Conference on Software Maintenance (ICSM 2009)},
	Doi = {10.1109/ICSM.2009.5306302},
	Journal = {icsm},
	Keywords = {scg09 scg-pub snf09 jb10 senseo roethlisberger haerry},
	Medium = {2},
	Pages = {253--262},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Title = {Augmenting Static Source Views in {IDE}s with Dynamic Metrics},
	Url = {http://scg.unibe.ch/archive/papers/Roet09bDynamicInfoEclipse.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Roet09bDynamicInfoEclipse.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICSM.2009.5306302}}

@inproceedings{Roet09c,
	Abstract = {Maintaining object-oriented systems that use
				  inheritance and polymorphism is difficult, since
				  runtime information, such as which methods are
				  actually invoked at a call site, is not visible in
				  the static source code. We have implemented Senseo,
				  an Eclipse plugin enhancing Eclipse's static source
				  views with various dynamic metrics, such as runtime
				  types, the number of objects created, or the amount
				  of memory allocated in particular methods.},
	Address = {Los Alamitos, CA, USA},
	Annote = {internationalconference tooldemo},
	Author = {David R{\"o}thlisberger and Marcel H\"{a}rry and Alex Villaz\'on and Danilo Ansaloni and Walter Binder and Oscar Nierstrasz and Philippe Moret},
	Booktitle = {Proceedings of the 25th International Conference on Software Maintenance (ICSM 2009)},
	Doi = {10.1109/ICSM.2009.5306314},
	Journal = {icsm},
	Keywords = {scg09 scg-pub snf09 jb10 roethlisberger haerry},
	Medium = {2},
	Note = {Tool demo},
	Pages = {383--384},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Title = {Senseo: Enriching {Eclipse}'s Static Source Views with Dynamic Metrics},
	Url = {http://scg.unibe.ch/archive/papers/Roet09cSenseo.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Roet09cSenseo.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICSM.2009.5306314}}

@techreport{Roet09d,
	Abstract = {Mainstream IDEs generally rely on the static
				  structure of a software project to support browsing
				  and navigation. We propose HeatMaps, a simple but
				  highly configurable technique to enrich the way an
				  IDE displays the static structure of a software
				  system with additional kinds of information. A
				  heatmap highlights software artifacts according to
				  various metric values, such as bright red or pale
				  blue, to indicate their potential degree of
				  interest. We present a prototype system that
				  implements heatmaps, and we describe an initial
				  study that assesses the degree to which different
				  heatmaps effectively guide developers in navigating
				  software.},
	Address = {Universit\"at Bern, Switzerland},
	Author = {David R{\"o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse and Damien Pollet and Romain Robbes},
	Classification = {D.2.2 Tools and Techniques; D.2.3 Coding; D.2.6 Programming Environments; D.2.9 Management},
	General_Terms = {Coding, Programming Environments, Program Editors, Integrated Environments},
	Institution = {Institut f\"ur Informatik},
	Keywords = {scg-pub snf09 scg-none jb09 skip-doi roethlisberger},
	Month = jul,
	Number = {IAM-09-005},
	Title = {Supporting Task-oriented Navigation in {IDEs} with Configurable {HeatMaps}},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Roet09dHeatMapsTechReport.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Roet09dHeatMapsTechReport.pdf}}

@inproceedings{Roet09e,
	Abstract = {The IDE used in most Smalltalk dialects such as
				  Pharo, Squeak or Cincom Smalltalk did not evolve
				  significantly over the last years, if not to say
				  decades. For other languages, for instance Java, the
				  available IDEs made tremendous progress as Eclipse
				  or NetBeans illustrate. While the Smalltalk IDE
				  served as an exemplar for many years, other IDEs
				  caught up or even overtook the erstwhile leader in
				  terms of feature-richness, usability, or code
				  navigation facilities. In this paper we first
				  analyze the difficulty of software navigation in the
				  Smalltalk IDE and second illustrate with concrete
				  examples the features we added to the Smalltalk IDE
				  to fill the gap to modern IDEs and to provide novel,
				  improved means to navigate source space. We show
				  that thanks to the agility and dynamics of
				  Smalltalk, we are able to extend and enhance with
				  reasonable effort the Smalltalk IDE to better
				  support software navigation, program comprehension,
				  and software maintenance in general. One such
				  support is the integration of dynamic information
				  into the static source views we are familiar with.
				  Other means include easing the access to static
				  information (for instance by better arranging
				  important packages) or helping developers
				  re-locating artifacts of interest (for example with
				  a categorization system such as smart groups).},
	Address = {New York, NY, USA},
	Annote = {internationalworkshop},
	Author = {David R{\"o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse and Alexandre Bergel},
	Booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2009)},
	Doi = {10.1145/1735935.1735945},
	Isbn = {978-1-60558-899-5},
	Keywords = {scg09 scg-pub snf10 jb10 roethlisberger},
	Location = {Brest, France},
	Medium = {1},
	Pages = {58--67},
	Peerreview = {yes},
	Publisher = {ACM},
	Title = {Tackling Software Navigation Issues of the {Smalltalk} {IDE}},
	Url = {http://scg.unibe.ch/archive/papers/Roet09eNavigation.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Roet09eNavigation.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1735935.1735945}}

@inproceedings{Roet09f,
	Abstract = {Navigating large software systems is difficult as
				  the various artifacts are distributed in a huge
				  space, while the relationships between different
				  artifacts often remain hidden and obscure. As a
				  consequence, developers using a modern interactive
				  development environment (IDE) are forced to open
				  views on numerous source artifacts to reveal these
				  hidden relationships, leading to a crowded workspace
				  with many opened windows or tabs. Developers often
				  lose the overview in such a cluttered workspace as
				  IDEs provide little support to get rid of unused
				  windows. AutumnLeaves automatically selects windows
				  unlikely for future use to be closed or grayed out
				  while important ones are displayed more prominently.
				  This reduces the number of windows opened at a time
				  and adds structure to the developer's workspace. We
				  validate AutumnLeaves with a benchmark evaluation
				  using recorded navigation data of various developers
				  to determine the prediction quality of the employed
				  algorithms.},
	Address = {Los Alamitos, CA, USA},
	Annote = {internationalconference},
	Author = {David R{\"o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse},
	Booktitle = {Proceedings of the 16th Working Conference on Reverse Engineering (WCRE 2009)},
	Doi = {10.1109/WCRE.2009.18},
	Journal = {wcre},
	Keywords = {scg09 scg-pub snf10 jb10 roethlisberger},
	Location = {Lille, France},
	Medium = {2},
	Pages = {237--246},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Title = {Autumn Leaves: Curing the Window Plague in {IDEs}},
	Url = {http://scg.unibe.ch/archive/papers/Roet09fAutumnLeaves.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Roet09fAutumnLeaves.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.2009.18}}

@inproceedings{Roet09g,
	Abstract = {Researchers and practitioners are usually eager to
				  develop, test and experiment with new ideas and
				  techniques to analyze software systems and/or to
				  present results of such analyzes, for instance new
				  kind of visualizations or analysis tools. However,
				  often these novel and certainly promising ideas are
				  never properly and seriously empirically evaluated.
				  Instead their inventors just resort to anecdotal
				  evidence to substantiate their beliefs and claims
				  that their ideas and the realizations thereof are
				  actually useful in theory and practice. The chief
				  reason why proper validation is often neglected is
				  that serious evaluation of any newly realized
				  technique, tool, or concept in reverse engineering
				  is time-consuming, laborious, and often tedious.
				  Furthermore, we assume that there is also a lack of
				  knowledge or experience concerning empirical
				  evaluation in our community. This paper hence
				  sketches some ideas and discusses best practices of
				  how we can still, with moderate expenses, come up
				  with at least some empirical validation of our next
				  project in the field of reverse engineering.},
	Annote = {internationalworkshop},
	Author = {David R{\"o}thlisberger},
	Booktitle = {FAMOOSr, 3rd Workshop on FAMIX and Moose in Reengineering},
	Keywords = {scg09 scg-pub skip-doi snf10 jb10 roethlisberger},
	Medium = {2},
	Peerreview = {yes},
	Title = {Why and How to Substantiate the Good of our Reverse Engineering Tools?},
	Url = {http://scg.unibe.ch/archive/papers/Roet09gValidation.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Roet09gValidation.pdf}}

@article{Roet11a,
	Abstract = {Modern IDEs such as Eclipse offer static views of
				  the source code, but such views ignore information
				  about the runtime behavior of software systems.
				  Since typical object-oriented systems make heavy use
				  of polymorphism and dynamic binding, static views
				  will miss key information about the runtime
				  architecture. In this article we present an approach
				  to gather and integrate dynamic information in the
				  Eclipse IDE with the goal of better supporting
				  typical software maintenance activities. By means of
				  a controlled experiment with 30 professional
				  developers we show that for typical software
				  maintenance tasks integrating dynamic information
				  into the Eclipse IDE yields a significant 17.5\%
				  decrease of time spent while significantly
				  increasing the correctness of the solutions by
				  33.5\%. We also provide a comprehensive performance
				  evaluation of our approach.},
	Address = {Piscataway, NJ, USA},
	Annote = {internationaljournal},
	Author = {David R{\"o}thlisberger and Marcel H\"{a}rry and Alex Villaz\'on and Danilo Ansaloni and Walter Binder and Oscar Nierstrasz and Philippe Moret},
	Doi = {10.1109/TSE.2011.42},
	Journal = {Transactions on Software Engineering},
	Keywords = {scg-pub scg11 roethlisberger haerry jb11 snf10 ercim11},
	Medium = {2},
	Peerreview = {yes},
	Publisher = {IEEE Press},
	Title = {Exploiting Dynamic Information in {IDEs} Improves Speed and Correctness of Software Maintenance Tasks},
	Url = {http://scg.unibe.ch/archive/papers/Roet11aSenseoTSE.pdf},
	Year = {2011},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Roet11aSenseoTSE.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/TSE.2011.42}}

@inproceedings{Roet11b,
	Abstract = {Navigating large software systems, even when using a
				  modern IDE, is difficult, since conceptually related software
				  artifacts are distributed in a huge software space.
				  For most software maintenance tasks, only a small fraction
				  of the entire software space is actually relevant. The IDE,
				  however, does not reveal the task relevancy of source artifacts,
				  thus developers cannot easily focus on the artifacts required to
				  accomplish their tasks.
				  SmartGroups help developers to perform software maintenance
				  tasks by representing groups of source artifacts that are relevant
				  for the current task. Relevancy is determined by analyzing historical
				  navigation and modification activities, evolutionary information, and
				  runtime information.
				  The prediction quality of SmartGroups is validated with a benchmark evaluation
				  using recorded development activities and evolutionary information
				  from versioning systems.},
	Address = {Los Alamitos, CA, USA},
	Annote = {internationalconference},
	Author = {David R{\"o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse},
	Booktitle = {Proceedings of the 19th International Conference on Program Comprehension (ICPC 2011)},
	Doi = {10.1109/ICPC.2011.20},
	Journal = {icpc},
	Keywords = {scg-pub scg11 snf11 jb11 roethlisberger ercim11},
	Medium = {2},
	Pages = {246--257},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Title = {{SmartGroups}: Focusing on Task-Relevant Source Artifacts in {IDEs}},
	Url = {http://scg.unibe.ch/archive/papers/Roet11bSmartGroupsICPC2011.pdf},
	Year = {2011},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Roet11bSmartGroupsICPC2011.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICPC.2011.20}}

@article{Sade02a,
	Abstract = {The concept of interfaces is central to
				  object-oriented methodologies and is one of the most
				  attractive features of {Java} and COM. Although
				  Smalltalk always had interfaces implicitly, in
				  Smalltalk interfaces are not first-class objects: t
				  hey cannot be conversed with, referred to, or
				  reflected upon. Consequently, Smalltalkers have been
				  deprived of such an important and useful tool. Since
				  a fundamental feature of Smalltalk is that just
				  about everything in the language is an
				  implementation feature, explicit, static interfaces
				  can be added to Smalltalk using Smalltalk itself
				  with ease. However, such an addition would
				  short-change the powerful dynamic aspects of
				  Smalltalk. In this article we present
				  SmallInterfaces; a new ontology of dynamic i
				  nterfaces which makes a powerful use of the dynamic
				  nature of Smalltalk. SmallInterfaces adds interfaces
				  as honorary members to Smalltalk's extensive
				  reflection mechanism, in a manner portable across
				  the many Smalltalk variants},
	Annote = {internationaljournal},
	Author = {Benny Sadeh and St\'ephane Ducasse},
	Journal = {Journal of Object Technology},
	Keywords = {scg-pub skip-doi scg-none jb02 snf02 stefPub},
	Number = {1},
	Title = {Adding Dynamic Interfaces to {Smalltalk}},
	Url = {http://scg.unibe.ch/archive/papers/Sade02aDynamicInterfaces.pdf},
	Volume = {1},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Sade02aDynamicInterfaces.pdf}}

@inproceedings{Scha01b,
	Abstract = {Wrapping external components by scripts can be a
				  performance bottleneck if inter-language bridging is
				  frequent. Piccola is a pure composition language
				  that wraps components according to a specific
				  composition style. This wrapping must be efficient,
				  since even arithmetic operations are done by
				  external components. In this paper we present how to
				  use partial evaluation to overcome much of the
				  overhead associated with the wrapping. It turns out
				  that Piccola scripts can be highly optimized since
				  form expression exhibit the right kind of
				  information to separate side effects from services
				  and resolve internal dependencies.},
	Author = {Nathanael Sch{\"a}rli and Franz Achermann},
	Booktitle = {Workshop on Composition Languages, WCL '01},
	Keywords = {scg-pub skip-doi scg-none jb02 piccola snf01 schaerli},
	Misc = {schaerli},
	Month = sep,
	Title = {Partial evaluation of inter-language wrappers},
	Url = {http://scg.unibe.ch/archive/papers/Scha01bLanguageWrappers.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Scha01bLanguageWrappers.pdf}}

@inproceedings{Scha02a,
	Abstract = {We present a simple, component-based model of
				  mixins, called traits, and argue that this simple
				  model sidesteps many of the practical problems with
				  other approaches to mixins and multiple inheritance.
				  With our model, classes are built from a set of
				  traits by specifying glue code that connects them
				  together and accesses the necessary state. We
				  briefly discuss practical experience with an
				  implementation of traits for Squeak, and we list a
				  number of open questions for discussion.},
	Annote = {internationalworkshop},
	Author = {Nathanael Sch{\"a}rli and St\'ephane Ducasse and Oscar Nierstrasz},
	Booktitle = {Proceedings of the International Workshop on Inheritance},
	Keywords = {scg-pub skip-doi scg-traits scg-none jb02 snf02 stefPub schaerli},
	Title = {Classes = Traits + States + Glue (Beyond mixins and multiple inheritance)},
	Url = {http://scg.unibe.ch/archive/papers/Scha02aTraitsPlusGlue2002.pdf},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Scha02aTraitsPlusGlue2002.pdf}}

@techreport{Scha02b,
	Abstract = {Inheritance is the fundamental reuse mechanism in
				  object-oriented programming languages; its most
				  prominent variants are single inheritance, multiple
				  inheritance, and mixin inheritance. In the first
				  part of this paper, we identify and illustrate the
				  conceptual and practical reusability problems that
				  arise with these forms of inheritance. We then
				  present a simple compositional model for structuring
				  object-oriented programs, which we call traits.
				  Traits are essentially groups of methods that serve
				  as building blocks for classes and are primitive
				  units of code reuse. In this model, classes are
				  composed from a set of traits by specifying glue
				  code that connects the traits together and accesses
				  the necessary state. We demonstrate how traits
				  overcome the problems arising with the different
				  variants of inheritance, we discuss how traits can
				  be implemented effectively, and we summarize our
				  experience applying traits to refactor an existing
				  class hierarchy.},
	Address = {Universit\"at Bern, Switzerland},
	Annote = {report notrefereed},
	Author = {Nathanael Sch\"arli and St\'ephane Ducasse and Oscar Nierstrasz and Andrew P. Black},
	Classification = {D.1.5 Object-oriented Programming; D.3.3 Language Constructs and Features},
	Cvs = {TraitsECOOP},
	General_Terms = {Inheritance, Mixins, Multiple Inheritance, Traits, Reuse, Smalltalk},
	Institution = {Institut f\"ur Informatik},
	Keywords = {snf-redundant scg-pub skip-doi scg-none jb02 scg-traits stefPub schaerli},
	Month = nov,
	Note = {Also available as Technical Report CSE-02-014, OGI School of Science \& Engineering, Beaverton, Oregon, USA},
	Number = {IAM-02-005},
	Title = {Traits: Composable Units of Behavior},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Scha02bTraits.pdf},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Scha02bTraits.pdf}}

@techreport{Scha02c,
	Abstract = {Single-inheritance in object-oriented languages can
				  lead to duplicated code in rich class libraries
				  where feature-sharing cannot be linearized.
				  Multiple-inheritance and mixins alleviate this
				  problem, but lead to other difficulties in the face
				  of evolution. Changes to classes or mixins can break
				  code lower in the hierarchy in unexpected ways.
				  Traits solve both problems by factoring out shared
				  behaviour as sets of methods that do not depend on
				  state. Traits have the important property that
				  composition is symmetric, so changes do not lead to
				  unexpected side effects. We present a formal model
				  of traits, and define some basic properties of
				  traits and classes.},
	Address = {Universit\"at Bern, Switzerland},
	Annote = {notrefereed},
	Author = {Nathanael Sch\"arli and Oscar Nierstrasz and St\'ephane Ducasse and Roel Wuyts and Andrew Black},
	Classification = {D.3.1 Formal Definitions and Theory; D.1.5 Object-oriented Programming; D.3.3 Language Constructs and Features},
	Cvs = {TraitsECOOP},
	General_Terms = {Inheritance, Mixins, Multiple Inheritance, Traits, Reuse, Smalltalk},
	Institution = {Institut f\"ur Informatik},
	Keywords = {snf03 scg-pub skip-doi scg-none jb02 scg-traits schaerli},
	Month = nov,
	Note = {Also available as Technical Report CSE-02-013, OGI School of Science \& Engineering, Beaverton, Oregon, USA},
	Number = {IAM-02-006},
	Title = {Traits: The Formal Model},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Scha02cTraitsModel.pdf},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Scha02cTraitsModel.pdf}}

@inproceedings{Scha03a,
	Abstract = {Despite the undisputed prominence of inheritance as
				  the fundamental reuse mechanism in object-oriented
				  programming languages, the main variants --- single
				  inheritance, multiple inheritance, and mixin
				  inheritance --- all suffer from conceptual and
				  practical problems. In the first part of this paper,
				  we identify and illustrate these problems. We then
				  present traits, a simple compositional model for
				  structuring object-oriented programs. A trait is
				  essentially a group of pure methods that serves as a
				  building block for classes and is a primitive unit
				  of code reuse. In this model, classes are composed
				  from a set of traits by specifying glue code that
				  connects the traits together and accesses the
				  necessary state. We demonstrate how traits overcome
				  the problems arising from the different variants of
				  inheritance, we discuss how traits can be
				  implemented effectively, and we summarize our
				  experience applying traits to refactor an existing
				  class hierarchy.},
	Acceptnum = {18},
	Accepttotal = {88},
	Address = {Berlin Heidelberg},
	Annote = {internationalconference topconference},
	Author = {Nathanael Sch\"arli and St\'ephane Ducasse and Oscar Nierstrasz and Andrew P. Black},
	Booktitle = {Proceedings of European Conference on Object-Oriented Programming (ECOOP'03)},
	Cvs = {TraitsECOOP2003},
	Doi = {10.1007/b11832},
	Isbn = {978-3-540-40531-3},
	Keywords = {snf03 scg-pub scg-none jb03 scg-traits stefPub schaerli onhindex(297)},
	Location = {Darmstadt, Germany},
	Misc = {acceptance rate: 18/88 = 20\%},
	Month = jul,
	Pages = {248--274},
	Publisher = {Springer Verlag},
	Series = {LNCS},
	Title = {Traits: Composable Units of Behavior},
	Url = {http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf},
	Volume = {2743},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/b11832}}

@techreport{Scha03b,
	Abstract = {Much of the elegance and power of Smalltalk comes
				  from its programming environment and tools. First
				  introduced more than 20 years ago, the Smalltalk
				  browser enables programmers to ``home in'' on
				  particular methods using a hierarchy of
				  manually-defined classifications. By its nature,
				  this classification scheme says a lot about the
				  desired state of the code, but little about the
				  actual state of the code as it is being developed.
				  We have extended the Smalltalk browser with
				  dynamically computed virtual categories that
				  dramatically improve the browser's support for
				  incremental programming. We illustrate these
				  improvements by example, and describe the algorithms
				  used to compute the virtual categories efficiently.},
	Address = {Beaverton, Oregon, USA},
	Annote = {notrefereed},
	Author = {Nathanael Sch\"arli and Andrew P. Black},
	Cvs = {TraitsBrowserESUG2003},
	Institution = {OGI School of Science \& Engineering},
	Keywords = {snf-redundant scg-pub skip-doi scg-traits scg-none jb03 schaerli},
	Misc = {schaerli},
	Month = apr,
	Number = {CSE-03-008},
	Title = {A Browser for Incremental Programming},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Scha03bTraitsBrowser.pdf},
	Year = {2003},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Scha03bTraitsBrowser.pdf}}

@inproceedings{Scha04a,
	Abstract = {Given the importance of encapsulation to
				  object-oriented programming, it is surprising to
				  note that mainstream object-oriented languages offer
				  only limited and fixed ways of encapsulating
				  methods. Typically one may only address two
				  categories of clients, users and heirs, and one must
				  bind visibility and access rights at an early stage.
				  This can lead to inflexible and fragile code as well
				  as clumsy workarounds. We propose a simple and
				  general solution to this problem in which
				  encapsulation policies can be specified separately
				  from implementations. As such they become
				  first-class composable entities that can be reused
				  by different classes. We present a detailed analysis
				  of the problem with encapsulation and visibility
				  mechanisms in mainstream OO languages, we introduce
				  our approach in terms of a simple model, and we
				  evaluate how our approach compares with existing
				  approaches. We also assess the impact of
				  incorporating encapsulation policies into Smalltalk
				  and discuss some implementation issues.},
	Acceptnum = {25},
	Accepttotal = {132},
	Annote = {internationalconference topconference},
	Author = {Nathanael Sch\"arli and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
	Booktitle = {Proceedings of European Conference on Object-Oriented Programming (ECOOP'04)},
	Cvs = {EncapsulationPoliciesECOOP2004},
	Doi = {10.1007/b98195},
	Isbn = {978-3-540-22159-3},
	Keywords = {snf04 scg-pub scg-none jb04 scg-traits stefPub schaerli},
	Misc = {acceptance rate: 25/132 = 19\%},
	Month = jun,
	Pages = {26--50},
	Publisher = {Springer Verlag},
	Series = {LNCS},
	Title = {Composable Encapsulation Policies},
	Url = {http://scg.unibe.ch/archive/papers/Scha04aEncapsulationPolicies.pdf},
	Volume = {3086},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Scha04aEncapsulationPolicies.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/b98195}}

@inproceedings{Scha04b,
	Abstract = {Encapsulation in object-oriented languages has
				  traditionally been based on static type systems. As
				  a consequence, dynamically-typed languages have only
				  limited support for encapsulation. This is
				  surprising, considering that encapsulation is one of
				  the most fundamental and important concepts behind
				  object-oriented programming and that it is essential
				  for writing programs that are maintainable and
				  reliable, and that remain robust as they evolve. In
				  this paper we describe the problems that are caused
				  by insufficient encapsulation mechanisms and then
				  present object-oriented encapsulation, a simple and
				  uniform approach that solves these problems by
				  bringing state of the art encapsulation features to
				  dynamically typed languages. We provide a detailed
				  discussion of our design rationales and compare them
				  and their consequences to the encapsulation
				  approaches used for statically typed languages. We
				  also describe an implementation of object-oriented
				  encapsulation in Smalltalk. Benchmarks show that
				  extensive use of objectoriented encapsulation
				  results in a slowdown of less than 15 per cent.},
	Acceptnum = {27},
	Accepttotal = {174},
	Annote = {internationalconference topconference},
	Author = {Nathanael Sch\"arli and Andrew P. Black and St\'ephane Ducasse},
	Booktitle = {Proceedings of 18th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'04)},
	Cvs = {OOEncapsulationOOPSLA2004},
	Doi = {10.1145/1028976.1028988},
	Keywords = {snf05 scg-pub scg-none jb03 scg-traits stefPub schaerli},
	Misc = {acceptance rate: 27/174 = 16\%},
	Month = oct,
	Pages = {130--149},
	Title = {Object-oriented Encapsulation for Dynamically Typed Languages},
	Url = {http://scg.unibe.ch/archive/papers/Scha04bOOEncapsulation.pdf},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Scha04bOOEncapsulation.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1028976.1028988}}

@article{Scha04c,
	Abstract = {Much of the elegance and power of Smalltalk comes
				  from its programming environment and tools. First
				  introduced more than 20 years ago, the Smalltalk
				  browser enables programmers to ``home in'' on
				  particular methods using a hierarchy of
				  manually-defined classifications. By its nature,
				  this classification scheme says a lot about the
				  desired state of the code, but little about the
				  actual state of the code as it is being developed.
				  We have extended the Smalltalk browser with
				  dynamically computed virtual categories that
				  dramatically improve the browser's support for
				  incremental programming. We illustrate these
				  improvements by example, and describe the algorithms
				  used to compute the virtual categories efficiently.},
	Author = {Nathanael Sch\"arli and Andrew P. Black},
	Cvs = {TraitsBrowserESUG2003},
	Doi = {10.1016/j.cl.2003.09.004},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {scg-pub scg-none jb04 scg-traits snf04 schaerli},
	Misc = {schaerli},
	Number = {1-2},
	Pages = {79--95},
	Publisher = {Elsevier},
	Title = {A Browser for Incremental Programming},
	Url = {http://scg.unibe.ch/archive/papers/Scha04cBrowser.pdf},
	Volume = {30},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Scha04cBrowser.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.cl.2003.09.004}}

@inproceedings{Sche13a,
	Annote = {internationalworkshop},
	Abstract = {By analyzing the transactions in Stack Overflow we can get a glimpse of the way in which the different geographical regions in the world contribute to the knowledge market represented by the website. In this paper we aggregate the knowledge transfer from the level of the users to the level of geographical regions and learn that Europe and North America are the principal and virtually equal contributors; Asia comes as a distant third, mainly represented by India; and Oceania contributes less than Asia but more than South America and Africa together.},
	Author = {Schenk, Dennis and Lungu, Mircea},
	Booktitle = {Proceedings of the 5th International Workshop on Social Software Engineering},
	Keywords = {StackOverflow scg-pub snf-asa1 scg13 lungu skip-doi jb14},
	Medium = {2},
	Pages = {21--24},
	Peerreview = {yes},
	Title = {Geo-Locating the Knowledge Transfer in StackOverflow},
	Url = {http://scg.unibe.ch/archive/papers/Sche13a-GeolocatingStackOverflow.pdf},
	Year = {2013},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Sche13a-GeolocatingStackOverflow.pdf}}

@techreport{Schn96a,
	Abstract = {For the development of present-day applications,
				  programming languages supporting high order
				  abstractions are needed. These high order
				  abstractions are called components. Since most of
				  the currently available programming languages and
				  systems fail to provide sufficient support for
				  specifying and implementing components, we are
				  developing a new language suitable for software
				  composition. It is not clear how such a language
				  will look like, what kind of abstractions it must
				  support, and what kind of formal model it will be
				  based on. Object-oriented programming languages
				  address some of the needs of present-day
				  applications, and it is therefore obvious to
				  integrate some of their concepts and abstractions in
				  the language. As a first step towards such an
				  integration, we have to define an object model.
				  Since no generally accepted formal object model
				  exists, we have chosen the Pi-calculus as a basis
				  for modelling. In order to find a suitable object
				  model, we have built up an object modelling
				  workbench for Pict, an implementation of an
				  asynchronous Pi-calculus. In this work, we define a
				  first abstract object model, describe several
				  implementations of the object model in Pict, and
				  discuss interesting features and possible
				  extensions.},
	Author = {Jean-Guy Schneider and Markus Lumpe},
	Institution = {University of Bern, Institute of Computer Science and Applied Mathematics},
	Keywords = {olit scglit oobib scg-pub skip-doi snf95 scg-none jb96 scg-coord-old},
	Month = jan,
	Number = {IAM-96-004},
	Title = {Modelling Objects in {PICT}},
	Url = {http://scg.unibe.ch/archive/software/OOPICT/pictObjM.pdf http://scg.unibe.ch/archive/software/OOPICT/index.html},
	Year = {1996},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/software/OOPICT/pictObjM.pdf%20http://scg.unibe.ch/archive/software/OOPICT/index.html}}

@inproceedings{Schn97a,
	Abstract = {The development of concurrent object-based
				  programming languages has suffered from the lack of
				  any generally accepted formal foundation for
				  defining their semantics. Therefore we are seeking
				  for a minimal semantic foundation for defining
				  features of concurrent object-based languages. Our
				  previous work has shown that the Pi-calculus is a
				  promising formal foundation for modelling objects,
				  and we have defined an object model integrating
				  common features of object-oriented programming
				  languages. Our goal is to define a black-box
				  framework for modelling objects. As a first
				  extension of our Pi-calculus based object model, we
				  present in this work the integration of abstractions
				  for synchronizing concurrent objects. Our results
				  show that objects are most easily synchronized when
				  synchronization policies are reified as first class
				  entities (i.e. metaobjects) and that McHale's
				  concept of ``generic synchronization policies''
				  forms a promising base for the definition of
				  higher-level, reusable synchronization
				  abstractions.},
	Address = {Roscoff},
	Author = {Jean-Guy Schneider and Markus Lumpe},
	Booktitle = {Proceedings of Langages et Mod\`eles \`a Objets '97},
	Editor = {Roland Ducournau and Serge Garlatti},
	Isbn = {2-86601-650-5},
	Keywords = {scg-pub skip-doi pict pi olit lmo97 snf96 scg-none jb97 scg-coord-98},
	Month = oct,
	Pages = {61--76},
	Publisher = {Hermes},
	Title = {Synchronizing Concurrent Objects in the Pi-Calculus},
	Url = {http://scg.unibe.ch/archive/papers/Schn97aSyncConcObjPi.pdf},
	Year = {1997},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Schn97aSyncConcObjPi.pdf}}

@incollection{Schn99b,
	Abstract = {Experience has shown us that object-oriented
				  technology alone is not enough to guarantee that the
				  systems we develop will be flexible and adaptable.
				  Even ``well-designed'' object-oriented software may
				  be difficult to understand and adapt to new
				  requirements. We propose a conceptual framework that
				  will help yield more flexible object-oriented
				  systems by encouraging explicit separation of
				  computational and compositional elements. We
				  distinguish between components that adhere to an
				  architectural style, scripts that specify
				  compositions, and glue that may be needed to adapt
				  components' interfaces and contracts. We also
				  discuss a prototype of an experimental composition
				  language called Piccola that attempts to combine
				  proven ideas from scripting languages, coordination
				  models and languages, glue techniques, and
				  architectural specification.},
	Author = {Jean-Guy Schneider and Oscar Nierstrasz},
	Booktitle = {Software Architectures --- Advances and Applications},
	Editor = {Leonor Barroca and Jon Hall and Patrick Hall},
	Isbn = {1-85233-636-6},
	Keywords = {scg-pub skip-doi scripting glue architectures sa cose snf98 csg99 omnrep scg-coord-99 piccola scg-none jb99 onhindex(108)},
	Pages = {13--25},
	Publisher = {Springer-Verlag},
	Title = {Components, Scripts and Glue},
	Url = {http://scg.unibe.ch/archive/papers/Schn99bComptsScriptsAndGlue.pdf},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Schn99bComptsScriptsAndGlue.pdf}}

@inproceedings{Schn00a,
	Abstract = {The development of flexible and reusable concurrent
				  object-oriented programming abstractions has
				  suffered from the inherent problem that reusability
				  and extensibility is limited due to
				  position-dependent parameters. To tackle this
				  problem, we propose the Form-calculus, an inherently
				  polymorphic variant of the Pi-calculus, where
				  polyadic tuple communication is replaced by monadic
				  communication of extensible records. This approach
				  facilitates the specification of flexible,
				  concurrent, object-oriented programming
				  abstractions. Based on our previous work in this
				  field, we present a Form-calculus based meta-level
				  approach for concurrent, object-based programming
				  which adapts a compositional view of programming.
				  This approach enables the definition of various
				  semantic models supporting different kinds of
				  inheritance and method dispatch strategies, and
				  clarifies concepts which are typically merged in
				  existing object-oriented programming languages.},
	Address = {Mont Saint-Hilaire, Qu{\'e}bec},
	Author = {Schneider, Jean-Guy and Lumpe, Markus},
	Booktitle = {Proceedings of Langages et Mod{\`e}les {\`a} Objets '00},
	Editor = {Dony, Christophe and Sahraoui, Houari A.},
	Isbn = {ISBN 2-7462-0093-7},
	Keywords = {scg-pub skip-doi olit concurrency pi models snf99 lmo00 scg-none jb01},
	Location = {Privat},
	Month = jan,
	Pages = {149--165},
	Publisher = {Hermes},
	Title = {{A Metamodel for Concurrent, Object-based Programming}},
	Url = {http://scg.unibe.ch/archive/papers/Schn00aMetamodelForOBCP.pdf},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Schn00aMetamodelForOBCP.pdf}}

@incollection{Schn01b,
	Abstract = {In this chapter, it is not our goal to focus on
				  basic coordination models and abstractions of
				  scripting languages alone. We would like to view
				  coordination from a different perspective, set the
				  relation to other approaches which aim at separating
				  independent concerns into deployable entities, in
				  particular to component-based software development,
				  and discuss the influence of scripting on building
				  applications as assemblies of these entities.
				  Furthermore, we would like to stress the fact that
				  scripting languages do not only allow us to
				  coordinate distributed agents, but also to implement
				  the agents themselves as scripts.},
	Author = {Jean-Guy Schneider and Markus Lumpe and Oscar Nierstrasz},
	Booktitle = {Coordination of Internet Agents},
	Editor = {Andrea Omicini and Franco Zambonelli and Matthias Klusch and Robert Tolksdorf},
	Isbn = {3-540-41613-7},
	Keywords = {scg-pub skip-doi scripting glue architectures scg-none jb01 snf02},
	Pages = {153--175},
	Publisher = {Springer-Verlag},
	Title = {Agent Coordination via Scripting Languages},
	Url = {http://scg.unibe.ch/archive/papers/Schn01bAgentCoordination.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Schn01bAgentCoordination.pdf}}

@inproceedings{Schn16a,
	Author    = {Teseo Schneider and Yuriy Tymchuk and Ronie Salgado and Alexandre Bergel},
	Title     = {{CuboidMatrix}: Exploring Dynamic Structural Connections in Software Components using Space-Time Cube},
	Booktitle = {{VISSOFT}'16: Proceedings of the 4th IEEE Working Conference on Software Visualization},
	Abstract  = {Static and dynamic evolution of software systems may be described in terms of connection additions and removals in a graph.
Due to the inherent complexity of software, navigating through such a dynamic network is a non-trivial task and extracting relevant information typically involves sophisticated queries.
We explore the notion of space-time cube, a well-known 3D representation of an evolving dynamic graph, to support a set of software engineering activities. CuboidMatrix is a visualization tool that offers simple and expressive navigation operations. We have evaluated our tool against two software comprehension activities, namely (i) assessing interaction of classes during a software execution and (ii) exploring the cause of breaking Lint-like quality rules over a large number of software revisions.},
	Annote 	  = {internationalconference},
	Publisher = {IEEE},
	PeerReview = {yes},
	Medium    = {2},
	Keywords  = {scg-pub snf-asa2 scg16 jb16 tymchuk},
	Year      = {2016},
	Url       = {http://scg.unibe.ch/archive/papers/Schn16a.pdf},
	DOI       = {10.1109/VISSOFT.2016.17},
	pages     = {116--125}
}

@incollection{Schu12a,
	Abstract = {Nowadays, a slew of clone detection approaches exists, producing a lot of clone data. These data have to be analyzed manually or automatically. It is not trivial to derive conclusions or even actions from the analyzed data. In particular, we argue that it is often unclear how to present the clone information to the user. As a result, we present our idea of task-oriented clone presentation based on use cases. Hence, we propose five use cases that have to be addressed and suggest clone presentation techniques that we consider to be appropriate.},
	Author = {Sandro Schulze and Niko Schwarz},
	Booktitle = {Software Clone Management Towards Industrial Application (Dagstuhl Seminar 12071)},
	Editor = {Rainer Koschke and Ira D. Baxter and Michael Conradt and James R. Cordy},
	Issn = {2192-5283},
	Journal = {Dagstuhl Reports},
	Keywords = {skip-doi scg-bigdata scg-pub snf12 jb12 scg12},
	Medium = {2},
	Month = jun,
	Pages = {35--38},
	Peerreview = {yes},
	Publisher = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
	Title = {How to Make the Hidden Visible --- Code Clone Presentation Revisited},
	Url = {http://scg.unibe.ch/archive/papers/Schu12a-clone-representation.pdf},
	Volume = {2},
	Year = {2012},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Schu12a-clone-representation.pdf}}

@inproceedings{Schw10b,
	Abstract = {Code duplication is common in current
				  programming-practice: programmers search for
				  snippets of code, incorporate them into their
				  projects and then modify them to their needs. In
				  today's practice, no automated scheme is in place to
				  inform both parties of any distant changes of the
				  code. As code snippets continues to evolve both on
				  the side of the user and on the side of the author,
				  both may wish to benefit from remote bug fixes or
				  refinements --- authors may be interested in the
				  actual usage of their code snippets, and researchers
				  could gather information on clone usage. We propose
				  maintaining a link between software clones across
				  repositories and outline how the links can be
				  created and maintained.},
	Address = {New York, NY, USA},
	Annote = {internationalworkshop},
	Author = {Niko Schwarz and Erwann Wernli and Adrian Kuhn},
	Booktitle = {IWSC '10: Proceedings of the 4th International Workshop on Software Clones},
	Date-Added = {2010-04-26 16:10:08 +0200},
	Date-Modified = {2010-04-26 16:12:27 +0200},
	Doi = {10.1145/1808901.1808915},
	Isbn = {978-1-60558-980-0},
	Keywords = {scg-pub scg10 snf10 jb10 nes, software clones, software evolution, software repositories, forking, position paper},
	Location = {Cape Town, South Africa},
	Medium = {1},
	Month = apr,
	Pages = {81--82},
	Peerreview = {yes},
	Publisher = {ACM},
	Title = {Hot Clones, Maintaining a Link Between Software Clones Across Repositories},
	Url = {http://scg.unibe.ch/archive/papers/Schw10b-hot-clones.pdf},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Schw10b-hot-clones.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1808901.1808915}}

@inproceedings{Schw11a,
	Abstract = {Unit testing is often made more difficult by the heavy use of classes as namespaces and the
		proliferation of class methods to encapsulate configuration code. We have analyzed the use of 120
		class methods from 96 projects by categorizing them according to their responsibilities. We find
		that most class methods support a hodgepodge of mixed responsibilities, held together only by
		their common need to be globally visible. Tight coupling between instances and their classes
		breaks encapsulation, and, together with the global visibility of class methods, complicates
		testing. By making dependency injection a feature of the programming language, we can get rid of
		class methods altogether. We employ the following semantic changes: (1) Replace every occurrence
		of a global with an access to an instance variable; (2) Let that instance variable be
		automatically injected into the object when it is instantiated. We present Seuss, a prototype that
		implements this change of semantics in Smalltalk. We show how Seuss eliminates the need to use
		class methods for non-reflective purposes, reduces the need for many design patterns, such as
		Abstract Factory, and simplifies configuration code, particularly for unit tests. },
	Annote = {internationalconference},
	Author = {Niko Schwarz and Mircea Lungu and Oscar Nierstrasz},
	Booktitle = {Objects, Components, Models and Patterns, Proceedings of TOOLS Europe 2011},
	Doi = {10.1007/978-3-642-21952-8_20},
	Keywords = {scg1 scg-pub scg11 jb11 snf11 ercim11},
	Medium = {2},
	Pages = {276--289},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Seuss: Cleaning up Class Responsibilities with Language-based Dependency Injection},
	Url = {http://scg.unibe.ch/archive/papers/Schw11aSeuss.pdf},
	Volume = {33},
	Year = {2011},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Schw11aSeuss.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/978-3-642-21952-8_20}}

@inproceedings{Schw11b,
	Abstract = {Developers override  toString() and  printOn: methods to allow objects to display themselves.
This is done to track object state while debugging.
Although very popular, the technique breaks down when displaying complex, mul\-ti\--di\-mension\-al objects.
We propose an approach in which objects have two-\-di\-men\-sion\-al visualizations at various levels of granularity. This makes it easier to compose visualizations from object parts, and enables ``semantic zooming'' of object visualizations while debugging.
We have carried out an empirical study to understand how printOn: methods are used in practice, and we are developing DoodleDebug, a framework to support visualizable objects.},
	Annote = {internationalworkshop},
	Author = {Niko Schwarz},
	Booktitle = {Proceedings of the TOOLS 2011, 5th Workshop on Dynamic Languages and Applications (DYLA'11).},
	Keywords = {scg11 scg-pub nes snf11 jb11 skip-doi},
	Medium = {4},
	Peerreview = {yes},
	Title = {{DoodleDebug}, Objects Should Sketch Themselves For Code Understanding},
	Url = {http://scg.unibe.ch/archive/papers/Schw11bDoodleDebug.pdf},
	Year = {2011},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Schw11bDoodleDebug.pdf}}

@inproceedings{Schw12a,
	Abstract = {Detecting code duplication in large code bases, or even across project boundaries, is problematic due to the massive amount of data involved. Large-scale clone detection also opens new challenges beyond asking for the provenance of a single clone fragment, such as assessing the prevalence of code clones on the entire code base, and their evolution.   We propose a set of lightweight techniques that may scale up to very large amounts of source code in the presence of multiple versions. The common idea behind these techniques is to use bad hashing to get a quick answer. We report on a case study, the Squeaksource ecosystem, which features thousands of software projects, with more than 40 million versions of methods, across more than seven years of evolution. We provide estimates for the prevalence of type-1, type-2, and type-3 clones in Squeaksource.},
	Address = {Piscataway, NJ, USA},
	Annote = {internationalconference},
	Author = {Schwarz, Niko and Lungu, Mircea and Robbes, Romain},
	Booktitle = {Proceedings of the 2012 International Conference on Software Engineering},
	Isbn = {978-1-4673-1067-3},
	Keywords = {scg-bigdata scg-pub snf12 jb12 scg12},
	Location = {Zurich, Switzerland},
	Medium = {2},
	Pages = {1289--1292},
	Peerreview = {yes},
	Priority = {2},
	Publisher = {IEEE Press},
	Series = {ICSE 2012},
	Title = {On how often code is cloned across repositories},
	Url = {http://scg.unibe.ch/archive/papers/Schw12a-scalable-clones.pdf},
	doi = {10.1109/ICSE.2012.6227097},
	Year = {2012},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Schw12a-scalable-clones.pdf}}

@article{Schw12b,
	Abstract = {Unit testing is often made more difficult by the heavy use of classes as namespaces and the proliferation of static methods to encapsulate configuration code. We have analyzed the use of 120 static methods from 96 projects by categorizing them according to their responsibilities. We find that most static methods support a hodgepodge of mixed responsibilities, held together only by their common need to be globally visible. Tight coupling between instances and their classes breaks encapsulation, and, together with the global visibility of static methods, complicates testing. By making dependency injection a feature of the programming language, we can get rid of static methods altogether. We employ the following semantic changes: (1) Replace every occurrence of a global with an access to an instance variable; (2) Let that instance variable be automatically injected into the object when it is instantiated. We present Seuss, a prototype that implements this change of semantics in Smalltalk. We show how Seuss eliminates the need to use class methods for non-reflective purposes, reduces the need for creational design patterns such as Abstract Factory and simplifies configuration code, particularly for unit tests. We present benchmarks showing that Seuss introduces a 34 % additional memory cost, and runs at 53 % speed, without any optimizations.},
	Annote = {internationaljournal},
	Author = {Niko Schwarz and Mircea Lungu and Oscar Nierstrasz},
	Doi = {10.5381/jot.2012.11.1.a3},
	Journal = {Journal of Object Technology},
	Keywords = {scg-pub jb12 snf12 scg12},
	Medium = {1},
	Number = {1},
	Peerreview = {yes},
	Title = {Seuss: Decoupling responsibilities from static methods for fine-grained configurability},
	Url = {http://www.jot.fm/issues/issue_2012_04/article3.pdf},
	Volume = {11},
	Year = {2012},
	Bdsk-Url-1 = {http://www.jot.fm/issues/issue_2012_04/article3.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.5381/jot.2012.11.1.a3}}

@inproceedings{Schw12c,
	Abstract = {Code duplication is common in current programming-practice: programmers search for snippets of code, incorporate them into their projects and then modify them to their needs. In today's practice, no automated scheme is in place to inform both parties of any distant changes of the code. As code snippets continue to evolve both on the side of the user and on the side of the author, both may wish to benefit from remote bug fixes or refinements -S authors may be interested in the actual usage of their code snippets, and researchers could gather information on clone usage. We propose to maintain a link between software clones across repositories and outline how the links can be created and maintained.},
	Annote = {internationalconference},
	Author = {Schwarz, Niko},
	Booktitle = {2012 34th International Conference on Software Engineering (ICSE)},
	Doi = {10.1109/ICSE.2012.6227221},
	Isbn = {978-1-4673-1067-3},
	Keywords = {scg-bigdata scg-pub jb12 snf12 scg12},
	Location = {Zurich, Switzerland},
	Medium = {2},
	Month = jun,
	Pages = {1628--1629},
	Peerreview = {yes},
	Posted-At = {2012-07-28 15:07:10},
	Priority = {2},
	Publisher = {IEEE},
	Title = {Hot clones: Combining search-driven development, clone management, and code provenance},
	Url = {http://scg.unibe.ch/archive/papers/Schw12c-clones-provenance.pdf},
	Year = {2012},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Schw12c-clones-provenance.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICSE.2012.6227221}}

@inproceedings{Schw12d,
	Abstract = {Code duplication is common in current programming-practice: programmers search for snippets of code, incorporate them into their projects and then modify them to their needs. In today's practice, no automated scheme is in place to inform both parties of any distant changes of the code. As code snippets continue to evolve both on the side of the user and on the side of the author, both may wish to benefit from remote bug fixes or refinements - authors may be interested in the actual usage of their code snippets, and researchers could gather information on clone usage. We propose to maintain a link between software clones across repositories and outline how the links can be created and maintained.},
	Address = {Los Alamitos, CA, USA},
	Annote = {internationalconference},
	Author = {Schwarz, Niko},
	Booktitle = {2012 16th European Conference on Software Maintenance and Reengineering},
	Doi = {10.1109/CSMR.2012.67},
	Isbn = {978-0-7695-4666-7},
	Issn = {1534-5351},
	Journal = {Software Maintenance and Reengineering, European Conference on},
	Keywords = {scg-bigdata scg-pub jb12 snf12 scg12},
	Location = {Szeged, Hungary},
	Medium = {2},
	Month = mar,
	Pages = {513--515},
	Peerreview = {yes},
	Posted-At = {2012-07-28 15:09:11},
	Priority = {2},
	Publisher = {IEEE},
	Title = {Hot Clones: A Shotgun Marriage of {Search-Driven} Development and Clone Management},
	Url = {http://dx.doi.org/10.1109/CSMR.2012.67},
	Volume = {0},
	Year = {2012},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/CSMR.2012.67}}

@inproceedings{Senf18a,
	author={Senft, Bj{\"o}rn and Fischer, Holger and Oberth{\"u}r, Simon and Patkar, Nitish},
	booktitle={International Conference of Design, User Experience, and Usability},
	title={Assist Users to Straightaway Suggest and Describe Experienced Problems},
	year={2018},
	annote={internationalconference},
	peerreview={yes},
	medium={2},
	doi={10.1007/978-3-319-91797-9_52},
	abstract={Requirements elicitation plays a vital role in building effective software. Incorrect or incomplete requirements lead to erroneous software and costs a huge amount of rework. Rework costs in terms of money and efforts are usually higher than the early detection of potential flaws in the requirements. This happens because most of the techniques employed to extract requirements fail to understand end user goals. Understanding your users and their goals is important to build a capable, viable and desirable product or software system. This paper attempts to suggest and evaluate an alternative approach to understand your potential users and their goals so that correct and complete requirements can be formulated resulting in a successful software. We introduce the concept of a tool-guided elicitation process, classify elicitation techniques in term of their suitability in such a tool-guided process, and present an initial study of the usability und usefulness of our prototype called Vision Backlog.},
	keywords={scg-pub skip-pdf scg-none snf-none jb-none},
	organization={Springer},
	pages={758--770}}

@inproceedings{Spas14a,
	Annote = {internationalworkshop},
	Abstract = {Software developers are often unsure of the exact name of the method
	they need to use to invoke the desired behavior in a given context. This results
	in a process of searching for the correct method name in documentation, which can
	be lengthy and distracting to the developer.
	We can decrease the method search time by enhancing the documentation of a class
	with the most frequently used methods. Usage frequency data for methods is gathered
	by analyzing other projects from the same ecosystem - written in the same language
	and sharing dependencies.
	We implemented a proof of concept of the approach for Pharo Smalltalk and Java. In
	Pharo Smalltalk, methods are commonly searched for using a code browser tool called
	"Nautilus", and in Java using a web browser displaying HTML based documentation -
	Javadoc. We developed plugins for both browsers and gathered method usage data from
	open source projects, in order to increase developer productivity by reducing method
	search time.
	A small initial evaluation has been conducted showing promising results in improving
	developer productivity.},
	author = {Spasojevi\'{c}, Boris and Lungu, Mircea and Nierstrasz, Oscar},
 	title = {Towards Faster Method Search Through Static Ecosystem Analysis},
 	booktitle = {Proceedings of the 2014 European Conference on Software Architecture Workshops},
	Keywords = {scg-pub snf-asa1 scg14 jb14 internationalworkshop scg-bigdata Spasojevic},
	PeerReview = {yes},
	Medium = {1},
	series = {ECSAW '14},
 	year = {2014},
 	isbn = {978-1-4503-2778-7},
 	location = {Vienna, Austria},
 	pages = {11:1--11:6},
 	articleno = {11},
 	numpages = {6},
 	acmid = {2642814},
 	address = {New York, NY, USA},
	Month = aug,
	Publisher = {ACM},
	Location = {Vienna, Austria},
	Doi = {10.1145/2642803.2642814},
	Url = {http://scg.unibe.ch/archive/papers/Spas14aFasterMethodLookup.pdf}}

@inproceedings{Spas14b,
	Annote = {internationalconference},
	Abstract = {Software developers are often unsure of the exact name of the API method they need to use to invoke the desired behavior. Most state-of-the-art documentation browsers present API artefacts in alphabetical order. Albeit easy to implement, alphabetical order does not help much: if the developer knew the name of the required method, he could have just searched for it in the first place. In a context where multiple projects use the same API, and their source code is available, we can improve the API presentation by organizing the elements in the order in which they are more likely to be used by the developer. Usage frequency data for methods is gathered by analyzing other projects from the same ecosystem and this data is used then to improve tools. We present a preliminary study on the potential of this approach to improve the API presentation by reducing the time it takes to find the method that implements a given feature. We also briefly present our experience with two proof-of-concept tools implemented for Smalltalk and Java.},
	author = {Spasojevi\'{c}, Boris and Lungu, Mircea and Nierstrasz, Oscar},
	Booktitle = {2014 IEEE International Conference on Software Maintenance and Evolution (ERA Track)},
	Doi = {10.1109/ICSME.2014.84},
	Keywords = {scg14 jb15; scg-pub snf-asa1; scg-bigdata Spasojevic},
	Medium = {2},
	Month = sep,
	Pages = {511-515},
	Title = {Overthrowing the Tyranny of Alphabetical Ordering in Documentation Systems},
	Url = {http://scg.unibe.ch/archive/papers/Spas14b.pdf},
	Year = {2014},
	PeerReview = {yes}}

@inproceedings{Spas14c,
	Annote = {internationalconference},
	Abstract = {Dynamically typed languages lack information about the types of variables in the source code. Developers care about this information as it supports program comprehension. Ba- sic type inference techniques are helpful, but may yield many false positives or negatives. We propose to mine information from the software ecosys- tem on how frequently given types are inferred unambigu- ously to improve the quality of type inference for a single system. This paper presents an approach to augment existing type inference techniques by supplementing the informa- tion available in the source code of a project with data from other projects written in the same language. For all available projects, we track how often messages are sent to instance variables throughout the source code. Predictions for the type of a variable are made based on the messages sent to it. The evaluation of a proof-of-concept prototype shows that this approach works well for types that are sufficiently popular, like those from the standard librarie, and tends to create false positives for unpopular or domain specific types. The false positives are, in most cases, fairly easily identifiable. Also, the evaluation data shows a substantial increase in the number of correctly inferred types when compared to the non-augmented type inference.},
	Address = {New York, NY, USA},
	author = {Spasojevi\'{c}, Boris and Lungu, Mircea and Nierstrasz, Oscar},
	booktitle = {Proceedings of the 2014 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
	series = {Onward! '14},
	isbn = {978-1-4503-3210-1},
	Doi = {10.1145/2661136.2661141},
	Keywords = {scg14 jb15; scg-pub snf-asa1; scg-bigdata; Ecosystem Mining; Type Inference Spasojevic},
	PeerReview = {yes},
	Medium = {2},
	location = {Portland, Oregon, USA},
	acmid = {2661141},
	pages = {133--142},
	Numpages = {10},
	Publisher = {ACM},
	Title = {Mining the Ecosystem to Improve Type Inference For Dynamically Typed Languages},
	Url = {http://scg.unibe.ch/archive/papers/Spas14c.pdf},
	Year = {2014}}

@inproceedings{Spas16a,
	Annote = {internationalconference},
	Author = {Spasojevi\'{c}, Boris and Lungu, Mircea and Nierstrasz, Oscar},
	Title = {A Case Study on Type Hints in Method Argument Names in {Pharo} {Smalltalk} Projects},
	Abstract = {A common practice when writing Smalltalk source code is to name method arguments in a way that hints at their expected type (i.e., aString, anInteger, aDictionary). This practice makes code more readable, but the prevalence of this practice is unknown, thus its reliability is questionable. Tools such as the auto complete feature in the Pharo Smalltalk code editor rely on these hints to improve the developer experience. The default algorithm used in Pharo to extract type information from these hints succeeds in extracting a type in slightly over 36% of method arguments taken from 114 Pharo projects. In this paper we present the results of analyzing the failing method argument names, and provide several simple heuristics that can increase the rate of success to slightly over 50%. We also present a case study on the relation between type hints and run-time types of method arguments that shows that type hints, in a great majority of cases, reflect run-time types.},
	Booktitle = {Proceedings of the 23rd IEEE International Conference on Software Analysis, Evolution, and Reengineering (SANER)},
	PeerReview = {yes},
	Medium = {2},
	volume={1},
	pages={283-292},
	Year = {2016},
	month=mar,
	Keywords = {scg-pub snf-asa1 scg16 jb16 Spasojevic},
	doi={10.1109/SANER.2016.41},
	Url = {http://scg.unibe.ch/archive/papers/Spas16a.pdf}
}

@inproceedings{Spas16b,
	Abstract = {In this paper we propose the idea of constructing an Object Repository -- a repository of code snippets that, when executed, produce an instance of some class. Such a repository may be useful for several software engineering tasks like augmenting software documentation, testing object inspectors, improving program comprehension etc.
	We mine code snippets from existing software systems via brute force execution of code segments obtained through converting AST nodes of methods to source code. The gathered snippets are known to be executable, and this is a novelty which is not possible with existing approaches.
	We show that applying the proposed approach to 141 open source Pharo projects results in an Object Repository that can instantiate almost 80\% of the available classes in these projects.},
	Annote = {internationalworkshop},
	Author = {Boris Spasojevi\'{c} and Mohammad Ghafari and Oscar Nierstrasz},
	Title = {The {Object Repository}, Pulling Objects out of the Ecosystem},
	Booktitle = {Proceedings of the 11th Edition of the International Workshop on Smalltalk Technologies},
	Series = {IWST'16},
	Year = {2016},
	isbn = {978-1-4503-4524-8},
	location = {Prague, Czech Republic},
	pages = {7:1--7:10},
	articleno = {7},
	numpages = {10},
	Url = {http://scg.unibe.ch/archive/papers/Spas16b.pdf},
	doi = {10.1145/2991041.2991048},
	acmid = {2991048},
	publisher = {ACM},
	address = {New York, NY, USA},
	Keywords = {scg16 scg-pub jb16 snf-asa2 spasojevic, Ecosystem Analysis, Ecosystem Mining, Object Repository},
	Peerreview = {yes}
}

@inproceedings{Spas16c,
	Annote = {internationalworkshop},
	Author = {Boris Spasojevi\'{c}},
	Abstract = {Integrating ecosystem data into developer tools can be very beneficial but is usually complicated. By automating the routine parts of this task we can reduce the amount of work needed to develop these tools. We have developed a framework that allows developers to quickly develop new tools that use ecosystem data. This framework automates the execution of user-defined analyses on ecosystem projects, allowing the developer to focus only on what ecosystem data is needed for her tool and how to present it.},
	title = {Building Ecosystem-Aware Tools Using the Ecosystem Monitoring Framework},
	publisher = {{CEUR}},
	booktitle = {Post-proceedings of the 9th Seminar on Advanced Techniques and Tools for Software Evolution (SATToSE 2016)},
    Volume = {1791},
	year = {2016},
	month = jul,
	location = {Bergen, Norway},
	numpages = {8},
	PeerReview = {yes},
	Medium = {2},
	Keywords = {scg-pub snf-asa2 scg16 jb16 skip-doi spasojevic},
	Pdf = {http://ceur-ws.org/Vol-1791/paper-02.pdf},
	Url = {http://scg.unibe.ch/archive/papers/Spas16c.pdf}}

@inproceedings{Step09b,
	Abstract = {We present Maispion, a tool for analysing software
				  developer communities. The tool, developed in
				  Smalltalk, mines mailing list and version
				  repositories, and provides visualizations to provide
				  insights into the ecosystem of open source software
				  (OSS) development. We show how Maispion can analyze
				  the history of medium to large OSS communities, by
				  applying our tool to three well-known open source
				  projects: Moose, Drupal and Python.},
	Address = {New York, NY, USA},
	Annote = {internationalworkshop},
	Author = {Fran\c{c}ois Stephany and Tom Mens and Tudor G\^irba},
	Booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2009)},
	Doi = {10.1145/1735935.1735944},
	Isbn = {978-1-60558-899-5},
	Keywords = {jb10 hasler09 moose-pub scg10 scg-pub inprint girba evol11},
	Location = {Brest, France},
	Medium = {2},
	Pages = {50--57},
	Peerreview = {yes},
	Publisher = {ACM},
	Title = {Maispion: A Tool for Analysing and Visualizing Open Source Software Developer Communities},
	Url = {http://scg.unibe.ch/archive/papers/Step09bMaispion.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Step09bMaispion.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1735935.1735944}}

@inproceedings{Stul20b,
  title={Towards Detecting Inconsistent Comments in Java Source Code Automatically},
  author={Stulova, Nataliia and Blasi, Arianna and Gorla, Alessandra and Nierstrasz, Oscar},
  abstract={A number of tools are available to software developers to check consistency
		of source code during software evolution. However, none of these tools
		checks for consistency of the documentation accompanying the code. As a
		result, code and documentation often diverge, hindering program
		comprehension. This leads to errors in how developers use source code,
		especially in the case of APIs of reusable libraries. We propose a
		technique and a tool, upDoc, to automatically detect code-comment
		inconsistency during code evolution. Our technique builds a map between the
		code and its documentation, ensuring that changes in the code match the
		changes in respective documentation parts. We conduct a preliminary
		evaluation using inconsistency examples from an existing dataset of Java
		open source projects, showing that upDoc can successfully detect them. We
		present a roadmap for the further development of the technique and its
		evaluation.},
  booktitle={2020 IEEE 20th International Working Conference on Source Code Analysis and Manipulation (SCAM)},
  pages={65--69},
  year={2020},
  Keywords = {scg-pub snf-asa3 scg20 jb21},
  PeerReview = {yes},
  medium = {2},
  doi={10.1109/SCAM51674.2020.00012},
  url = {http://scg.unibe.ch/archive/papers/Stul20b-InconsistentComments.pdf},
  organization={IEEE}
}

@inproceedings{Syre15a,
	 abstract={Program comprehension requires developers to reason about many kinds of highly interconnected software entities. Dealing with this reality prompts developers to continuously intertwine searching and navigation. Nevertheless, most integrated development environments (IDEs) address searching by means of many disconnected search tools, making it difficult for developers to reuse search results produced by one search tool as input for another search tool. This forces developers to spend considerable time manually linking disconnected search results. To address this issue we propose Spotter, a model for expressing and combining search tools in a unified way. The current implementation shows that Spotter can unify a wide range of search tools. More information about Spotter can be found at scg.unibe.ch/research/moldablespotter},
	 author = {Aliaksei Syrel and Andrei Chi\c{s} and Tudor G\^irba and Juraj Kubelka and Oscar Nierstrasz and Stefan Reichhart},
	 title = {Spotter: towards a unified search interface in {IDEs}},
 	 booktitle = {Proceedings of the Companion Publication of the 2015 ACM SIGPLAN Conference on Systems, Programming, and Applications: Software for Humanity},
	 series = {SPLASH Companion 2015},
	 year = {2015},
	 location = {Pittsburgh, PA, USA},
	 pages = {54--55},
	 numpages = {2},
	 url = {http://scg.unibe.ch/archive/papers/Syre15a-SpotterPosterAbstract.pdf},
	 doi = {10.1145/2814189.2817269},
	 isbn = {978-1-4503-3722-9},
	 acmid = {2817269},
	 publisher = {ACM},
	 address = {New York, NY, USA},
	 keywords = {snf-asa1, scg-pub scg15 jb16, Andrei Chis, Tudor Girba, girba feenk-pub},
	 peerreview = {yes},
	 medium = {2}
}

@inproceedings{Tant06a,
	Abstract = {Context-aware applications behave differently
				  depending on the context in which they are running.
				  Since context-specific behavior tends to crosscut
				  base programs, it can advantageously be implemented
				  as aspects. This leads to the notion of
				  context-aware aspects, e.g., aspects whose behavior
				  depends on context. This paper analyzes the issue of
				  appropriate support from the aspect language to both
				  restrict the scope of aspects according to the
				  context and allow aspect definitions to access
				  information associated to the context. We propose an
				  open framework for context-aware aspects that allows
				  for the definition of first-class contexts and
				  supports the definition of context awareness
				  constructs for aspects, including the ability to
				  refer to past contexts, and to provide domain- and
				  application-specific constructs.},
	Address = {Vienna, Austria},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {{\'E}ric Tanter and Kris Gybels and Marcus Denker and Alexandre Bergel},
	Booktitle = {Proceedings of the 5th International Symposium on Software Composition (SC 2006)},
	Doi = {10.1007/11821946_15},
	Inria = {hors},
	Isbn = {978-3-540-37657-6},
	Keywords = {scg-pub scg-none jb06 fb06 snf06},
	Medium = {2},
	Month = mar,
	Pages = {227--242},
	Peerreview = {yes},
	Selectif = {non},
	Series = {LNCS},
	Title = {Context-Aware Aspects},
	Url = {http://scg.unibe.ch/archive/papers/Tant06aContextAspectsSC2006.pdf},
	Volume = {4089},
	Year = {2006},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Tant06aContextAspectsSC2006.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/11821946_15}}

@article{Teru15a,
	year={2015},
	abstract = {Scoping behavioral variations to dynamic extents is useful
		to support non-functional concerns that otherwise result in
		cross-cutting code. Unfortunately, such forms of scoping are difficult
		to obtain with traditional reflection or aspects. We propose delegation
		proxies, a dynamic proxy model that supports behavioral intercession
		through the interception of various interpretation operations.
		Delegation proxies permit different behavioral variations to be easily
		composed together. We show how delegation proxies enable behavioral
		variations that can propagate to dynamic extents. We demonstrate our
		approach with examples of behavioral variations scoped to dynamic
		extents that help simplify code related to safety, reliability, and
		monitoring.},
	isbn={978-3-662-46733-6},
	journal={Transactions on Aspect-Oriented Software Development XII},
	volume={8989},
	series={Lecture Notes in Computer Science},
	editor={Chiba, Shigeru and Tanter, \'{E}ric and Ernst, Erik and Hirschfeld, Robert},
	doi={10.1007/978-3-662-46734-3_2},
	title={Propagation of Behavioral Variations with Delegation Proxies},
	publisher={Springer Berlin Heidelberg},
	keywords={Reflection; Proxy; Delegation; Propagation; Dynamic extent},
	author={Teruel, Camille and Wernli, Erwann and Ducasse, St\'{e}phane and Nierstrasz, Oscar},
	pages={63-95},
	Keywords = {scg-pub snf-asa1 scg15 jb15},
	Annote = {internationaljournal},
	Peerreview = {yes},
	Medium = {2},
	Url = {http://scg.unibe.ch/archive/papers/Teru15a-delegation-proxies.pdf}
}

@inproceedings{Tich97b,
	Abstract = {In this workshop proposal we present a prototype
				  approach to help the extraction of architectural
				  information in the re-engineering process. Commonly,
				  the re-engineering life-cycle has been defined as a
				  succession of the following tasks: analysis of
				  requirements, model capture (understanding the
				  system), problem detection, problem analysis,
				  reorganization and change propagation. We have
				  evaluated the benefit of a prototyping approach with
				  a focus on model capture. Although prototyping is a
				  known approach to evaluate the application
				  feasibility, costs, comparison and validation of
				  choices, we focus in this paper on the aspects of
				  prototyping that are helpful for re-engineering.},
	Annote = {internationalworkshop},
	Author = {Sander Tichelaar and St\'ephane Ducasse and Theo-Dirk Meijler},
	Booktitle = {Proceedings of the ESEC/FSE Workshop on Object-Oriented Re-engineering},
	Editor = {Serge Demeyer and Harald Gall},
	Keywords = {olit famoos-papunr tich-papunr scglit oobib scg-pub skip-doi snf97 scg-none jb97 stePub},
	Month = sep,
	Note = {Technical Report TUV-1841-97-10},
	Publisher = {Technical University of Vienna, Information Systems Institute, Distributed Systems Group},
	Title = {Architectural Extraction In Reverse Engineering by Prototyping: An experiment},
	Url = {http://scg.unibe.ch/archive/papers/Tich97bArchExtraction.pdf},
	Year = {1997},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Tich97bArchExtraction.pdf}}

@inproceedings{Tich98m,
	Abstract = {Tools support is recognised as a key issue in the
				  reengineering of large scale object-oriented
				  systems. However, due to the heterogeneity in
				  today's object-oriented programming languages, it is
				  hard to reuse reengineering tools across legacy
				  systems. This paper proposes a language independent
				  exchange model, so that tools may perform their
				  tasks independent of the underlying programming
				  language. Beside supporting reusability between
				  tools, we expect that this exchange model will
				  enhance the interoperability between tools for
				  metrics, visualization, reorganisation and other
				  reengineering activities.},
	Author = {Sander Tichelaar and Serge Demeyer},
	Booktitle = {Object-Oriented Technology (ECOOP '98 Workshop Reader)},
	Editor = {Serge Demeyer and Jan Bosch},
	Keywords = {olit scg-pub skip-doi famoos-papunr sergedem-papunr tich-papunr snf98 scg-none jb98},
	Month = jul,
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {An Exchange Model for Reengineering Tools},
	Url = {http://scg.unibe.ch/archive/famoos/Tich98m/ecoop98exchmod.pdf},
	Volume = {1543},
	Year = {1998},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/famoos/Tich98m/ecoop98exchmod.pdf}}

@inproceedings{Tich99m,
	Abstract = {Nowadays development environments are required to be
				  open: users want to be able to work with a
				  combination of their preferred commercial and
				  home-grown tools. TakeFive has opened up SNiFF+ with
				  a so-called "Symbol Table API"; Rational has opened
				  up the UML tool Rose via the so-called "Rose
				  Extensibility Interface (REI)". On the other hand,
				  efforts are underway to define standards for
				  exchanging information between case-tools; CDIF
				  being a notable example. This paper reports on our
				  experience to generate UML diagrams in Rational Rose
				  from the symbol table in SNiFF+ using a standard
				  CDIF exchange format.},
	Author = {Sander Tichelaar and Serge Demeyer},
	Booktitle = {{SNiFF}+ User's Conference},
	Keywords = {olit scg-pub skip-doi famoos-papunr sergedem-papunr tich-papunr snf99 scg-none jb99},
	Month = jan,
	Note = {Also in the "Proceedings of the ESEC/FSE '99 Workshop on Object-Oriented Re-engineering (WOOR '99)" --- Technical Report of the Technical University of Vienna (TUV-1841-99-13)},
	Title = {{SNiFF}+ Talks to {Rational} {Rose} --- Interoperability using a Common Exchange Model},
	Url = {http://scg.unibe.ch/archive/papers/Tich99mSniffToRationalRose.pdf},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Tich99mSniffToRationalRose.pdf}}

@techreport{Tich99z,
	Abstract = {This document describes the language plug-in to the
				  FAMIX 2.0 model for the {Java} programming language.
				  It handles interpretation issues concerning {Java}
				  in FAMIX and the extension of the FAMIX model for
				  Jav specific features.},
	Author = {Sander Tichelaar},
	Institution = {University of Bern},
	Keywords = {scg-pub skip-doi scg-none jb-none olit famoos-techrep tich-techrep snf99 moose-pub},
	Month = sep,
	Title = {{FAMIX} {Java} language plug-in 1.0},
	Url = {http://scg.unibe.ch/archive/famoos/FAMIX/Plugins/JavaPlugin1.0.html http://scg.unibe.ch/archive/famoos/FAMIX/Plugins/JavaPlugin1.0.pdf},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/famoos/FAMIX/Plugins/JavaPlugin1.0.html%20http://scg.unibe.ch/archive/famoos/FAMIX/Plugins/JavaPlugin1.0.pdf}}

@inproceedings{Tich00a,
	Abstract = {The distributed nature of a typical web application
				  combined with the rapid evolution of underlying
				  platforms demands for a plug-in component
				  architecture. Nevertheless, code for controlling
				  distributed activities is usually spread over
				  multiple subsystems, which makes it hard to
				  dynamically reconfigure coordination services. This
				  paper investigates coordination components as a way
				  to encapsulate the coordination of a distributed
				  system into a separate, pluggable entity. In an
				  object-oriented context we introduce two design
				  guidelines (namely, "turn contracts into objects"
				  and "turn configuration into a factory object") that
				  help developers to separate coordination from
				  computation and to develop reusable and flexible
				  solutions for coordination in distributed systems.},
	Author = {Sander Tichelaar and Juan Carlos Cruz and Serge Demeyer},
	Booktitle = {Proceedings ACM SAC 2000},
	Doi = {10.1145/335603.335758},
	Editor = {Janice Carroll and Ernesto Damiani and Hisham Haddad and Dave Oppenheim},
	Keywords = {coordination components scg-pub tich-papref sergedem-papref scg-coord-00 snf00 scg-none jb00},
	Month = mar,
	Pages = {270--277},
	Publisher = {ACM},
	Title = {Design Guidelines for Coordination Components},
	Url = {http://scg.unibe.ch/archive/papers/Tich00aDesignGuidelines.pdf},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Tich00aDesignGuidelines.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/335603.335758}}

@inproceedings{Tich00b,
	Abstract = {Refactoring --- transforming code while preserving
				  behaviour --- is currently considered a key approach
				  for improving object-oriented software systems.
				  Unfortunately, all of the current refactoring tools
				  depend on language-dependent refactoring engines,
				  which prevents a smooth integration with mainstream
				  development environments. In this paper we
				  investigate the similarities between refactorings
				  for Smalltalk and {Java}, derive a
				  language-independent meta-model and show that it is
				  feasible to build a language-independent refactoring
				  engine on top of this meta-model. Our feasibility
				  study is validated by means of a tool prototype
				  which uses the same engine to refactor both
				  Smalltalk and {Java} code. Using our approach we
				  minimize the language-dependent part of refactoring
				  tools, providing a standard way for programmers and
				  tools to perform refactorings no matter what
				  language they work in.},
	Acceptnum = {22},
	Accepttotal = {51},
	Address = {Los Alamitos, CA},
	Annote = {internationalconference},
	Author = {Sander Tichelaar and St\'ephane Ducasse and Serge Demeyer and Oscar Nierstrasz},
	Booktitle = {Proceedings of International Symposium on Principles of Software Evolution (ISPSE '00)},
	Doi = {10.1109/ISPSE.2000.913233},
	Keywords = {reengineering refactoring FAMIX repositories mooseCincom tich-papref scg-pub scg-none jb00 snf01 stefPub onhindex(92) moose-pub},
	Misc = {acceptance rate: 22/51 = 43\%},
	Month = nov,
	Pages = {157--167},
	Publisher = {IEEE Computer Society Press},
	Title = {A Meta-model for Language-Independent Refactoring},
	Url = {http://scg.unibe.ch/archive/papers/Tich00bRefactoringMetamodel.pdf},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Tich00bRefactoringMetamodel.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ISPSE.2000.913233}}

@inproceedings{Tich00m,
	Abstract = {In the FAMOOS project we have developed a set of
				  tools for reengineering object-oriented legacy
				  systems. These tools are based on the FAMIX meta
				  model and exchange information using CDIF, an
				  industry standard exchange format. For several
				  reasons XMI, an emerging standard for information
				  exchange, has appealed to us to be used as our
				  interchange format. In this paper we discuss why XMI
				  is interesting for us and what, to our current
				  experience, are the advantages and disadvantages of
				  XMI over CDIF.},
	Annote = {internationalworkshop},
	Author = {Sander Tichelaar and St\'ephane Ducasse and Serge Demeyer},
	Booktitle = {Proceedings of the ICSE 2000 Workshop on Standard Exchange Format (WoSEF 2000)},
	Keywords = {components scg-pub skip-doi tich-papunr sergedem-papunr snf00 scg-none jb00 stefPub moose-pub},
	Month = jun,
	Title = {{FAMIX}: Exchange Experiences with {CDIF} and {XMI}},
	Url = {http://scg.unibe.ch/archive/papers/Tich00mFamixCdifXmi.pdf},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Tich00mFamixCdifXmi.pdf}}

@inproceedings{Tich00n,
	Abstract = {Recently exchange formats have gained lots of
				  attention. Multiple tools need to interact and/or
				  work on the same software system. Especially there
				  is a need to reuse parser technology. Within the
				  FAMOOS project we have developed a model for
				  representing object-oriented software systems at the
				  program entity level. The model has been designed
				  for language independence, extensibility and
				  information exchange. For the actual exchange of
				  data we are currently moving to use XMI, a standard
				  for model-based information exchange.},
	Address = {Los Alamitos CA},
	Annote = {internationalworkshop},
	Author = {Sander Tichelaar and St\'ephane Ducasse and Serge Demeyer},
	Booktitle = {Proceedings WCRE 2000 Workshop on Exchange Formats},
	Doi = {10.1109/WCRE.2000.891485},
	Keywords = {components scg-pub tich-papunr sergedem-papunr snf00 scg-none jb00 stefPub moose-pub},
	Month = nov,
	Pages = {296--296},
	Publisher = {IEEE Computer Society Press},
	Title = {{FAMIX} and {XMI}},
	Url = {http://scg.unibe.ch/archive/papers/Tich00nFamixWCRE2000.pdf},
	Year = {2000},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Tich00nFamixWCRE2000.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.2000.891485}}

@inproceedings{Tymc16a,
	Author    = {Yuriy Tymchuk and Leonel Merino and Mohammad Ghafari and Oscar Nierstrasz},
	Title     = {Walls, Pillars and Beams: A 3D Decomposition of Quality Anomalies},
	Booktitle = {{VISSOFT}'16: Proceedings of the 4th IEEE Working Conference on Software Visualization},
	Abstract  = {Quality rules are used to capture important implementation and design decisions embedded in a software system's architecture. They can automatically analyze software and assign quality grades to its components.
To provide a meaningful evaluation of quality, rules have to stay up-to-date with the continuously evolving system that they describe. However one would encounter unexpected anomalies during a historical overview because the notion of quality is always changing, while the qualitative evolution analysis requires it to remain constant.
To understand the anomalies in a quality history of a real-world software system we use an immersive visualization that lays out the quality fluctuations in three dimensions based on two co-evolving properties: quality rules and source code. This helps us to identify and separate the impact caused by the changes of each property, and allows us to detect significant mistakes that happened during the development process.},
	Annote 	  = {internationalconference},
	Publisher = {IEEE},
	PeerReview = {yes},
	Medium    = {2},
	Keywords  = {scg-pub snf-asa2 scg16 jb16 tymchuk},
	Year      = {2016},
	Url       = {http://scg.unibe.ch/archive/papers/Tymc16a.pdf},
	DOI       = {10.1109/VISSOFT.2016.9},
	Pages     = {126--135}
}

@inproceedings{Tymc16b,
	Abstract = {Static analysis tools can aid in software quality assessment, but are rarely used by software developers.
Poor usage of quality analysis tools not only means missed opportunities for the quality of software systems, but also results in little feedback, which in turn slows the improvements of the quality rules themselves.
We introduced a set of intrusive quality plugins and integrated them into the Pharo IDE. This not only triggered a feedback loop that led to improvements of the existing rules, but also encouraged removal of some rules and integration of new ones.
Our analysis of changes to the rules suggests that precise rules capturing a domain-specific logic are more valuable than general ones.},
	Annote = {internationalworkshop},
	Author = {Yuriy Tymchuk and Mohammad Ghafari and Oscar Nierstrasz},
	Booktitle = {IWST '16: Proceedings of International Workshop on Smalltalk Technologies},
	Keywords = {scg16 scg-pub jb16 snf-asa2 tymchuk},
	Peerreview = {yes},
  Doi = {10.1145/2991041.2991046},
	Title = {When {QualityAssistant} Meets {Pharo}: Enforced Code Critiques Motivate More Valuable Rules},
	Url = {http://scg.unibe.ch/archive/papers/Tymc16b.pdf},
	Year = {2016},
	Pages = {5:1--5:6},
	Medium = {4}
}

@misc{Tymc17a,
  author       = {Yuriy Tymchuk},
  title        = {Renraku v0.15.2},
  month        = may,
  year         = {2017},
  Medium       = {1},
  Peerreview   = {no},
  doi          = {10.5281/zenodo.800676},
  url          = {https://doi.org/10.5281/zenodo.800676},
  keywords     = {scg17 scg-pub jb17 snf-none},
  abstract     = {Renraku is an extensible static analysis model designed to connect analyzers and tools conveniently. It defines how algorithms should provide external properties of source code, and how tools should consume these properties. Not only the unique model lifts the complexity burden from static analysis engineering but opens entirely new horizons unseen by the others.}
}

@misc{Tymc17b,
  author       = {Yuriy Tymchuk},
  title        = {QualityAssistant v3.3.1},
  month        = jun,
  year         = {2017},
  Medium       = {1},
  keywords     = {scg17 scg-pub jb17 snf-none},
  Peerreview   = {no},
  doi          = {10.5281/zenodo.809410},
  url          = {https://doi.org/10.5281/zenodo.809410},
  abstract     = {QualityAssistant is a live quality feedback plugin based on SmallLint, which reports code quality violations to software developers as they work with the code.}
}

@inproceedings{Tymc17c,
	Annote = {internationalworkshop},
	Abstract = {Static analysis tools may produce false positive results, which negatively impact the overall usability of these tools.
However, even a correct static analysis report is sometimes classified as a false positive if a developer does not understand it or does not agree with it.
Lately developers' classification of false positives is treated on a par with the actual static analysis performance which may distort the knowledge about the real state of static analysis. In this paper we discuss various use cases where a false positive report is not false and the issue is caused by another aspects of static analysis.
We provide an in-depth explanation of the issue for each use case followed by recommendations on how to solve it, and thus exemplify the importance of careful false positive classification.},
	Author = {Tymchuk, Yuriy},
	Booktitle = {SATToSE'17: Pre-Proceedings of the 10th International Seminar Series on Advanced Techniques \& Tools for Software Evolution},
	PeerReview = {yes},
	Medium = {1},
	Keywords = {scg-pub snf-asa2 scg17 jb17 skip-doi tymchuk},
	Month = jun,
	location = {Madrid, Spain},
	Title = {The False False Positives of Static Analysis},
	Year = {2017},
	Url = {http://scg.unibe.ch/archive/papers/Tymc17c.pdf},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Tymc17c.pdf}}

@inproceedings{Tymc17d,
	Abstract = {Most of the static analyzers are monolithic applications that define their own ways to analyze source code and present the results.
Therefore aggregating multiple static analyzers into a single tool or integrating a new analyzer into existing tools requires a significant amount of effort.
Over the last few years, we cultivated Renraku --- a static analysis model that acts as a mediator between the static analyzers and the tools that present the reports.
When used by both analysis and tool developers, the single quality model can reduce the cost to both introduce a new type of analysis to existing tools or create a tool that relies on existing analyzers.},
	Annote = {internationalworkshop},
	Author = {Yuriy Tymchuk and Mohammad Ghafari and Oscar Nierstrasz},
	Booktitle = {IWST'17: Proceedings of International Workshop on Smalltalk Technologies},
	Keywords = {scg17 scg-pub jb17 snf-asa2 tymchuk},
	Peerreview = {yes},
	Title = {Renraku --- the One Static Analysis Model to Rule Them All},
	location = {Maribor, Slovenia},
	Url = {http://scg.unibe.ch/archive/papers/Tymc17d.pdf},
	Doi = {10.1145/3139903.3139919},
	Year = {2017},
	Medium = {4}
}

@misc{Tymc17e,
  author       = {Tymchuk, Yuriy},
  title        = {QualityAssistant Interactions},
  month        = aug,
  year         = {2017},
  doi          = {10.5281/zenodo.846690},
  Medium       = {1},
  keywords     = {scg17 scg-pub jb17 snf-none},
  Peerreview   = {no},
  url          = {https://doi.org/10.5281/zenodo.846690},
  abstract     = {The dataset contains recordings of developers interacting with the QualityAssistant static analysis plugin in Pharo IDE (version 5 and 6). We recorded 7786 development sessions from 547 developers in a time span of 322 days. In a regular programming session, the developer launches the Pharo IDE and uses the code editor to display code. The Pharo IDE allows the developer to work on a single method or class definition at a time. QualityAssistant then evaluates the browsed code; if the tool finds quality violations, it displays them in the code editor. The developer eventually edits the code, i.e., performing code transformations either manually or using automated tools. After the developer compiles the code, QualityAssistant re-evaluates it and thus more or fewer violations may be displayed to the developer.}
}

@inproceedings{Tymc18a,
	Author    = {Yuriy Tymchuk and Mohammad Ghafari and Oscar Nierstrasz},
	abstract = {Although software developers are usually reluctant to
		use static analysis to detect issues in their source
		code, our automatic just-in-time (JIT) static analysis
		assistant was integrated into an Integrated
		Development Environment, and was evaluated positively
		by its users. We conducted interviews to understand
		the impact of the tool on experienced developers, and
		how it performs in comparison with other static
		analyzers. We learned that the availability of our
		tool as a default IDE feature and its automatic
		execution are the main reasons for its adoption.
		Moreover, the fact that immediate feedback is provided
		directly in the related development context is
		essential to keeping developers satis ed, although in
		certain cases feedback delivered later was deemed more
		useful. We also discovered that static analyzers can
		play an educational role, especially in combination
		with domain-specific rules.},
	location = {Gothenburg, Sweden},
	Keywords = {scg-pub snf-asa2 scg18 jb18},
	Peerreview = {yes},
	Medium = {2},
	Booktitle = {26th IEEE International Conference on Program Comprehension (ICPC 2018)},
    Annote    = {internationalconference},
	Url = {http://scg.unibe.ch/archive/papers/Tymc18a.pdf},
	Doi = {10.1145/3196321.3196327},
	Title = {{JIT} Feedback --- what Experienced Developers like about Static Analysis},
	Pages = {64--73},
	Year = {2018}
}

@techreport{Varo95a,
	Abstract = {This report presents the implementation of the
				  "Generic Synchronization Policies" (abbreviated as
				  GSP) using the language Pict. The main goal of this
				  work was to see how well suited Pict is for
				  implementing higher level abstractions. The
				  remainder of this report is structured as follows:
				  Section 2 briefly introduces the GSP concept. Pict
				  and its object model are presented in section 3. The
				  implementation of GSP is the heart of section 4.
				  Finally, Section 5 mention future possible works.},
	Author = {Patrick Varone},
	Institution = {University of Bern, Institute of Computer Science and Applied Mathematics},
	Keywords = {olit scg-pub skip-doi toBeChecked snf95 scg-none jb95},
	Month = feb,
	Number = {IAM-96-005},
	Title = {Implementation of `Generic Synchronization Policies' in Pict},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Varo95aGSPinPict.pdf},
	Year = {1996},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Varo95aGSPinPict.pdf}}

@inproceedings{Vasa07b,
	Abstract = {Real software systems change and become more complex
				  over time. But which parts change and which parts
				  remain stable? Common wisdom, for example, states
				  that in a well-designed object-oriented system, the
				  more popular a class is, the less likely it is to
				  change from one version to the next, since changes
				  to this class are likely to impact its clients. We
				  have studied consecutive releases of several public
				  domain, object-oriented software systems and
				  analyzed a number of measures indicative of size,
				  popularity, and complexity of classes and
				  interfaces. As it turns out, the distributions of
				  these measures are remarkably stable as an
				  application evolves. The distribution of class size
				  and complexity retains its shape over time.
				  Relatively little code is modified over time.
				  Classes that tend to be modified, however, are also
				  the more popular ones, that is, those with greater
				  Fan-In. In general, the more "complex" a class or
				  interface becomes, the more likely it is to change
				  from one version to the next.},
	Address = {Los Alamitos CA},
	Annote = {internationalconference},
	Author = {Rajesh Vasa and Jean-Guy Schneider and Oscar Nierstrasz},
	Booktitle = {Proceedings of 23rd IEEE International Conference on Software Maintenance (ICSM '07)},
	City = {Paris, France},
	Doi = {10.1109/ICSM.2007.4362613},
	Keywords = {scg07 scg-pub jb08 snf08},
	Medium = {2},
	Pages = {4--13},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Title = {The Inevitable Stability of Software Change},
	Url = {http://scg.unibe.ch/archive/papers/Vasa07bInevitableChange.pdf},
	Year = {2007},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Vasa07bInevitableChange.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICSM.2007.4362613}}

@inproceedings{Vasa08a,
	Abstract = {Software systems evolve over time incrementally and
				  sections of code are modified. But, how much does
				  code really change? Lehman's laws suggest that
				  software must be continuously adapted to be useful.
				  We have studied the evolution of several public
				  domain object-oriented software systems and analyzed
				  the rate as well as the amount of change that
				  individual classes undergo as they evolve. Our
				  observations suggest that although classes are
				  modified, the majority of changes are minor and only
				  a small proportion of classes undergo significant
				  modification.},
	Annote = {internationalconference},
	Author = {Rajesh Vasa and Jean-Guy Schneider and Oscar Nierstrasz and Clint Woodward},
	Booktitle = {Proceedings of 3d International ERCIM Symposium on Software Evolution (Software Evolution 2007)},
	Editor = {Tom Mens and Maja D'Hondt and Kim Mens},
	Issn = {1863-2122},
	Keywords = {scg07 scg-pub skip-doi jb08 snf08},
	Medium = {2},
	Peerreview = {yes},
	Publisher = {Electronic Communications of the EASST},
	Title = {On the Resilience of Classes to Change},
	url = {http://scg.unibe.ch/archive/papers/Vasa08aResilienceToChange.pdf},
	Url2 = {http://eceasst.cs.tu-berlin.de/index.php/eceasst/article/view/121},
	Volume = {8},
	Year = {2008},
	Bdsk-Url-1 = {http://eceasst.cs.tu-berlin.de/index.php/eceasst/article/view/121%20http://scg.unibe.ch/archive/papers/Vasa08aResilienceToChange.pdf}}

@inproceedings{Vasa09a,
	Abstract = {Software metrics offer us the promise of distilling
				  useful information from vast amounts of software in
				  order to track development progress, to gain
				  insights into the nature of the software, and to
				  identify potential problems. Unfortunately, however,
				  many software metrics exhibit highly skewed,
				  non-Gaussian distributions. As a consequence, usual
				  ways of interpreting these metrics --- for example,
				  in terms of "average" values --- can be highly
				  misleading. Many metrics, it turns out, are
				  distributed like wealth --- with high concentrations
				  of values in selected locations. We propose to
				  analyze software metrics using the Gini coefficient,
				  a higher-order statistic widely used in economics to
				  study the distribution of wealth. Our approach
				  allows us not only to observe changes in software
				  systems efficiently, but also to assess project
				  risks and monitor the development process itself. We
				  apply the Gini coefficient to numerous metrics over
				  a range of software projects, and we show that many
				  metrics not only display remarkably high Gini
				  values, but that these values are remarkably
				  consistent as a project evolves over time.},
	Address = {Los Alamitos, CA, USA},
	Annote = {internationalconference},
	Author = {Rajesh Vasa and Markus Lumpe and Philip Branch and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 25th International Conference on Software Maintenance (ICSM 2009)},
	Doi = {10.1109/ICSM.2009.5306322},
	Journal = {icsm},
	Keywords = {scg09 scg-pub snf09 jb10},
	Medium = {2},
	Pages = {179--188},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Title = {Comparative Analysis of Evolving Software Systems Using the {Gini} Coefficient},
	Url = {http://scg.unibe.ch/archive/papers/Vasa09aGiniICSM.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Vasa09aGiniICSM.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICSM.2009.5306322}}

@inproceedings{Verb08a,
	Abstract = {Industrial software systems are large and complex,
				  both in terms of the software entities and their
				  relationships. Consequently, understanding how a
				  software system works requires the ability to pose
				  queries over the design-level entities of the
				  system. Traditionally, this task has been supported
				  by simple tools (e.g., grep) combined with the
				  programmer's intuition and experience. Recently,
				  however, specialized code query technologies have
				  matured to the point where they can be used in
				  industrial situations, providing more intelligent,
				  timely, and efficient responses to developer
				  queries. This working session aims to explore the
				  state of the art in code query technologies, and
				  discover new ways in which these technologies may be
				  useful in program comprehension. The session brings
				  together researchers and practitioners. We survey
				  existing techniques and applications, trying to
				  understand the strengths and weaknesses of the
				  various approaches, and sketch out new frontiers
				  that hold promise.},
	Annote = {internationalconference},
	Author = {Mathieu Verbaere and Michael W. Godfrey and Tudor G\^irba},
	Booktitle = {Proceedings of International Conference on Program Comprehension (ICPC 2008)},
	Doi = {10.1109/ICPC.2008.27},
	Keywords = {scg08 scg-pub snf-none moose-pub girba jb08 hasler08},
	Medium = {2},
	Pages = {285--288},
	Peerreview = {yes},
	Title = {Query Technologies and Applications for Program Comprehension},
	Url = {http://scg.unibe.ch/archive/papers/Verb08aQTAPC2008.pdf},
	Year = {2008},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Verb08aQTAPC2008.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/ICPC.2008.27}}

@inproceedings{Verc18a,
 author = {Vercammen, Sten and Ghafari, Mohammad and Demeyer, Serge and Borg, Markus},
 title = {Goal-oriented Mutation Testing with Focal Methods},
 booktitle = {Proceedings of the 9th ACM SIGSOFT International Workshop on Automating TEST Case Design, Selection, and Evaluation},
 series = {A-TEST 2018},
 year = {2018},
 isbn = {978-1-4503-6053-1},
 location = {Lake Buena Vista, FL, USA},
 pages = {23--30},
 numpages = {8},
 url = {https://arxiv.org/abs/1807.10953},
 doi = {10.1145/3278186.3278190},
 acmid = {3278190},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {scg-pub snf-asa2 scg18 jb19},
abstract={Mutation testing is the state-of-the-art technique for assessing the fault-detection capacity of a test suite. Unfortunately, mutation testing consumes enormous computing resources because it runs the whole test suite for each and every injected mutant. In this paper we explore fine-grained traceability links at method level (named focal methods), to reduce the execution time of mutation testing and to verify the quality of the test cases for each individual method, instead of the usually verified overall test suite quality. Validation of our approach on the open source Apache Ant project shows a speed-up of 573.5x for the mutants located in focal methods with a quality score of 80%.}
}

@inproceedings{Verw09a,
	Abstract = {Code executed in a fully reflective system switches
				  back and forth between application and interpreter
				  code. These two states can be seen as contexts in
				  which an expression is evaluated. Current language
				  implementations obtain reflective capabilities by
				  exposing objects to the interpreter. However, in
				  doing so these systems break the encapsulation of
				  the application objects. In this paper we propose
				  safe reflection through polymorphism, \ie by
				  unifying the interface and ensuring the
				  encapsulation of objects from both the interpreter
				  and application context. We demonstrate a
				  \emph{homogeneous system} that defines the execution
				  semantics in terms of itself, thus enforcing that
				  encapsulation is not broken.},
	Address = {New York, NY, USA},
	Annote = {internationalworkshop},
	Author = {Toon Verwaest and Lukas Renggli},
	Booktitle = {CASTA '09: Proceedings of the first international workshop on Context-aware software technology and applications},
	Doi = {10.1145/1595768.1595776},
	Isbn = {978-1-60558-707-3},
	Keywords = {scg09 scg-pub tverwaes snf09 jb10 schemetalk pinocchio},
	Location = {Amsterdam, The Netherlands},
	Medium = {1},
	Pages = {21--24},
	Peerreview = {yes},
	Publisher = {ACM},
	Title = {Safe Reflection Through Polymorphism},
	Url = {http://scg.unibe.ch/archive/papers/Verw09aSafeReflectionThroughPolymorphism.pdf},
	Year = {2009},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Verw09aSafeReflectionThroughPolymorphism.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1595768.1595776}}

@inproceedings{Verw10a,
	Abstract = {To support development tools like debuggers, runtime
				  systems need to provide a meta-programming interface
				  to alter their semantics and access internal data.
				  Reflective capabilities are typically fixed by the
				  Virtual Machine (VM). Unanticipated reflective
				  features must either be simulated by complex program
				  transformations, or they require the development of
				  a specially tailored VM. We propose a novel approach
				  to behavioral reflection that eliminates the barrier
				  between applications and the VM by manipulating an
				  explicit tower of first-class interpreters.
				  Pinocchio is a proof-of-concept implementation of
				  our approach which enables radical changes to the
				  interpretation of programs by explicitly
				  instantiating subclasses of the base interpreter. We
				  illustrate the design of Pinocchio through
				  non-trivial examples that extend runtime semantics
				  to support debugging, parallel debugging, and
				  back-in-time object-flow debugging. Although
				  performance is not yet addressed, we also discuss
				  numerous opportunities for optimization, which we
				  believe will lead to a practical approach to
				  behavioral reflection.},
	Address = {New York, NY, USA},
	Annote = {internationalconference},
	Author = {Toon Verwaest and Camillo Bruni and David Gurtner and Adrian Lienhard and Oscar Nierstrasz},
	Booktitle = {OOPSLA Onward! '10},
	Doi = {10.1145/1869459.1869522},
	Isbn = {978-1-4503-0203-6},
	Issn = {0362-1340},
	Issue = {10},
	Issue_Date = {October 2010},
	Journal = {SIGPLAN Not.},
	Keywords = {scg10 scg-pub tverwaes snf10 jb11 pinocchio},
	Location = {Reno/Tahoe, NV, USA},
	Medium = {0},
	Numpages = {16},
	Pages = {774--789},
	Peerreview = {yes},
	Publisher = {ACM},
	Title = {Pinocchio: Bringing Reflection to Life with First-Class Interpreters},
	Url = {http://scg.unibe.ch/archive/papers/Verw10aPinocchio.pdf},
	Volume = {45},
	Year = {2010},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Verw10aPinocchio.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/1869459.1869522}}

@inproceedings{Verw11a,
	Abstract = {Dynamic updates in object-oriented
languages require high-level changes to be translated
 to low-level changes. For example, removing an unused
instance variable from a class may shift the
indices of other instance variables. The shift needs
to be translated to a change of the bytecodes accessing
these instance variables. Current languages do not
 offer a bridge between the two levels of abstraction.
 We outline such a model, and demonstrate its usefulness
 by discussing a prototype implementation in Pharo
Smalltalk. In addition to simplifying the implementation
 of dynamic updates, our model enables easy experiments
 in modifying the language semantics.},
	Annote = {internationalworkshop},
	Author = {Toon Verwaest and Niko Schwarz and Erwann Wernli},
	Booktitle = {Proceedings of the TOOLS 2011 8th Workshop on Reflection, AOP and Meta-Data for Software Evolution (RAM-SE'11)},
	Keywords = {scg11 scg-pub tverwaes nes snf11 jb11 skip-doi},
	Medium = {1},
	Peerreview = {yes},
	Title = {Runtime Class Updates using Modification Models},
	Url = {http://scg.unibe.ch/archive/papers/Verw11aRuntimeUpdates.pdf},
	Year = {2011},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Verw11aRuntimeUpdates.pdf}}

@inproceedings{Verw11b,
	Abstract = {Programming idioms, design patterns and application libraries often introduce
cumbersome and repetitive boilerplate code to a software system. Language
extensions and external DSLs (domain specific languages) are sometimes
introduced to reduce the need for boilerplate code, but they also complicate
the system by introducing the need for language dialects and inter-language
mediation.
To address this, we propose to extend the structural reflective model of the
language with object layouts, layout scopes and slots.
Based on the new reflective language model we can 1) provide behavioral hooks
to object layouts that are triggered when the fields of an object are accessed
and 2) simplify the implementation of state-related language extensions such as
stateful traits. By doing this we show how many idiomatic use cases that
normally require boilerplate code can be more effectively supported.
We present an implementation in Smalltalk, and illustrate its usage through a
series of extended examples.},
	Address = {New York, NY, USA},
	Annote = {internationalconference},
	Author = {Toon Verwaest and Camillo Bruni and Mircea Lungu and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 2011 ACM international conference on Object oriented programming systems languages and applications},
	Doi = {10.1145/2048066.2048138},
	Isbn = {978-1-4503-0940-0},
	Keywords = {scg11 scg-pub tverwaes snf11 jb11},
	Location = {Portland, Oregon, USA},
	Medium = {0},
	Pages = {959--972},
	Peerreview = {yes},
	Publisher = {ACM},
	Series = {OOPSLA '11},
	Title = {Flexible object layouts: enabling lightweight language extensions by intercepting slot access},
	Url = {http://scg.unibe.ch/archive/papers/Verw11bFlexibleObjectLayouts.pdf},
	Year = {2011},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Verw11bFlexibleObjectLayouts.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/2048066.2048138}}

@inproceedings{Vran12b,
	Abstract = {After decades of development in programming languages and programming
		environments, Smalltalk is still one of few environments that provide advanced
		features and is still widely used in the industry. However, as Java became prevalent,
		the ability to call Java code from Smalltalk and vice versa becomes important.
		Traditional approaches to integrate the Java and Smalltalk languages are through
		low-level communication between separate Java and Smalltalk virtual machines.
		We are not aware of any attempt to execute and integrate the Java language
		directly in the Smalltalk environment. A direct integration allows for very tight and
		almost seamless integration of the languages and their objects within a single
		environment. Yet integration and language interoperability impose challenging
		issues related to method naming conventions, method overloading, exception handling
		and thread-locking mechanisms.  In this paper we describe ways to overcome these
		challenges and to integrate Java into the Smalltalk environment.  Using techniques
		described in this paper, the programmer can call Java code from Smalltalk using
		standard Smalltalk idioms while the semantics of each language remains preserved.
		We present STX:LIBJAVA - an implementation of Java virtual machine within
		Smalltalk/X - as a validation of our approach},
	Author = {Jan Vrany and Jan Kur\v{s} and Marcel Hlopko and Claus Gittinger},
	Booktitle = {Proceedings of the 4rd International Workshop on Smalltalk Technologies (IWST'12)},
	Isbn = {978-1-4503-1897-6},
	Keywords = {scg-pub snf-none scg12 jb13, Language Interoperability, Smalltalk, Java, kursjan},
	Medium = {1},
	Peerreview = {yes},
	Publisher = {ACM},
	Title = {On the Integration of Smalltalk and Java},
	Url = {http://scg.unibe.ch/archive/papers/Vran12a.pdf},
	doi = {10.1016/j.scico.2013.10.011},
	Year = {2012},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Vran12a.pdf}}

@inproceedings{Wern11a,
	Abstract = {Applications that need to be updated but cannot be easily restarted must be updated at run-time. We
		evaluate the reflective facilities of Smalltalk with respect to dynamic soft- ware and the
		state-of-the-art in this field. We conclude that while fine for debugging, the existing reflective
		facilities are not appropriate for dynamically updating production systems under constant load. We
		propose to enable dynamic updates by introducing first-class contexts as a mechanism to allow multiple
		versions of objects to coexist. Object states can be dynamically migrated from one context to another,
		and can be kept in sync with the help of bidirectional transformations. We demonstrate our approach with
		ActiveContext, an extension of Smalltalk with first-class contexts. ActiveContext eliminates the need for
		a system to be quiescent for it to be updated. ActiveContext is realized in Pinocchio, an experimental
		Smalltalk implementation that fully reifies the VM to enable radical extensions. We illustrate dynamic
		updates in ActiveContext with a typical use case, present initial benchmarks, and discuss future
		performance improvements.},
	Annote = {internationalworkshop},
	Author = {Erwann Wernli and David Gurtner and Oscar Nierstrasz},
	Booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2011)},
	Keywords = {scg11 scg-pub jb11 snf11 skip-doi},
	Medium = {1},
	Note = {http://esug.org/data/ESUG2011/IWST/Proceedings.pdf},
	Pages = {21-31},
	Peerreview = {yes},
	Title = {Using First-class Contexts to realize Dynamic Software Updates},
	Url = {http://scg.unibe.ch/archive/papers/Wern11a-ActiveContext.pdf},
	Year = {2011},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Wern11a-ActiveContext.pdf}}

@inproceedings{Wern12a,
	Abstract = {Highly available software systems occasionally need to be updated while avoiding downtime.
Dynamic software updates reduce downtime, but still require the system to reach a quiescent state in which a global update can be performed.
This can be difficult for multi-threaded systems.
We present a novel approach to dynamic updates using first-class contexts, called Theseus.
First-class contexts make global updates unnecessary: existing threads run to termination in an old context, while new threads start in a new, updated context; consistency between contexts is ensured with the help of bidirectional transformations.
We show how first-class contexts offer a practical and flexible approach to incremental dynamic updates, with acceptable overhead.},
	Annote = {internationalconference},
	Author = {Erwann Wernli and Mircea Lungu and Oscar Nierstrasz},
	Booktitle = {Objects, Components, Models and Patterns, Proceedings of TOOLS Europe 2012},
	Doi = {10.1007/978-3-642-30561-0_21},
	Keywords = {scg-pub jb12 scg12 snf12 theseus},
	Medium = {2},
	Pages = {304-319},
	Peerreview = {yes},
	Title = {Incremental Dynamic Updates with First-class Contexts},
	Url = {http://scg.unibe.ch/archive/papers/Wern12a.pdf},
	Year = {2012},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/978-3-642-30561-0_21}}

@inproceedings{Wern12b,
	Abstract = {We present a novel approach to update server applications in Java. In our approach, different versions of the code coexist in the system, but are isolated into distinct contexts. The server can switch from one context to another incrementally in order to process incoming requests. Our approach has the following characteristics: (1) updatability is defined and added to the application by developers, (2) no syntax is added to the language and the update is controlled via the manipulation of objects, (3) the whole system is migrated lazily and eventually replaces the old system, (4) it is safe to update global entities anytime and there is no need to reach update points. We demonstrate our approach by updating the Jetty web server.},
	Annote = {internationalworkshop},
	Author = {Erwann Wernli},
	Booktitle = {Proceedings of HotSWUp 2012 (Fourth Workshop on Hot Topics in Software Upgrades)},
	Doi = {10.1109/HotSWUp.2012.6226616},
	Keywords = {scg-pub jb12 scg12 snf12 theseus wern-sel},
	Medium = {1},
	Month = jun,
	Pages = {41-45},
	Peerreview = {yes},
	Title = {Theseus: Whole updates of {Java} server applications},
	Url = {http://scg.unibe.ch/archive/papers/Wern12b.pdf},
	Year = {2012},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Wern12b.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/HotSWUp.2012.6226616}}

@inproceedings{Wern12c,
	Annote = {internationalconference},
	Abstract = {Sharing mutable objects can result in broken invariants, exposure of internal details, and other subtle bugs. To prevent such issues, it is important to control accessibility and aliasing of objects. Dynamic Ownership is an effective way to do so, but its owner-as-dominator discipline is too restrictive: objects are either accessible or not. We propose in this paper to control accessibility and aliasing with more flexibility using two mechanisms, filters and crossing handlers. We demonstrate the benefits of the flexibility offered by these mechanisms, and report on the adaptation of a Smalltalk web server with our approach. We conclude that our variant of dynamic ownership is flexible enough to accommodate an existing design, while at the same time constraining it enough to highlight design anomalies.},
	Acmid = {2384589},
	Address = {New York, NY, USA},
	Author = {Wernli, Erwann and Maerki, Pascal and Nierstrasz, Oscar},
	Booktitle = {Proceedings of the 8th symposium on Dynamic languages},
	Doi = {10.1145/2384577.2384589},
	Isbn = {978-1-4503-1564-7},
	Keywords = {encapsulation scg-pub scg12 snf12 ownership jb13 wern-sel},
	Location = {Tucson, Arizona, USA},
	Medium = {0},
	Numpages = {12},
	Pages = {83--94},
	Peerreview = {yes},
	Publisher = {ACM},
	Series = {DLS '12},
	Title = {Ownership, filters and crossing handlers: flexible ownership in dynamic languages},
	Url = {http://scg.unibe.ch/archive/papers/Wern12c.pdf},
	Year = {2012},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Wern12c.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/2384577.2384589}}

@article{Wern13a,
	Abstract = {Highly available software systems occasionally need to be updated while avoiding downtime.
	Dynamic software updates reduce down-time, but still require the system to reach a quiescent state in
	which a global update can be performed. This can be difficult for multi-threaded systems. We present a
	novel approach to dynamic updates using first-class contexts, called Theseus. First-class contexts
	make global updates unnecessary: existing threads run to termination in an old context, while new
	threads start in a new, updated context; consistency between contexts is ensured with the help of
	bidirectional transformations. We show that for multi-threaded systems with coherent memory,
	first-class contexts offer a practical and flexible approach to dynamic updates, with acceptable
	overhead.},
	Author = {Erwann Wernli and Mircea Lungu and Oscar Nierstrasz},
	Doi = {10.5381/jot.2013.12.3.a1},
	Issn = {1660-1769},
	Journal = {Journal of Object Technology},
	Annote = {internationaljournal},
	Keywords = {context-oriented scg-pub jb13 snf-asa1 scg13 wern-sel},
	Medium = {1},
	Month = aug,
	Number = {3},
	Pages = {1:1-27},
	Peerreview = {yes},
	Title = {Incremental Dynamic Updates with First-class Contexts},
	Url = {http://scg.unibe.ch/archive/papers/Wern13a.pdf},
	Volume = {12},
	Year = {2013},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Wern13a.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.5381/jot.2013.12.3.a1}}

@inproceedings{Wern14a,
	Annote = {internationalconference},
	Abstract = {Scoping behavioral variations to dynamic extents is useful to
   support non-functional requirements that otherwise result in cross-cutting
   code. Unfortunately, such variations are difficult to achieve with
   traditional reflection or aspects. We show that with a modification of
   dynamic proxies, called delegation proxies, it becomes possible to
   reflectively implement variations that propagate to all objects accessed in
   the dynamic extent of a message send. We demonstrate our approach with
   examples of variations scoped to dynamic extents that help simplify code
   related to safety, reliability, and monitoring.},
	Acmid = {2577081},
	Address = {New York, NY, USA},
	Author = {Erwann Wernli and Oscar Nierstrasz and Camille Teruel and Stephane Ducasse},
	Booktitle = {Proceedings of the 13th International Conference on Modularity},
	Doi = {10.1145/2577080.2577081},
	Isbn = {978-1-4503-2772-5},
	Keywords = {constructs and features, dynamic extent, programming languages, proxy, reflection proxy; delegation; wern-sel scg-pub snf-asa1 scg14 jb14},
	PeerReview = {yes},
	Medium = {2},
	Location = {Lugano, Switzerland},
	Numpages = {12},
	Pages = {1--12},
	Publisher = {ACM},
	Series = {MODULARITY '14},
	Title = {Delegation Proxies: The Power of Propagation},
	Url = {http://scg.unibe.ch/archive/papers/Wern14a.pdf},
	Year = {2014},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Wern14a.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/2577080.2577081}}

@inproceedings{Wint02a,
	Abstract = {This paper presents a domain specific composition
				  language called CoCo. The CoCo language has been
				  developed in the context of the PECOS project which
				  aims at enabling component-based technology for a
				  certain class of embedded systems called "field
				  devices".},
	Annote = {internationalworkshop},
	Author = {Michael Winter and Thomas Gen{\ss}ler and Alexander Christoph and Oscar Nierstrasz and St\'ephane Ducasse and Roel Wuyts and Gabriela Ar{\'e}valo and Peter M\"uller and Christian Stich and Bastiaan Sch\"onhage},
	Booktitle = {Proc. Second International Workshop on Composition Languages},
	Keywords = {olit skip-doi scg-pub scg-none jb-none pecos stefPub arevalo onhindex(60)},
	Note = {In conjunction with 16th European Conference on Object-Oriented Programming (ECOOP) Malaga, Spain, June 11, 2002},
	Title = {Components for Embedded Software --- The PECOS Approach},
	Url = {http://scg.unibe.ch/archive/pecos/public_documents/Wint02a.pdf},
	Year = {2002},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/pecos/public_documents/Wint02a.pdf}}

@techreport{Wuyt99a,
	Abstract = {Throughout its entire life cycle software
				  development is subject to many rules constraining
				  and guiding construction of software systems.
				  Examples are best-practice patterns, idioms, coding
				  conventions, design guidelines, architectural
				  patterns, etc. Although such regulations are widely
				  used, their usage is currently implicit or ad-hoc,
				  and most soft- ware development environments do not
				  explicitly support them. We present an approach to
				  declare explicitly software development styles in an
				  open declarative system that allows querying,
				  conformance check- ing and enforcement of these
				  declarations on the source code. We validate the
				  approach by expressing and supporting several
				  software development styles in a real-world case.},
	Annote = {notrefereed},
	Author = {Wuyts, Roel and Mens, Kim and D'Hondt, Theo},
	Institution = {Vrije Universiteit Brussel},
	Keywords = {scg-old scg-pub skip-doi},
	Number = {vub-prog-tr-99-07},
	Title = {Explicit Support for Software Development Styles throughout the Complete Life Cycle},
	Url = {http://scg.unibe.ch/archive/papers/Wuyt99a.pdf},
	Year = {1999},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Wuyt99a.pdf}}

@inproceedings{Wuyt01a,
	Abstract = {Meta-programming is the act of using one system or
				  language to reason about another one. Reflection
				  describes systems that have access to and change a
				  causally connected representation of themselves,
				  hence leading to self-extensible systems . Up to
				  now, most of the reflective languages have been
				  implemented in the same paradigm. In this paper, we
				  propose \emph{symbiotic reflection} as a way to
				  integrate a meta programming language with the
				  object-oriented language it reasons about and is
				  implemented in. New to this approach is that any
				  element of the implementation language can be
				  reasoned about and acted upon (not only the self
				  representation), and that both languages are of
				  different paradigms. Moreover, every language
				  implementer that is faced with the problem of
				  allowing the base language to access the underlying
				  meta-language has to solve the problem of enabling
				  entity transfer between both worlds. We propose a
				  uniform schema, called upping/downing, to this
				  problem that avoid explicit wrapping or
				  typechecking. We illustrate this with SOUL (the
				  Smalltalk Open Unification Language), a logic
				  programming language in symbiotic reflection with
				  the object-oriented language Smalltalk. We show how
				  SOUL does logic reasoning directly on Smalltalk
				  objects, and how to use this to implement type
				  snooping},
	Annote = {internationalworkshop},
	Author = {Roel Wuyts and St\'ephane Ducasse},
	Booktitle = {ECOOP 2001 International Workshop on MultiParadigm Programming with Object-Oriented Languages},
	Keywords = {scg-pub skip-doi snf01 snf02 scg-none jb01 component Pecos stefPub},
	Title = {Symbiotic Reflection between an Object-Oriented and a Logic Programming Language},
	Url = {http://scg.unibe.ch/archive/papers/Wuyt01a.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Wuyt01a.pdf}}

@inproceedings{Wuyt01c,
	Abstract = {Supporting reuse of existing pieces of code is one
				  of the main goals of software engineering. In the
				  name of reuse, module-based programming languages
				  came to be, only to be surpassed by object-oriented
				  technology. With the same motivation component-based
				  solutions are overtaking object-oriented solutions.
				  However, the delegation-only focus of
				  component-based programming risks of resulting in
				  the same problems that modular-based approaches ran
				  into. To counter this, we claim that one of th e
				  important problems that should be addressed by
				  component languages is the composition of
				  components. More specifically, we see component
				  languages where components are black-box
				  abstractions, and with (one or more) composition
				  languages to glue them tog ether. As an example we
				  show a functional (Piccola) and a logic (QSoul)
				  composition approach.},
	Annote = {internationalworkshop},
	Author = {Roel Wuyts and St\'ephane Ducasse},
	Booktitle = {First OOPSLA Workshop on Language Mechanisms for Programming Software Components},
	Keywords = {scg-pub skip-doi snf01 scg-none jb01 component piccola Pecos stefPub},
	Title = {Composition Languages for Black-Box Components},
	Url = {http://scg.unibe.ch/archive/papers/Wuyt01c.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Wuyt01c.pdf}}

@inproceedings{Wuyt01d,
	Abstract = {This position paper presents some preliminary work
				  we made for applying declaractive component oriented
				  design in the context of embedded devices. We
				  quickly describes COMES the model we develop and
				  present how logic rules can be used to describe
				  architectures.},
	Annote = {internationalworkshop},
	Author = {Roel Wuyts and St\'ephane Ducasse and Gabriela Ar{\'e}valo},
	Booktitle = {Ecoop 6th International Workshop on Component-Oriented Programming},
	Keywords = {scg-pub skip-doi snf01 scg-none jb01 component Pecos stefPub arevalo},
	Title = {Applying Experiences with Declarative Codifications of Software Architectures on COD},
	Url = {http://scg.unibe.ch/archive/papers/Wuyt01d.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Wuyt01d.pdf}}

@inproceedings{Wuyt01e,
	Abstract = {In this paper we describe an interesting context to
				  study formal methods for component systems: embedded
				  devices. The context of embedded devices is highly
				  constrained by the physical requirements the devices
				  have to adhere to. As a result, component models for
				  embedded devices are not general purpose but geared
				  towards these constrained contexts. In this paper we
				  give the concrete setting of the Pecos project (a
				  project with as goal component engineering for
				  embedded devices). We describe the Pecos component
				  model, and show possibilities where we think formal
				  verification could be useful. We would like to use
				  this as a very concrete example to discuss formal
				  verification techniques.},
	Annote = {internationalworkshop},
	Author = {Roel Wuyts and St\'ephane Ducasse},
	Booktitle = {International Workshop on Specification and Verification of Component-Based Systems},
	Keywords = {scg-pub skip-doi snf01 scg-none jb01 component Pecos stefPub},
	Title = {Non-Functional Requirements in a Component Model for Embedded Systems},
	Url = {http://scg.unibe.ch/archive/papers/Wuyt01e.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Wuyt01e.pdf}}

@inproceedings{Wuyt01f,
	Abstract = {When developing software systems, the relation
				  between design and implementation is typically left
				  unspecified. As a result design or implementation
				  can be modified independently of each other, and a
				  modification of either one does not leave any trace
				  in the other. The practical result of this is a
				  number of well-known problems such as drift and
				  erosion, documentation maintenance problems or
				  round-trip engineering trouble. To solve these
				  problems we propose to make the relation between des
				  ign and implementation explicit by expressing design
				  as a logic meta program over implementation. This is
				  the cornerstone for building a complete
				  synchronisation framework that allows one to
				  synchronise changes to design and implementation. We
				  have implem ented such synchronisation framework,
				  and applied it successfully on two case studies.},
	Annote = {internationalworkshop},
	Author = {Roel Wuyts},
	Booktitle = {International Workshop on (Constraint) Logic Programming for Software Engineering},
	Keywords = {scg-pub skip-doi snf01 snf02 scg-none jb01},
	Month = dec,
	Title = {Synchronising Changes to Design and Implementation using a Declarative Meta-Programming Language},
	Url = {http://scg.unibe.ch/archive/papers/Wuyt01f.pdf},
	Year = {2001},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Wuyt01f.pdf}}

@article{Wuyt04a,
	Abstract = {The increasing complexity of software development
				  spawns lots of specialised tools to edit code,
				  employ UML schemes, integrate documentation, and so
				  on. The problem is that the tool builders themselves
				  are responsible for making their tools interoperable
				  with other tools or development environments.
				  Because they cannot anticipate all other tools they
				  can integrate with, a lot of tools cannot
				  co-operate. This paper introduces the classication
				  model, a lightweight integration medium that enables
				  unrelated tools that were not meant to be integrated
				  to cooperate easily. Moreover, the tool integration
				  is done by a tool integrator, and not by the tool
				  builder. To validate this claim, we show how to
				  integrate several third-party tools using the
				  classication model, and how it forms the foundation
				  for the StarBrowser, a Smalltalk browser integrating
				  different tools.},
	Annote = {internationaljournal},
	Author = {Roel Wuyts and St\'ephane Ducasse},
	Doi = {10.1016/j.cl.2003.08.003},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {recast04 scg-pub scg-none jb04 decomp-pub},
	Misc = {SCI impact factor 0.176},
	Number = {1-2},
	Pages = {63--77},
	Publisher = {Elsevier},
	Title = {Unanticipated Integration of Development Tools using the Classification Model},
	Url = {http://scg.unibe.ch/archive/papers/Wuyt04aClassifications.pdf},
	Volume = {30},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Wuyt04aClassifications.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.cl.2003.08.003}}

@inproceedings{Wuyt04x,
	Abstract = {This paper reports on the results of the Fifth
				  International Workshop on Object-Oriented
				  Reengineering in Oslo on June 15, 2004. It
				  enumerates the presentations made, classifies the
				  contributions and lists the main results of the
				  discussions held at the workshop. As such it
				  provides the context for future workshops around
				  this topic.},
	Annote = {workshopproceedings},
	Author = {Roel Wuyts and Serge Demeyer and St\'ephane Ducasse and Kim Mens},
	Booktitle = {Object-Oriented Technology. ECOOP'04 Workshop Reader},
	Doi = {10.1007/b104146},
	Isbn = {978-3-540-23988-8},
	Keywords = {scg-pub scg-none jb04 stefPub recast04},
	Pages = {177--186},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Report of the {ECOOP}'04 Workshop on Object-Oriented Reengineering},
	Url = {http://scg.unibe.ch/archive/papers/Wuyt04x-OOR04Report.pdf},
	Volume = {3344},
	Year = {2004},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Wuyt04x-OOR04Report.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1007/b104146}}

@article{Wuyt05a,
	Abstract = {Software for embedded systems must cope with a
				  variety of stringent constraints, such as real-time
				  requirements, small memory footprints, and low power
				  consumption. It is usually implemented using
				  low-level programming languages, and as a result has
				  not benefitted from component-based software
				  development techniques. This paper describes a
				  \emph{data-centric component model} for embedded
				  devices that (i) minimizes the number of concurrent
				  tasks needed to implement the system, (ii) allows
				  one to verify whether components meet their
				  deadlines by applying Rate Monotonic Analysis (RMA),
				  and (iii) can generate and verify schedules using
				  Constraint Logic Programming (CLP). This model forms
				  the foundation for a suite of tools for specifying,
				  composing, verifying and deploying embedded software
				  components developed in the context of the PECOS
				  project.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Roel Wuyts and St\'ephane Ducasse and Oscar Nierstrasz},
	Cvs = {PecosJournalPaper},
	Doi = {10.1016/j.jss.2003.05.004},
	Inria = {hors},
	Journal = {Journal of Systems and Software --- Special Issue on Automated Component-Based Software Engineering},
	Keywords = {scg-pub scg-none jb03 pecos stefPub},
	Misc = {SCI impact factor 0.744},
	Number = {1},
	Pages = {25--34},
	Publisher = {Elsevier},
	Title = {A Data-centric Approach to Composing Embedded, Real-time Software Components},
	Url = {http://scg.unibe.ch/archive/papers/Wuyt05aPecosElsevier.pdf},
	Volume = {74},
	Year = {2005},
	Bdsk-Url-1 = {http://scg.unibe.ch/archive/papers/Wuyt05aPecosElsevier.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1016/j.jss.2003.05.004}}

@inproceedings{Zaid06a,
	Annote = {internationalconference},
	Author = {Andy Zaidman and Orla Greevy and Abdelwahab Hamou-Lhadj},
	Booktitle = {Proceedings of IEEE 13th Working Conference on Software Maintenance and Reengineering (WCRE)},
	Doi = {10.1109/WCRE.2006.45},
	Keywords = {scg-pub skip-abstract greevy scg-none jb07 fb06 Dynamic Analysis moose-pub recast07},
	Medium = {2},
	Month = oct,
	Pages = {315--315},
	Peerreview = {yes},
	Title = {Workshop on Program Comprehension through Dynamic Analysis ({PCODA})},
	Url = {http://www.lore.ua.ac.be/Events/PCODA2006/pcoda2006proceedings.pdf},
	Year = {2006},
	Bdsk-Url-1 = {http://www.lore.ua.ac.be/Events/PCODA2006/pcoda2006proceedings.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.2006.45}}

@inproceedings{Zaid08a,
	Annote = {internationalconference},
	Author = {Andy Zaidman and Orla Greevy and Abdelwahab Hamou-Lhadj and David R\"othlisberger},
	Bdsk-Url-1 = {http://swerl.tudelft.nl/bin/view/PCODA/PCODA2008 http://scg.unibe.ch/archive/papers/Zaid08a-pcoda2008proceedings.pdf},
	Booktitle = {Proceedings of IEEE 15th Working Conference on Software Maintenance and Reengineering (WCRE)},
	Doi = {10.1109/WCRE.2008.21},
	Keywords = {scg08 scg-pub skip-abstract greevy roethlisberger jb09 snf09 Dynamic Analysis},
	Medium = {2},
	Month = oct,
	Pages = {345--346},
	Peerreview = {yes},
	Title = {Workshop on Program Comprehension through Dynamic Analysis ({PCODA})},
	Url = {http://swerl.tudelft.nl/bin/view/PCODA/PCODA2008 http://scg.unibe.ch/archive/papers/Zaid08a-pcoda2008proceedings.pdf},
	Year = {2008},
	Bdsk-Url-2 = {http://dx.doi.org/10.1109/WCRE.2008.21},
	Bdsk-Url-3 = {http://swerl.tudelft.nl/bin/view/PCODA/PCODA2008%20http://scg.unibe.ch/archive/papers/Zaid08a-pcoda2008proceedings.pdf}}

